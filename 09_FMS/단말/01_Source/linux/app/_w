/*********************************************************************
	file : control.c
	description :
	product by tory45( tory45@empal.com) ( 2016.08.05 )
	update by ?? ( . . . )

 ********************************************************************/
#include "com_include.h"
#include "sem.h"
#include "control.h"

//#include "fms_client.h"
//#include "op_server.h"
//#include "update_client.h"
#include "radio.h"
#include "gpio_mcu.h"
#include "pwr_c.h"
#include "remote.h"
#include "temp.h"
#include "apc_ups.h"
#include "pwr_m.h"
#include "pwr_mng.h"
#include "ctrl_db.h"

#define DI_UN_VAL                       9
#define SNSR_ID_UNKOWN                  9999
#define SNSR_VAL_UNKNOWN                999999
#define MAX_RELEASE_TIME                ( 60 * 6 )
#define MAX_ONOFF_CNT					10

//#define MAX_SEND_MOR_RADIO_TIME		60 * 5 /* 5 MIN */
#define MAX_SEND_MOR_RADIO_TIME		1   5 /* 5 MIN */

#define MOR_DATA				0
#define CUR_DATA				1

#define MAX_CLIENT_CNT			15

#define SNS_ONOFF_MCU			1
#define SNS_ONOFF_REMOTE		2
#define SNS_ONOFF_PWR_C			3

#define NET_RTU					1
#define NET_FMS					2
#define NET_OP					3
#define NET_FRE					4
#define NET_SRE					5
#define NET_FDE					6
#define NET_UPS					7
#define NET_CAM					8
#define NET_MAX_CNT				NET_CAM
#define MAX_CUR_NET_CNT			10

typedef struct cur_req_
{
	volatile int clientid;
	volatile UINT32 last_send_time;
}cur_req_t;

typedef struct sns_onoff_sts_
{
	volatile int snsr_id;
	volatile int clientid;
	volatile int sns_type;
	
	fms_ctl_base_t ctl_base;
}sns_onoff_sts_t;

typedef struct cur_net_info_
{
	volatile int type;
	net_info_t net;
}cur_net_info_t;

typedef struct cur_net_mng_
{
	volatile int cnt;
	cur_net_info_t nets[ MAX_CUR_NET_CNT ];
}cur_net_mng_t;

typedef struct eqp_auto_
{
    volatile int run;
    volatile UINT32 run_time;
}eqp_auto_t;

typedef struct sns_proc_exist_
{
	volatile int proc_id;
	volatile int used;
}sns_proc_used_t;

typedef struct sns_proc_mng_
{
	volatile int cnt;
	sns_proc_used_t proc_list[ MAX_PROC_CNT ];
}sns_proc_mng_t;
/*================================================================================================
 전역 변수 
================================================================================================*/
static volatile int g_ctrl_sem_key 						= CTRL_SEM_KEY;
static volatile int g_ctrl_sem_id 						= 0;

static send_data_func g_ptrsend_fms_client = NULL;
static send_data_func g_ptrsend_op_server = NULL;
static send_data_func g_ptrsend_update = NULL;
static send_data_func g_ptrsend_websock = NULL;

static send_data_func g_ptrsend_data_radio = NULL;
static send_data_func g_ptrsend_data_mcu = NULL;
static send_data_func g_ptrsend_data_pwr_c = NULL;
static send_data_func g_ptrsend_data_remote = NULL;
static send_data_func g_ptrsend_data_temp = NULL;
static send_data_func g_ptrsend_data_pwr_m = NULL;
static send_data_func g_ptrsend_data_apc_ups = NULL;

static volatile int g_trans_func_cnt 	= 0;
static volatile int g_update_func_cnt 	= 0;
static volatile int g_sns_func_cnt		= 0;
static eqp_auto_t  g_eqp_auto; 
/*================================================================================================
  Sensor 처리 변수 함수선언
================================================================================================*/
/* 실시간 데이터/ 모니터링 데이터 전송 시간 */
static volatile int g_checked_ver = 0;
static volatile int g_chk_sns = 0;
static volatile int g_chk_sns2 = 0;

static volatile UINT32 g_last_mor_send_time = 0;
static volatile UINT32 g_last_req_time_send_time = 0;
static ver_info_t g_version;
static volatile int g_dido_send_cnt			= 40;
static volatile int g_ai_send_cnt			= 80;
static volatile int g_reboot                = 0;

/* cur data req */
static volatile int g_clientid 				= 0;
static cur_req_t g_cur_req[ MAX_CLIENT_CNT ];
static sns_proc_mng_t g_proc_mng;

/* gpio value */
static volatile int g_mcu_sr_timeout		= ESNSRCNNST_NORMAL;

static di_val_t g_di_val[ MAX_GPIO_CNT ];
static do_val_t g_do_val[ MAX_GPIO_CNT ] ;
static doe_val_t g_doe_val[ MAX_GPIO_CNT ] ;

static sns_onoff_sts_t g_sns_onoff_sts[ MAX_ONOFF_CNT ];
static cur_net_mng_t g_cur_net_mng;

static int load_di_val( void );
static int load_di_ups_val( void );
static int load_ai_val( void );
static int load_ai_ups_val( void );


static int load_do_val( void );
static int load_rtu_fclt_info( void );
static int load_eqp_fclt_info( void );
static int load_sns_col_val( void );

static int load_rtu_info( void );

/* temprature */
static temp_val_t g_temp_val[ MAX_TEMP_CNT ];
static volatile int g_temp_sr_timeout		= ESNSRCNNST_NORMAL;

/* power control */
static pwr_c_val_t g_pwr_c_val[ MAX_PWR_C_PORT_CNT ];
static pwr_c_data_t g_pwr_c_data;
static volatile int g_pwr_c_sr_timeout		= ESNSRCNNST_NORMAL;

/* power monitor */
static pwr_m_val_t g_pwr_m_val[ MAX_PWR_M_CNT ];
static volatile int g_pwr_m_sr_timeout		= ESNSRCNNST_NORMAL;

/* remote */
static remote_val_t g_remote_val;
static volatile int g_remote_sr_timeout		= ESNSRCNNST_NORMAL;

/* video */
static di_val_t g_video_val;
static volatile int g_video_tcp_timeout		= ESNSRCNNST_NORMAL;

/* ground */
static di_val_t g_ground_val;

/* APC UPS  */
static di_val_t g_apc_ups_di_val[ MAX_APC_UPS_DATA_CNT ];
static ai_val_t g_apc_ups_ai_val[ MAX_APC_UPS_DATA_CNT ];
static volatile int g_apc_ups_sr_timeout	= ESNSRCNNST_NORMAL;

/* power dev ( power c + mcu etc */
static pwr_dev_val_t g_pwr_dev_val[ MAX_PWR_DEV_CNT ];
static int load_pwr_dev_val( void );

/* faclt */
static fclt_info_t g_fclt_info[ MAX_FCLT_CNT ];
static radio_val_manager_t g_fre_mng;	/* 고정 */
static radio_val_manager_t g_frs_mng;	/* 고정 운영 */
static radio_val_manager_t g_sre_mng;	/* 준고정 */
static radio_val_manager_t g_fde_mng;	/* 고정 방탐 */

/* rtu fclt */
static fclt_info_t g_rtu_fclt_info[ MAX_FCLT_CNT ];

/* radio */
static volatile UINT32 g_last_mor_radio_send_time = 0;
static volatile int g_fre_tcp_sts	= ESNSRCNNST_NORMAL;
static volatile int g_sre_tcp_sts	= ESNSRCNNST_NORMAL;
static volatile int g_fde_tcp_sts	= ESNSRCNNST_NORMAL;

static volatile int g_fre_fclt_code	= EFCLT_EQP01 ;
static volatile int g_frs_fclt_code	= ( EFCLT_EQP01  + 1 );
static volatile int g_sre_fclt_code	= ( EFCLT_EQP01  + 2 );
static volatile int g_fde_fclt_code	= ( EFCLT_EQP01  + 3 );

static cur_req_t g_cur_fre_req[ MAX_CLIENT_CNT ];
static cur_req_t g_cur_frs_req[ MAX_CLIENT_CNT ];
static cur_req_t g_cur_sre_req[ MAX_CLIENT_CNT ];
static cur_req_t g_cur_fde_req[ MAX_CLIENT_CNT ];

static volatile int g_first_mcu = 0;
static volatile int g_first_pwr_c = 0;

/*================================================================================================
  내부 함수선언
================================================================================================*/
/* for debug */
static char g_recv_buf[ 100  ];
static volatile int g_rtu_test				= 0;
static volatile int g_di_test				= 0;
static volatile int g_debug_fd 				= -1;

/* thread ( debug )*/
static pthread_t debug_pthread;
static void * pthread_debug_idle( void * ptrdata );
static volatile int g_control_run_cnt = 0;
static volatile int start_debug_pthread = 0;
static volatile int end_debug_pthread = 1;

static int cli_test( char * ptrdata , int size );

/* thread ( control )*/
static volatile int g_start_ctrl_pthread 	= 0; 
static volatile int g_end_ctrl_pthread 		= 1; 
static pthread_t ctrl_pthread;
static void * ctrl_pthread_idle( void * ptrdata );

/* thread( radio )*/
static volatile int g_start_radio_pthread 	= 0; 
static volatile int g_end_radio_pthread 	= 1; 
static pthread_t radio_pthread;
static void * radio_pthread_idle( void * ptrdata );

static volatile int g_release				= 0;


static int internal_init( void );
static int internal_idle( void * ptr );
static int internal_release( void );

/* 내부 메시지 전달 */
static int send_network_chang( int msg );
static int get_fclt_ip_port( int fcltcode, char * ptrip, unsigned short * ptrport );
static int get_rtu_fclt_ip_port( int fcltcode, char * ptrip, unsigned short * ptrport );

/* Transfer 전달 함수 */
/* 모니터링_실시간데이터 */
static int send_dido_data(int clientid, UINT16 cmd, int send_op );
static int send_ai_data(int clientid, UINT16 cmd, int send_op );
static int send_req_time(void );
static int send_base_db_update_res( int ret , int clientid, int editinfo , int ctlcmd  );
static int load_db( void );

/* 임계값 처리 */
static int send_di_thrd_fms(int clientid, fclt_ctl_thrlddi_t * ptrdi_thrd, int sns_type, UINT16 cmd );
static int send_di_thrd_complet(int clientid,int sts, fclt_ctl_thrlddi_t * ptrdi_thrd , UINT16 cmd , int result);

static int send_ai_thrd_fms(int clientid, fclt_ctl_thrldai_t * ptrai_thrd );
static int send_ai_thrd_complet(int clientid,int sts, fclt_ctl_thrldai_t * ptrai_thrd , int result );

/* MCU/Remote ON/OFF 처리 */
static int send_onoff_fms(int clientid, fclt_ctrl_snsronoff_t * ptronoff ); 
static int send_snsr_onoff_result_fms( int result );
static int send_pwr_c_onoff_result_fms( int result );

static int send_snsr_remote_result_fms( int result );

/* RADIO 처리 */
static int check_mor_radio_data( UINT32 cur_time );


/* control --> transfer */
static int send_data_transfer( UINT16 inter_msg, void * ptrdata, int opsend );
static int send_update_transfer( UINT16 inter_msg, void * ptrdata );

/* transfer -> contro l*/
static int internal_recv_cmd_data_transfer( UINT16 inter_msg, void * ptrdata ); 
static int internal_recv_update_transfer( UINT16 inter_msg, void * ptrdata ); 
static int internal_recv_cmd_data_websock( UINT16 inter_msg, void * ptrdata ); 


/* not used */
static int internal_recv_sns_data_sensor( unsigned short inter_msg, void * ptrdata );

/* sensor layer 전달 함수 */
/* MCU, RADIO, PWR_C, REMOTE, TEMP, PWR_M */
static int send_data_mcu( UINT16 inter_msg, void * ptrdata );
static int send_data_pwr_c( UINT16 inter_msg, void * ptrdata );
static int send_data_remote( UINT16 inter_msg, void * ptrdata );
static int send_data_radio( UINT16 inter_msg, void * ptrdata );

/* sensor recv transfer req */
static int recv_data_req( UINT16 inter_msg, void * ptrdata );
static int recv_threshold_req( UINT16 inter_msg, void * ptrdata );
static int recv_onoff_req( UINT16 inter_msg, void * ptrdata );

/* radio recv transfer req */
static int send_fre_data(int clientid, UINT16 cmd, int send_op );
static int send_frs_data(int clientid, UINT16 cmd, int send_op );
static int send_sre_data(int clientid, UINT16 cmd, int send_op );
static int send_fde_data(int clientid, UINT16 cmd, int send_op );

static int send_fclt_netsts( int fcltcode, int sts , int snsr_sub_type );
static int send_sns_netsts(  int sts, int snsr_type, int snsr_sub_type, int snsr_id );

static int recv_radio_data_req( UINT16 inter_msg, void * ptrdata);
static int recv_radio_threshold_req( UINT16 inter_msg, void * ptrdata );

static int recv_radio_eqp_pwr_req( UINT16 inter_msg, void * ptrdata );
static int recv_radio_eqp_pwr_ack( UINT16 inter_msg, void * ptrdata );
static int recv_radio_eqp_res_ack( UINT16 inter_msg, void * ptrdata );

/* etc */
static int recv_dbupdate_req( UINT16 inter_msg, void * ptrdata );
static int recv_timesync_req( UINT16 inter_msg, void * ptrdata );
static int recv_fclt_netinfo_req( UINT16 inter_msg, void * ptrdata );

/* 2016 11 14 new protocol */
static int recv_radio_eqp_off_option( UINT16 inter_msg, void * ptrdata );
static int recv_radio_eqp_on_option( UINT16 inter_msg, void * ptrdata );
static int recv_radio_eqp_status( UINT16 inter_msg, void * ptrdata );
static int recv_radio_eqp_net_status( UINT16 inter_msg, void * ptrdata );

static int recv_allim_msg( UINT16 inter_msg, void * ptrdata );
static int recv_allim_web_req( UINT16 inter_msg, void * ptrdata );
static int recv_web_firm_update_req( UINT16 inter_msg, void * ptrdata );

/*================================================================================================
 internal msg에 따른 Struct 구조체 
 transfer(fms client, op server ) Msg 구조체
 update Msg 구조체 
 sensor Msg구조체 
================================================================================================*/
static proc_func_t trans_proc_list[] =
{
	/* sensor */
	{ EFT_SNSRCUDAT_REQ, 				recv_data_req },		/* 실시간데이터 요청 */
	{ EFT_SNSRCTL_THRLD, 				recv_threshold_req },	/* 센서 임계값  제어 */
	{ EFT_SNSRCTL_POWER, 				recv_onoff_req },		/* 센서 전원  설정 */

	/* radio */
	{ EFT_EQPCUDAT_REQ, 				recv_radio_data_req },		/* 실시간데이터 요청 */
	{ EFT_EQPCTL_THRLD, 				recv_radio_threshold_req },	/* 센서 임계값  제어 */

	/* radio pwr control */
	{ EFT_EQPCTL_POWER, 				recv_radio_eqp_pwr_req},	/* 전원제어 요청 ON/OFF */
	{ EFT_EQPCTL_POWERACK, 				recv_radio_eqp_pwr_ack},	/* 전원제어 응답  */
	{ EFT_EQPCTL_RESACK, 				recv_radio_eqp_res_ack},	/* 전원제어 상태 응답  */
	
	/* 2016 11 14 new protocol */
	{ EFT_EQPCTL_POWEROPT_OFF, 			recv_radio_eqp_off_option },	/* 전원제어 옵션 요청 ON/OFF */
	{ EFT_EQPCTL_POWEROPT_ON, 			recv_radio_eqp_on_option },	/* 전원제어 옵션 요청 ON/OFF */
	{ EFT_EQPCTL_STATUS_REQ, 			recv_radio_eqp_status },	/* EQP 제어 상태 요청 */
	{ EFT_EQPCTL_CNNSTATUS_REQ, 		recv_radio_eqp_net_status },	/* EQP 네트워크 상태 요청  */
	
	/* etc */
	{ EFT_EVT_BASEDATUPDATE_REQ, 	recv_dbupdate_req },		/* db update 요청 */
	{ EFT_TIMEDAT_RES, 				recv_timesync_req },

    { EFT_FCLTNETINFO_REQ,              recv_fclt_netinfo_req },
	
	/* 내부 통신용 message */
	{ EFT_ALLIM_MSG,					recv_allim_msg },
	{ EFT_ALLIM_WEB_REQ,				recv_allim_web_req },
	{ EFT_EVT_FIRMWAREUPDATE_REQ,		recv_web_firm_update_req},
	{ 0, NULL }
};

static proc_func_t update_proc_list[] =
{
	{ EFT_ALLIM_MSG,					recv_allim_msg },
	{ 0, NULL }
};

static proc_func_t sns_proc_list[] =
{
	//{ EFT_SNSRDAT_RES, send_data_transfer }, 
	{ 0, NULL }
};
/*================================================================================================
  recv 함수  정의 
================================================================================================*/
static int print_proc_used( void )
{
	int i, cnt;
	int used = 0;
	int l_proc_id;

	cnt = g_proc_mng.cnt;
	
	/* 존재할때 */
	for( i = 0 ; i < cnt ; i++ )
	{
		l_proc_id 	= g_proc_mng.proc_list[ i ].proc_id;
		used 		= g_proc_mng.proc_list[ i ].used;
		print_dbg( DBG_SAVE,1, "####### SET PROC ID USED:%d, %d, ", l_proc_id , used );
	}
	
	return ERR_SUCCESS;
}

static int set_proc_used( int proc_id, int val )
{
	
	int i, cnt;
	int used = 0;
	int l_proc_id;

	cnt = g_proc_mng.cnt;
	
	/* 존재할때 */
	for( i = 0 ; i < cnt ; i++ )
	{
		l_proc_id 	= g_proc_mng.proc_list[ i ].proc_id;
		if ( proc_id == l_proc_id )
		{
			g_proc_mng.proc_list[ i ].used = val;
			used = 1;
			print_dbg( DBG_SAVE,1, "####### PROC ID USED:%d, %d, ", proc_id , val );
			break;
		}
	}

	/* 존재 하지 않을 때 */
	if ( used == 0 )
	{
		for( i = 0 ; i < MAX_PROC_CNT ; i++ )
		{
			l_proc_id 	= g_proc_mng.proc_list[ i ].proc_id;
			if ( l_proc_id == 0 )
			{
				g_proc_mng.proc_list[ i ].proc_id= proc_id;
				g_proc_mng.proc_list[ i ].used = val;
				g_proc_mng.cnt++;
				print_dbg( DBG_SAVE,1, "####### PROC ID USED:%d, %d", proc_id, val );
				break;
			}
		}
	}

	return ERR_SUCCESS;
}

int get_proc_used( int proc_id )
{
	int i, cnt;
	int used = 0;
	int l_proc_id;
	cnt = g_proc_mng.cnt;
	
	for( i = 0 ; i < cnt ; i++ )
	{
		l_proc_id 	= g_proc_mng.proc_list[ i ].proc_id;
		used 		= g_proc_mng.proc_list[ i ].used;

		if ( proc_id == l_proc_id )
		{
			return used;
		}
	}

	return used;
}

static int create_debug_thread( void )
{
	/* msgqueue thread */
	if ( start_debug_pthread == 0 && end_debug_pthread == 1 )
	{
		if ( pthread_create( &debug_pthread, NULL, pthread_debug_idle, NULL ) < 0 )
		{
			//printf("err create network  pop queue thread....\n");
		}
		else
		{
			start_debug_pthread = 1;
		}
	}

	return ERR_SUCCESS;
}

static int create_debug_sock( void )
{
	int fd =-1; 
	struct sockaddr_in sockaddr;
	int so_reuseaddr;
	int err=ERR_SUCCESS;

	if ( g_debug_fd  > 0 )
		return 0;

	fd = socket( PF_INET, SOCK_DGRAM, 0 ); 
	if ( fd < ERR_SUCCESS )
	{    
		print_dbg(DBG_ERR, 1, "Fail to Create Debug socket");
		return ERR_RETURN;
	}    

	so_reuseaddr = 1; 
	setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &so_reuseaddr, sizeof (so_reuseaddr));

	memset(&sockaddr, 0, sizeof(sockaddr));
	sockaddr.sin_family = AF_INET;
	sockaddr.sin_addr.s_addr = inet_addr( DEBUG_IP );
	sockaddr.sin_port = htons( DEBUG_PORT + 1 );

	err = bind( fd, (struct sockaddr *) &sockaddr, sizeof( sockaddr ));
	if ( err != ERR_SUCCESS )
	{    
		close( fd );
		print_dbg(DBG_ERR, 1, "Fail to create debuger bind port( %d )", DEBUG_PORT );
		return ERR_RETURN ;
	}    

	g_debug_fd = fd;
	return ERR_SUCCESS;
}

static int read_debug( void )
{
	int n;
	struct sockaddr_in clientaddr;
	socklen_t len;

	if ( g_debug_fd < 0 )
		return ERR_RETURN;

	memset( g_recv_buf, 0, sizeof( g_recv_buf ));
	len = sizeof( clientaddr );
	n = recvfrom( g_debug_fd, ( void *)g_recv_buf, sizeof( g_recv_buf ), 0, ( struct sockaddr *)&clientaddr, &len );
	
	if ( n > 0 )
	{
		g_recv_buf[ n ] = 0x00;
		if ( strcmp( g_recv_buf, "T") == 0 )
		{
			g_rtu_test = 1;
            g_di_test  = 0;
			set_print_debug_shm( 0 );

			print_dbg( DBG_INFO,1,"######## Recv from DEBUGER with Test Mode");
		}
		else if ( strcmp( g_recv_buf, "R") == 0  )
		{
			g_rtu_test = 0;
            g_di_test  = 0;
			set_print_debug_shm( 0 );

			print_dbg( DBG_INFO,1,"######## Recv from DEBUGER with Release Mode");
		}
		else
		{
			cli_test( g_recv_buf, n );
		}
	}

	return ERR_SUCCESS;
}

int send_debug_data( char * ptrdata, int size )
{
	struct sockaddr_in sockaddr;
	if ( ptrdata == NULL )
	{
		return ERR_RETURN;
	}

	if ( g_debug_fd > 0 )
	{
		memset(&sockaddr, 0, sizeof(sockaddr));

		sockaddr.sin_family = AF_INET;
		sockaddr.sin_addr.s_addr = inet_addr( DEBUG_IP );
		sockaddr.sin_port = htons( DEBUG_PORT );
		sendto( g_debug_fd, ptrdata, size,  0, ( struct sockaddr * )&sockaddr, sizeof( sockaddr) );
	}

	return ERR_SUCCESS;
}

static void * pthread_debug_idle( void * ptrdata )
{
	( void ) ptrdata;
	int status;

	end_debug_pthread = 0;

	while ( g_release == 0  )
	{
		read_debug( );
	}

	pthread_join( debug_pthread , ( void **)&status );
	start_debug_pthread =0;
	end_debug_pthread = 1;

	return ERR_SUCCESS;
}

static int check_rtu_net_change( rtu_info_t * ptrrtu )
{
	char * ptrip = NULL;

	int net_type = 0;

	UINT16 port = 0;
	int i , cnt;
	//int chg_rtu = 0;
	int chg_fms = 0;
	int chg_op  = 0;

	if ( ptrrtu == NULL )
	{
		print_dbg( DBG_ERR,1, "is null ptrrtu [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	cnt = g_cur_net_mng.cnt;

	//char * ptrifname = NULL;
	//char * ptrnet = NULL;
	//char * ptrgate = NULL;
	//static volatile int first = 0;
	//ptrifname = get_ifname_shm();

	print_dbg(DBG_INFO,1,"Count of Current Network Info :%d", cnt );

	for( i = 0 ; i < cnt ;i++ )
	{
		net_type 	= g_cur_net_mng.nets[ i ].type;
		ptrip		= g_cur_net_mng.nets[ i ].net.ip;
		//ptrnet		= g_cur_net_mng.nets[ i ].net.netmask;
		//ptrgate	 	= g_cur_net_mng.nets[ i ].net.gateway;
		port		= g_cur_net_mng.nets[ i ].net.port;
        
       // chg_rtu = 0;

		/* RTU NET 확인  */
		if ( net_type == NET_RTU )
		{
			/* RTU IP는 CLI를 통해서만 바꾼다. 2016-10-30 */
#if 0
			if( strlen( ptrip ) != 0  && strlen( ptrrtu->net.ip ) != 0 && strcmp( ptrip , ptrrtu->net.ip) != 0)
			{
				chg_rtu =1;
				print_dbg( DBG_INFO,1, "Change Of RTU IP (%s ->%s)", ptrip, ptrrtu->net.ip);
			}
			else if( strlen( ptrip ) ==  0 && strlen( ptrrtu->net.ip ) != 0 )
			{
				memcpy( ptrip , ptrrtu->net.ip, MAX_IP_SIZE );
			}

			if( strlen( ptrnet ) != 0 && strlen( ptrrtu->net.netmask ) != 0 && strcmp( ptrnet , ptrrtu->net.netmask ) != 0 )
			{
				chg_rtu =1;
				print_dbg( DBG_INFO,1, "Change Of RTU NETMASK (%s ->%s)", ptrnet, ptrrtu->net.netmask );
			}
			else if( strlen( ptrnet ) == 0 && strlen( ptrrtu->net.netmask ) != 0)
			{
				memcpy( ptrnet , ptrrtu->net.netmask, MAX_IP_SIZE );
			}

			if( strlen( ptrgate ) != 0 && strlen( ptrrtu->net.gateway ) != 0 && strcmp( ptrgate , ptrrtu->net.gateway) != 0)
			{
				chg_rtu =1;
				print_dbg( DBG_INFO,1, "Change Of RTU GATEWAY(%s ->%s)", ptrgate, ptrrtu->net.gateway );
			}
			else if (strlen( ptrgate ) == 0 && strlen( ptrrtu->net.gateway ) != 0) 
			{
				memcpy( ptrgate , ptrrtu->net.gateway, MAX_IP_SIZE );
			}

			if ( first== 0 || chg_rtu == 1 )
			{
				memset( ptrip , 0,  MAX_IP_SIZE );
				memset( ptrnet, 0,  MAX_IP_SIZE );
				memset( ptrgate , 0, MAX_IP_SIZE );

				memcpy( ptrip , ptrrtu->net.ip, MAX_IP_SIZE );
				memcpy( ptrnet , ptrrtu->net.netmask, MAX_IP_SIZE );
				memcpy( ptrgate , ptrrtu->net.gateway, MAX_IP_SIZE );

				/* RTU 정보 변경 전달 */
				/* FMS, OP, RADIO, 영상, util */

				change_netmask( ptrifname, ptrip, ptrnet );
				change_gateway( ptrgate );
				first = 1;
				if ( chg_rtu == 1 && g_eqp_auto.run == 0 )
				{
			        //set_rtu_net_shm( &ptrrtu->net );
					//sys_sleep( 500 );
					//send_network_chang( ALM_RTU_NET_CHG_NOTI_MSG );
                    g_reboot =1;
                    print_dbg( DBG_ERR, 1, "Reboot RTU becase of IP Change !! ");
                    sys_sleep( 3000 );
		            //system_cmd("reboot");
                    killall( APP_PNAME, 9 );
                    killall( APP_PNAME, 9 );


				}
                else if ( g_eqp_auto.run == 1 )
                {
                    print_dbg( DBG_ERR, 1, "Can not RTU Reboot With RTU IP Change, becase of  EPQ AUTOMOD run" );
                }
            }
#endif
		}
		/* FMS 확인 */
		else if ( net_type == NET_FMS )
		{
			if( strlen( ptrip ) != 0  && strlen( ptrrtu->fms_server_ip ) != 0 && strcmp( ptrip , ptrrtu->fms_server_ip ) != 0)
			{
				chg_fms =1;
				print_dbg( DBG_INFO,1, "Change Of FMS SERVER ip(%s ->%s)", ptrip, ptrrtu->fms_server_ip );
				memset( ptrip , 0,  MAX_IP_SIZE );
				memcpy( ptrip , ptrrtu->fms_server_ip, MAX_IP_SIZE );

			}
			else if ( strlen( ptrip ) == 0  && strlen( ptrrtu->fms_server_ip ) != 0  )
			{
				memset( ptrip , 0,  MAX_IP_SIZE );
				memcpy( ptrip , ptrrtu->fms_server_ip, MAX_IP_SIZE );
			}

			if( port != 0  && ptrrtu->fms_server_port != 0 && (port != ptrrtu->fms_server_port ))
			{
				chg_fms =1;
				print_dbg( DBG_INFO,1, "Change Of FMS SERVER Port(%d ->%d)", port, ptrrtu->fms_server_port );
				g_cur_net_mng.nets[ i ].net.port = ptrrtu->fms_server_port;
			}
			else if ( port == 0  && ptrrtu->fms_server_port != 0 )
			{
				g_cur_net_mng.nets[ i ].net.port = ptrrtu->fms_server_port;
			}

			if ( chg_fms == 1 )
			{
				//memset( ptrip , 0,  MAX_IP_SIZE );
				//memcpy( ptrip , ptrrtu->fms_server_ip, MAX_IP_SIZE );
				//g_cur_net_mng.nets[ i ].net.port = ptrrtu->fms_server_port;

			    set_fms_net_shm( ptrrtu->fms_server_ip, ptrrtu->fms_server_port );
				sys_sleep( 500 );
				
				/* RTU 정보 변경 전달 */
				/* FMS  */
				send_network_chang( ALM_FMS_NET_CHG_NOTI_MSG );
			}
		}
		else if ( net_type == NET_OP )
		{
			if( port != 0  && ptrrtu->op_port != 0 && (port != ptrrtu->op_port ))
			{
				chg_op =1;
				print_dbg( DBG_INFO,1, "Change Of OP Listen Port(%d ->%d)", port, ptrrtu->op_port );
				g_cur_net_mng.nets[ i ].net.port = ptrrtu->op_port;
			}
			else if ( port == 0  && ptrrtu->op_port != 0 )
			{
				g_cur_net_mng.nets[ i ].net.port = ptrrtu->op_port;
			}

			if ( chg_op == 1 )
			{
				/* RTU 정보 변경 전달 */
				/* OP  */
			    set_op_net_shm( ptrrtu->op_port );
				sys_sleep( 500 );
				send_network_chang( ALM_OP_NET_CHG_NOTI_MSG );
			}
		}
	}
	
	return ERR_SUCCESS;
}

static int set_cur_req_client( int type , int clientid )
{
	int i ;
	int l_id;

	/* insert */
	if ( type == 1 )
	{
		for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
		{
			l_id = g_cur_req[ i ].clientid;
			if ( l_id == clientid )
			{
				g_cur_req[ i ].last_send_time = 0;
			    return ERR_SUCCESS;	
			}
		}

		for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
		{
			l_id = g_cur_req[ i ].clientid;
			if ( l_id == 0 )
			{
				g_cur_req[ i ].clientid = clientid ;
				g_cur_req[ i ].last_send_time = 0;

                print_dbg( DBG_INFO, 1, "Insert of ClientID int Cur Sns Buf :%d", clientid );
				break;
			}
		}
	}
	/* delete */
	else
	{
		for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
		{
			l_id = g_cur_req[ i ].clientid;
			if ( l_id == clientid )
			{
				g_cur_req[ i ].clientid = 0;
				g_cur_req[ i ].last_send_time = 0;
                print_dbg( DBG_INFO, 1, "Del of ClientID int Cur Sns Buf :%d", clientid );
				break;
			}
		}
	}
	return ERR_SUCCESS;
}

static int set_cur_radio_req_all_client( int type, int clientid )
{
	int i;
	int l_id;
	cur_req_t * req = NULL;

	for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
	{
		/* fre */
		req = (cur_req_t *)&g_cur_fre_req[ i ]; 
		if ( req != NULL )
		{
			l_id = req->clientid;
			if ( l_id == clientid )
			{
				req->clientid = 0;
				print_dbg( DBG_INFO,1,"Set Cur Radio Pos:%d, Type:%d, ClientID:%d", i, type, clientid );
			}
		}

		/* frs */
		req = (cur_req_t *)&g_cur_frs_req[ i ]; 
		if ( req != NULL )
		{
			l_id = req->clientid;
			if ( l_id == clientid )
			{
				req->clientid = 0;
				print_dbg( DBG_INFO,1,"Set Cur Radio Pos:%d, Type:%d, ClientID:%d", i, type, clientid );
			}
		}

		/* sre */
		req = (cur_req_t *)&g_cur_sre_req[ i ]; 
		if ( req != NULL )
		{
			l_id = req->clientid;
			if ( l_id == clientid )
			{
				req->clientid = 0;
				print_dbg( DBG_INFO,1,"Set Cur Radio Pos:%d, Type:%d, ClientID:%d", i, type, clientid );
			}
		}

		/* fde */
		req = (cur_req_t *)&g_cur_fde_req[ i ]; 
		if ( req != NULL )
		{
			l_id = req->clientid;
			if ( l_id == clientid )
			{
				req->clientid = 0;
				print_dbg( DBG_INFO,1,"Set Cur Radio Pos:%d, Type:%d, ClientID:%d", i, type, clientid );
			}
		}
	}

	return ERR_SUCCESS;
}

static int set_cur_radio_req_client( int fclt_code, int type , int clientid )
{
	int i ;
	int l_id;
	cur_req_t * ptrreq = NULL;
	cur_req_t * req = NULL;
	
	if ( fclt_code == g_fre_fclt_code )
	{
		ptrreq =  &g_cur_fre_req[ 0 ];;
	}
	else if (fclt_code == g_frs_fclt_code )
	{
		ptrreq = &g_cur_frs_req[ 0 ];
	}
	else if (fclt_code == g_sre_fclt_code )
	{
		ptrreq = &g_cur_sre_req[ 0 ];
	}
	else if (fclt_code == g_fde_fclt_code )
	{
		ptrreq = &g_cur_fde_req[ 0 ] ;
	}

	if ( ptrreq == NULL )
	{
		print_dbg( DBG_ERR,1, "is null ptrreq [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	/* insert */
	if ( type == 1 )
	{
		for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
		{
			req = (cur_req_t *)&ptrreq[ i ]; 

			if ( req != NULL )
			{
				l_id = req->clientid;
				if ( l_id == clientid )
				{
					req->last_send_time = 0;
                    return ERR_SUCCESS;
				}
			}

		}

		for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
		{
			req = (cur_req_t *)&ptrreq[ i ]; 

			if ( req != NULL )
			{
				l_id = req->clientid;
				if ( l_id == 0 )
				{
					req->clientid = clientid ;
					req->last_send_time = 0;
					print_dbg( DBG_INFO,1,"Set Cur Radio fcltcode :%d, Pos:%d, Type:%d, ClientID:%d", fclt_code, i, type, clientid );
					break;
				}
			}
		}
	}
	/* delete */
	else
	{
		for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
		{
			req = (cur_req_t *)&ptrreq[ i ]; 
			if ( req != NULL )
			{
				l_id = req->clientid;
				if ( l_id == clientid )
				{
					req->clientid = 0;
					req->last_send_time = 0;
					print_dbg( DBG_INFO,1,"Set Cur Radio fclt_code :%d, Pos:%d, Type:%d, ClientID:%d", fclt_code, i, type, clientid );
					break;
				}
			}
		}

	}
	return ERR_SUCCESS;
}

static int set_last_sns_onoff_sts( int snsr_id, int clientid,  int sns_type )
{
	int i;
	for( i = 0 ; i < MAX_ONOFF_CNT ; i++ )
	{

		if ( g_sns_onoff_sts[ i ].snsr_id == 0 )
		{
			g_sns_onoff_sts[ i ].snsr_id	= snsr_id;
			g_sns_onoff_sts[ i ].clientid 	= clientid;
			g_sns_onoff_sts[ i ].sns_type 	= sns_type;

			print_dbg( DBG_INFO,1, "Set ONOFF Queue SnsrID:%d, ClientID:%d, Internal Snr Type:%d ", snsr_id, clientid, sns_type );
			break;
		}
	}

	return ERR_SUCCESS;
}

static int get_last_sns_onoff_sts( int snsr_id, sns_onoff_sts_t * ptronoff_sts )
{
	int i;
	int ret = ERR_RETURN;

	if ( ptronoff_sts== NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	for( i = 0 ; i < MAX_ONOFF_CNT ;i++ )
	{
		if ( snsr_id != 0 && snsr_id == g_sns_onoff_sts[ i ].snsr_id )
		{
			ptronoff_sts->snsr_id = g_sns_onoff_sts[ i ].snsr_id;
			ptronoff_sts->clientid= g_sns_onoff_sts[ i ].clientid;
			ptronoff_sts->sns_type= g_sns_onoff_sts[ i ].sns_type;

			g_sns_onoff_sts[ i ].snsr_id	= 0;
			g_sns_onoff_sts[ i ].clientid 	= 0;
			g_sns_onoff_sts[ i ].sns_type 	= 0;
			ret = ERR_SUCCESS;
			print_dbg( DBG_INFO,1, "Get ONOFF Queue SnsrID:%d, ClientID:%d, SnsrType:%d ", ptronoff_sts->snsr_id, ptronoff_sts->clientid, ptronoff_sts->sns_type );
			break;
		}
	}

	return ret;
}

static int check_sns_onoff_result( int sns_type , int result )
{
	if ( sns_type == SNS_ONOFF_MCU )
	{
		send_snsr_onoff_result_fms( result );
	}
	else if ( sns_type == SNS_ONOFF_PWR_C )
	{
		send_pwr_c_onoff_result_fms( result );

	}
	else if ( sns_type == SNS_ONOFF_REMOTE )
	{
		send_snsr_remote_result_fms( result );
	}

	return ERR_SUCCESS;
}

/*현재 데이터 요청 */
static int recv_data_req( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t * ptrmsg =NULL;
	fclt_ctl_requestrsltdata_t req_data;
	int clientid;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset( &req_data, 0, sizeof( req_data ));

	ptrmsg = ( inter_msg_t *)ptrdata;
	clientid = ptrmsg->client_id;
	if ( ptrmsg->ptrbudy == NULL )
	{
		print_dbg( DBG_ERR,1, "is budy [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memcpy( &req_data, ptrmsg->ptrbudy, sizeof( req_data ));

	/* 실시간데이터 요청 */
	if( ( req_data.ectltype == EFCLTCTLTYP_CURRSLTREQ ) && ( req_data.ectlcmd == EFCLTCTLCMD_START ))
	{
		print_dbg( DBG_INFO,1, "Recv CUR RSLT Start REQ ClientID:%d", clientid);
		set_cur_req_client( 1, clientid );
	}

	/* 실시간 데이터 중지 요청 */
	if ( ( req_data.ectltype ==  EFCLTCTLTYP_CURRSLTREQ ) && ( req_data.ectlcmd == EFCLTCTLCMD_END ))
	{
		print_dbg( DBG_INFO,1, "Recv CUR RSLT Stop REQ ClientID:%d", clientid );
		set_cur_req_client( 0, clientid );
	}

	/* moniter data 요청 */
	if ( ( req_data.ectltype ==  EFCLTCTLTYP_RSLTREQ ) && ( req_data.ectlcmd == EFCLTCTLCMD_QUERY  ))
	{
		print_dbg( DBG_INFO,1, "Recv Monitor RSLT REQ ");
		send_dido_data( clientid, EFT_SNSRDAT_RES, SEND_OP );
		send_ai_data( clientid,  EFT_SNSRDAT_RES, SEND_OP );
	}

	return ERR_SUCCESS;
}

static int recv_radio_data_req( UINT16 inter_msg, void * ptrdata)
{
	inter_msg_t * ptrmsg =NULL;
	fclt_ctl_requestrsltdata_t req_data;
	int clientid;
	int fclt_code = 0;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset( &req_data, 0, sizeof( req_data ));

	ptrmsg = ( inter_msg_t *)ptrdata;
	clientid = ptrmsg->client_id;
	if ( ptrmsg->ptrbudy == NULL )
	{
		print_dbg( DBG_ERR,1, "is budy [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memcpy( &req_data, ptrmsg->ptrbudy, sizeof( req_data ));

	/* 실시간데이터 요청 */
	if( ( req_data.ectltype == EFCLTCTLTYP_CURRSLTREQ ) && ( req_data.ectlcmd == EFCLTCTLCMD_START ))
	{
		if ( req_data.tfcltelem.efclt == g_fre_fclt_code )
		{
			fclt_code = g_fre_fclt_code;
			print_dbg( DBG_INFO,1, "Recv CUR FRE RSLT Start REQ ");
		}
		else if ( req_data.tfcltelem.efclt == g_frs_fclt_code )
		{
			fclt_code = g_frs_fclt_code;
			print_dbg( DBG_INFO,1, "Recv CUR FRS RSLT Start REQ ");
		}
		else if ( req_data.tfcltelem.efclt == g_sre_fclt_code )
		{
			fclt_code = g_sre_fclt_code;
			print_dbg( DBG_INFO,1, "Recv CUR SRE RSLT Start REQ ");
		}
		else if ( req_data.tfcltelem.efclt == g_fde_fclt_code )
		{
			fclt_code = g_fde_fclt_code;
			print_dbg( DBG_INFO,1, "Recv CUR FDE RSLT Start REQ ");
		}

		set_cur_radio_req_client( fclt_code , 1, clientid );
	}

	/* 실시간 데이터 중지 요청 */
	if ( ( req_data.ectltype ==  EFCLTCTLTYP_CURRSLTREQ ) && ( req_data.ectlcmd == EFCLTCTLCMD_END ))
	{
		if ( req_data.tfcltelem.efclt == g_fre_fclt_code )
		{
			fclt_code = g_fre_fclt_code;
			print_dbg( DBG_INFO,1, "Recv CUR FRE RSLT Stop REQ ");
		}
		else if ( req_data.tfcltelem.efclt == g_frs_fclt_code )
		{
			fclt_code = g_frs_fclt_code;
			print_dbg( DBG_INFO,1, "Recv CUR FRS RSLT Stop REQ ");
		}
		else if ( req_data.tfcltelem.efclt == g_sre_fclt_code )
		{
			fclt_code = g_sre_fclt_code;
			print_dbg( DBG_INFO,1, "Recv CUR SRE RSLT Stop REQ ");
		}
		else if ( req_data.tfcltelem.efclt == g_fde_fclt_code )
		{
			fclt_code = g_fde_fclt_code;
			print_dbg( DBG_INFO,1, "Recv CUR FDE RSLT Stop REQ ");
		}
		set_cur_radio_req_client( fclt_code, 0, clientid );
	}

	/* moniter data 요청 */
	if ( ( req_data.ectltype ==  EFCLTCTLTYP_RSLTREQ ) && ( req_data.ectlcmd == EFCLTCTLCMD_QUERY  ))
	{
		if ( req_data.tfcltelem.efclt == g_fre_fclt_code )
		{
			print_dbg( DBG_INFO,1, "Recv MOR FRE RSLT Stop REQ ");
			send_fre_data( clientid, EFT_EQPDAT_RES, SEND_OP );
		}
		else if ( req_data.tfcltelem.efclt == g_frs_fclt_code )
		{
			print_dbg( DBG_INFO,1, "Recv MOR FRS RSLT Stop REQ ");
			send_frs_data( clientid, EFT_EQPDAT_RES, SEND_OP );
		}
		else if ( req_data.tfcltelem.efclt == g_sre_fclt_code )
		{
			print_dbg( DBG_INFO,1, "Recv MOR SRE RSLT Stop REQ ");
			send_sre_data( clientid, EFT_EQPDAT_RES, SEND_OP );
		}
		else if ( req_data.tfcltelem.efclt == g_fde_fclt_code )
		{
			print_dbg( DBG_INFO,1, "Recv MOR FDE RSLT Stop REQ ");
			send_fde_data( clientid, EFT_EQPDAT_RES, SEND_FMS );
		}
	}

	return ERR_SUCCESS;
}


static int set_di_thrd(int clientid,  fms_ctl_base_t * ptrbase , fclt_ctl_thrlddi_t * ptrdi_thrd )
{
	int snsr_id = 0 ;
	int l_snsr_sub_idx, l_snsr_type, l_snsr_sub_type;
	int i;
	int flag = 0;
	int result = 0;
	char szip[ MAX_IP_SIZE ];

	if ( ptrbase == NULL || ptrdi_thrd == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset( szip, 0, sizeof( szip ));

	cnv_addr_to_strip( ptrbase->op_ip, szip );

	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		snsr_id 		= g_di_val[ i ].snsr_id;			/* snsr  index */
		l_snsr_sub_idx	= g_di_val[ i ].snsr_sub_idx;		/* snsr sub index */
		l_snsr_type 	= g_di_val[ i ].snsr_type;			/* snsr type */
		l_snsr_sub_type = g_di_val[ i ].snsr_sub_type; 		/* snsr sub type */
		
		if( (l_snsr_sub_idx == ptrbase->idxsub) && 
			(l_snsr_type == ptrbase->esnsrtype) && 
			(l_snsr_sub_type == ptrbase->esnsrsub ))
		{
			g_di_val[ i ].good_val 	= ptrdi_thrd->tthrlddtdi.bnormalval;
			g_di_val[ i ].grade		= ptrdi_thrd->tthrlddtdi.egrade;

			memset( g_di_val[ i].szlabel1, 0, SZ_MAX_LABEL );
			memset( g_di_val[i ].szlabel0, 0, SZ_MAX_LABEL );

			memcpy( g_di_val[ i].szlabel1, ptrdi_thrd->tthrlddtdi.snormalname, SZ_MAX_LABEL );
			memcpy( g_di_val[i ].szlabel0, ptrdi_thrd->tthrlddtdi.sfaultname, SZ_MAX_LABEL );

			flag = 1;
			print_dbg( DBG_INFO,1,"Set DI Threshold SnsrID:%d, Good val:%d, Grade:%d, OP_IP:%s",
						snsr_id,
						g_di_val[ i ].good_val,
						g_di_val[ i ].grade ,
						szip
						);
			break;
		}
	}

	/* DB UPDATE, history 저장  */
	if ( flag == 1 )
	{
		result = EFCLTERR_NOERROR;
	}
	else
	{
		result = EFCLTERR_UNDEFINED;
	}

	/* updat_db( snsr_id, ptrdi_thrd ); */
	send_di_thrd_complet( clientid, flag,  ptrdi_thrd, EFT_SNSRCTLCOMPLETED_THRLD , result );
	
	//if ( flag && result == EFCLTERR_NOERROR)
	{
		send_di_thrd_fms( clientid, ptrdi_thrd ,ESNSRTYP_DI, EFT_SNSRCTL_THRLD );
	}

	return ERR_SUCCESS;
}

static int set_radio_thrd(int clientid,  fms_ctl_base_t * ptrbase , fclt_ctl_thrlddi_t * ptrdi_thrd )
{
	int snsr_id = 0 ;
	int l_snsr_sub_idx, l_snsr_type, l_snsr_sub_type;
	int i;
	int flag = 0;
	int result = 0;
	char szip[ MAX_IP_SIZE ];

	radio_val_manager_t * ptrmanager = NULL;

	memset( szip, 0, sizeof( szip ));

	if ( ptrbase == NULL || ptrdi_thrd == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	if ( ptrbase->tfcltelem.efclt == g_fre_fclt_code )
	{
		ptrmanager = &g_fre_mng;
		print_dbg( DBG_INFO,1,"Set FRE Threshold");
	}
	else if ( ptrbase->tfcltelem.efclt == g_frs_fclt_code )
	{
		ptrmanager = &g_frs_mng;
		print_dbg( DBG_INFO,1,"Set FRS Threshold");
	}
	else if ( ptrbase->tfcltelem.efclt == g_sre_fclt_code )
	{
		ptrmanager = &g_sre_mng;
		print_dbg( DBG_INFO,1,"Set SRE Threshold");
	}
	else if ( ptrbase->tfcltelem.efclt == g_fde_fclt_code )
	{
		ptrmanager = &g_fde_mng;
		print_dbg( DBG_INFO,1,"Set FDE Threshold");
	}

	if ( ptrmanager == NULL )
	{
		print_dbg( DBG_ERR,1, "is null ptrmanager [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	cnv_addr_to_strip( ptrbase->op_ip, szip );

    print_dbg(DBG_INFO,1, "############ Recv EQP(%d) Threshold  from OP SubIndex : %d, SnsrType:%d, SnsrSubType : %d, OP_IP:%s .\r\n",
                                                                                     ptrbase->tfcltelem.efclt, 
                                                                                     ptrbase->idxsub ,
                                                                                     ptrbase->esnsrtype,  
                                                                                     ptrbase->esnsrsub,
																					 szip );

	for( i = 0 ; i < MAX_RADIO_SNS_CNT ; i++ )
	{
		snsr_id 		= ptrmanager->radio_val[ i ].snsr_id;				/* snsr  index */
		l_snsr_sub_idx	= ptrmanager->radio_val[ i ].snsr_sub_idx;			/* snsr sub index */
		l_snsr_type 	= ptrmanager->radio_val[ i ].snsr_type;				/* snsr type */
		l_snsr_sub_type = ptrmanager->radio_val[ i ].snsr_sub_type; 		/* snsr sub type */
		
		if( (l_snsr_sub_idx == ptrbase->idxsub) && 
			(l_snsr_type == ptrbase->esnsrtype) && 
			(l_snsr_sub_type == ptrbase->esnsrsub ))
		{
			ptrmanager->radio_val[ i ].good_val 	= ptrdi_thrd->tthrlddtdi.bnormalval;
			ptrmanager->radio_val[ i ].grade		= ptrdi_thrd->tthrlddtdi.egrade;

			memset( ptrmanager->radio_val[ i ].szlabel0, 0, SZ_MAX_LABEL );
			memset( ptrmanager->radio_val[ i ].szlabel1, 0, SZ_MAX_LABEL );

			memcpy( ptrmanager->radio_val[ i ].szlabel1, ptrdi_thrd->tthrlddtdi.snormalname, SZ_MAX_LABEL );
			memcpy( ptrmanager->radio_val[ i ].szlabel0, ptrdi_thrd->tthrlddtdi.sfaultname, SZ_MAX_LABEL );

			flag = 1;
			print_dbg( DBG_INFO,1,"Set Radio Threshold SnsrID:%d, Good val:%d, Grade:%d, OP_IP:%s",
						snsr_id,
						ptrmanager->radio_val[ i ].good_val,
						ptrmanager->radio_val[ i ].grade,
						szip );
			break;
		}
	}

	/* DB UPDATE, history 저장  */
	/* updat_db( snsr_id, ptrdi_thrd ); */
	if ( flag == 1 )
	{
		result = EFCLTERR_NOERROR;
	}
	else
	{
		result = EFCLTERR_UNDEFINED;
	}
	send_di_thrd_complet( clientid, flag,  ptrdi_thrd, EFT_EQPCTLCOMPLETED_THRLD , result );
	
	//if ( flag && result == EFCLTERR_NOERROR )
	{
		send_di_thrd_fms( clientid, ptrdi_thrd, ESNSRTYP_DI, EFT_EQPCTL_THRLD);
	}

	return ERR_SUCCESS;
}

static int set_ai_thrd(int clientid,  fms_ctl_base_t * ptrbase , fclt_ctl_thrldai_t * ptrai_thrd )
{
	int snsr_id = 0 ;
	int l_snsr_sub_idx, l_snsr_type, l_snsr_sub_type;
	int i,j;
	int flag = 0;
	int result = 0;
	char szip[ MAX_IP_SIZE ];

    print_dbg(DBG_INFO,1, "############ Recv AI Threshold  from OP SubIndex : %d, SnsrType:%d, SnsrSubType : %d.\r\n",
                                                                                     ptrbase->idxsub ,
                                                                                     ptrbase->esnsrtype,  
																					 ptrbase->esnsrsub );

	memset( szip, 0, sizeof( szip ));
    
	cnv_addr_to_strip( ptrbase->op_ip, szip );
	/* 온습도 */
	for( i = 0 ; i < MAX_TEMP_CNT ; i++ )
	{
		snsr_id 		= g_temp_val[ i ].snsr_id;		/* snsr  index */
		l_snsr_sub_idx	= g_temp_val[ i ].snsr_sub_idx;	/* snsr sub index */
		l_snsr_type 	= g_temp_val[ i ].snsr_type;		/* snsr type */
		l_snsr_sub_type = g_temp_val[ i ].snsr_sub_type; 		/* snsr sub type */

		if( (l_snsr_sub_idx == ptrbase->idxsub) && 
			(l_snsr_type == ptrbase->esnsrtype) && 
			(l_snsr_sub_type == ptrbase->esnsrsub ))
		{
			for( j = 0 ; j< MAX_RANG_CNT ; j++ )
			{
				g_temp_val[ i ].range_val[j] = ptrai_thrd->tthrlddtai.frange[j];
			}

			g_temp_val[ i ].offset_val = ptrai_thrd->tthrlddtai.foffsetval;
			g_temp_val[ i ].min_val= ptrai_thrd->tthrlddtai.fmin;
			g_temp_val[ i ].max_val= ptrai_thrd->tthrlddtai.fmax;

			flag = 1;
			print_dbg(DBG_INFO,1,"Set AI Threshold SnsrID:%d,OP_IP:%s, RANGE0:%.2f,RANGE1:%.2f, RANGE2:%.2f, RANGE3:%.2f, RANGE4:%.2f, RANGE5:%.2f, MIN:%.2f, MAX:%.2f, OFFSET:%.2f"
						,snsr_id, szip, 
						g_temp_val[ i ].range_val[ 0 ], g_temp_val[ i ].range_val[ 1 ],g_temp_val[ i ].range_val[ 2 ], g_temp_val[ i ].range_val[ 3 ],
						g_temp_val[ i ].range_val[ 4 ], g_temp_val[ i ].range_val[ 5 ],g_temp_val[ i ].min_val,
						g_temp_val[ i ].max_val,g_temp_val[ i ].offset_val);

			break;
		}
	}

	/* 상전압 ,주파수 */
	for( i = 0 ; i < MAX_PWR_M_CNT ; i++ )
	{
		snsr_id 		= g_pwr_m_val[ i ].snsr_id;		/* snsr  index */
		l_snsr_sub_idx	= g_pwr_m_val[ i ].snsr_sub_idx;	/* snsr sub index */
		l_snsr_type 	= g_pwr_m_val[ i ].snsr_type;		/* snsr type */
		l_snsr_sub_type = g_pwr_m_val[ i ].snsr_sub_type; 		/* snsr sub type */

		if( (l_snsr_sub_idx == ptrbase->idxsub) && 
			(l_snsr_type == ptrbase->esnsrtype) && 
			(l_snsr_sub_type == ptrbase->esnsrsub ))
		{
			for( j = 0 ; j< MAX_RANG_CNT ; j++ )
			{
				g_pwr_m_val[ i ].range_val[j] = ptrai_thrd->tthrlddtai.frange[j];
			}

			g_pwr_m_val[ i ].offset_val = ptrai_thrd->tthrlddtai.foffsetval;
			g_pwr_m_val[ i ].min_val= ptrai_thrd->tthrlddtai.fmin;
			g_pwr_m_val[ i ].max_val= ptrai_thrd->tthrlddtai.fmax;

			flag = 1;
			print_dbg(DBG_INFO,1,"Set AI Threshold SnsrID:%d,OP_IP:%s,RANGE0:%.2f,RANGE1:%.2f, RANGE2:%.2f, RANGE3:%.2f, RANGE4:%.2f, RANGE5:%.2f, MIN:%.2f, MAX:%.2f, OFFSET:%.2f"
					,snsr_id,szip,
					g_pwr_m_val[ i ].range_val[ 0 ],g_pwr_m_val[ i ].range_val[ 1 ],g_pwr_m_val[ i ].range_val[ 2 ],g_pwr_m_val[ i ].range_val[ 3 ],
					g_pwr_m_val[ i ].range_val[ 4 ],g_pwr_m_val[ i ].range_val[ 5 ],g_pwr_m_val[ i ].min_val,
					g_pwr_m_val[ i ].max_val,g_pwr_m_val[ i ].offset_val);

			break;
		}

	}

	/* DB UPDATE, history 저장  */
	if ( flag == 1 )
	{
		result = EFCLTERR_NOERROR;
	}
	else
	{
		result = EFCLTERR_UNDEFINED;
	}
	/* updat_db( snsr_id, ptrdi_thrd ); */
	send_ai_thrd_complet( clientid, flag,  ptrai_thrd , result );
	
	//if ( flag )
	{
		send_ai_thrd_fms( clientid, ptrai_thrd  );
	}

	return ERR_SUCCESS;
}

static int recv_threshold_req( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t * ptrmsg =NULL;
	fms_ctl_base_t base;
	fclt_ctl_thrlddi_t di_thrd;
	fclt_ctl_thrldai_t ai_thrd;
	int clientid;
	

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset(&base, 0, sizeof( base ));

	memset( &di_thrd, 0, sizeof( di_thrd ));
	memset( &ai_thrd, 0, sizeof( ai_thrd ));

	ptrmsg = ( inter_msg_t *)ptrdata;
	clientid = ptrmsg->client_id;
	if ( clientid == WEB_CLIENTID )
	{
		print_dbg( DBG_INFO, 1, "Recv Thresold from WebClient");
	}

	if ( ptrmsg->ptrbudy == NULL )
	{
		print_dbg( DBG_ERR,1, "is budy [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memcpy( &base, ptrmsg->ptrbudy , sizeof( base ));

	/* DI 임계치 설정 요청 */
	if ( base.ectltype ==  EFCLTCTLTYP_THRLDDI ) 
	{
		memcpy( &di_thrd, ptrmsg->ptrbudy, sizeof( di_thrd ));
		
		print_dbg( DBG_INFO,1, "Recv DI THRESHOLD REQ ");
		set_di_thrd(clientid,  &base, &di_thrd );

	}

	/* AI 임계치 설정 요청 */
	if ( base.ectltype ==  EFCLTCTLTYP_THRLDAI ) 
	{
		memcpy( &ai_thrd, ptrmsg->ptrbudy, sizeof( ai_thrd ));
		print_dbg( DBG_INFO,1, "Recv AI THRESHOLD REQ ");
		set_ai_thrd( clientid, &base, &ai_thrd );
	}


	return ERR_SUCCESS;
}

static int recv_radio_threshold_req( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t * ptrmsg =NULL;
	fms_ctl_base_t base;
	fclt_ctl_thrlddi_t di_thrd;
	int clientid;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset(&base, 0, sizeof( base ));
	memset( &di_thrd, 0, sizeof( di_thrd ));

	ptrmsg = ( inter_msg_t *)ptrdata;
	clientid = ptrmsg->client_id;

	if ( ptrmsg->ptrbudy == NULL )
	{
		print_dbg( DBG_ERR,1, "is budy [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memcpy( &base, ptrmsg->ptrbudy , sizeof( base ));

	/* radio  임계치 설정 요청 */
	if ( base.ectltype ==  EFCLTCTLTYP_THRLDDI ) 
	{
		memcpy( &di_thrd, ptrmsg->ptrbudy, sizeof( di_thrd ));
		
		print_dbg( DBG_INFO,1, "Recv Radio THRESHOLD REQ ");
		set_radio_thrd(clientid,  &base, &di_thrd );

	}

	return ERR_SUCCESS;
}

static int recv_radio_eqp_pwr_req( UINT16 inter_msg, void * ptrdata )
{
    int ret = 0;
	print_dbg(DBG_INFO,1,"REC EQP PWR REQ in Control");

    /* EQP ON OFF */
    g_eqp_auto.run= 1;
    g_eqp_auto.run_time = get_sectick();
    ret = recv_ctrl_data_pwr_mng( inter_msg, ptrdata );

    if ( ret != ERR_SUCCESS )
    {
        memset( &g_eqp_auto, 0, sizeof( g_eqp_auto ));
    }

	return ret;  
}

/* 2016 11 14 new protocol */
static int recv_radio_eqp_off_option( UINT16 inter_msg, void * ptrdata )
{
    int ret = 0;
	print_dbg(DBG_INFO,1,"REC EQP PWR OFF OPTION in Control");

	ret = recv_ctrl_data_pwr_off_opt_mng( inter_msg, ptrdata );

	return ret;
}

static int recv_radio_eqp_on_option( UINT16 inter_msg, void * ptrdata )
{
    int ret = 0;
	print_dbg(DBG_INFO,1,"REC EQP PWR ON OPTION in Control");

	ret = recv_ctrl_data_pwr_on_opt_mng( inter_msg, ptrdata );

	return ret;
}

static int recv_radio_eqp_status( UINT16 inter_msg, void * ptrdata )
{
    int ret = 0;
	print_dbg(DBG_INFO,1,"REC EQP STATUS in Control");

	ret = recv_ctrl_data_eqp_status_mng( inter_msg, ptrdata );

	return ret;
}

static int recv_radio_eqp_net_status( UINT16 inter_msg, void * ptrdata )
{
    int ret = 0;
	int clientid = 0;
	inter_msg_t * ptrmsg =NULL;
	inter_msg_t send_msg;
	int net_sts = ESNSRCNNST_NONE;
	fclt_cnnstatus_eqp_t req_net_eqp;
	fclt_cnnstatus_eqprslt_t resp_net_eqp;

	int siteid, fcltid, fcltcode;
	UINT16 cmd;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset( &req_net_eqp, 0, sizeof( req_net_eqp ));
	memset( &resp_net_eqp, 0, sizeof( resp_net_eqp ));
	memset( &send_msg, 0, sizeof( send_msg ));

	ptrmsg = ( inter_msg_t *)ptrdata;
	clientid = ptrmsg->client_id;

	if ( ptrmsg->ptrbudy == NULL )
	{
		print_dbg( DBG_ERR,1, "is budy [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memcpy( &req_net_eqp, ptrmsg->ptrbudy , sizeof( req_net_eqp ));

	siteid 		= req_net_eqp.tfcltelem.nsiteid ;
	fcltid 		= req_net_eqp.tfcltelem.nfcltid ;
	fcltcode 	= req_net_eqp.tfcltelem.efclt;

	print_dbg( DBG_INFO,1, "Recv EQP Network Status SiteID:%d, FcltID:%d, FcltCode:%d", siteid, fcltid, fcltcode );

	if ( fcltcode ==  g_fre_fclt_code || fcltcode == g_frs_fclt_code )
	{
		net_sts = g_fre_tcp_sts;
	}
	else if ( fcltcode == g_sre_fclt_code )
	{
		net_sts = g_sre_tcp_sts;
	}
	else if ( fcltcode == g_fde_fclt_code )
	{
		net_sts = g_fde_tcp_sts;
	}


	resp_net_eqp.tfcltelem.nsiteid = get_my_siteid_shm();
	resp_net_eqp.tfcltelem.nfcltid = fcltid;
	resp_net_eqp.tfcltelem.efclt  = fcltcode;
	resp_net_eqp.ecnnstatus = net_sts;

	cmd = EFT_EQPCTL_CNNSTATUS_RES;
	/* intr msg */
	send_msg.client_id	= clientid;
	send_msg.msg 		= cmd;
	send_msg.ptrbudy 	= &resp_net_eqp;

	/* send transfer */
	send_data_transfer( cmd, (void *)&send_msg ,SEND_OP );

	return ret;
}

static int recv_radio_eqp_pwr_ack( UINT16 inter_msg, void * ptrdata )
{
	/* power manager로 전송 */
	return recv_ctrl_data_pwr_mng( inter_msg, ptrdata );
}

static int recv_radio_eqp_res_ack( UINT16 inter_msg, void * ptrdata )
{
	/* power manager로 전송 */
	return recv_ctrl_data_pwr_mng( inter_msg, ptrdata );
}

static int set_dodoe_onoff( int clientid, int onoff, fclt_ctrl_snsronoff_t * ptronoff_data )
{
	int snsr_id = 0 ;
	int set_snsr_id = 0;

	int l_snsr_sub_idx, l_snsr_type, l_snsr_sub_type;
	int i;
	int flag = 0;
	char szip[ MAX_IP_SIZE ];

	mcu_data_t mcu_data;		
	remote_data_t remote_data;
	pwr_c_data_t pwr_c_data;

	if ( ptronoff_data == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset( &mcu_data, 0, sizeof( mcu_data ));
	memset( &remote_data, 0, sizeof( remote_data ));
	memset( &pwr_c_data, 0, sizeof( pwr_c_data ));
	memset( &szip, 0, sizeof( szip ));

	lock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		mcu_data.do_[ i ] = (int)g_do_val[ i ].last_val;
		mcu_data.doe[ i ] = (int)g_doe_val[ i ].last_val;
	}
	
	for( i = 0 ; i < MAX_PWR_C_PORT_CNT ; i++ )
	{
		pwr_c_data.val[ i ] = (int)g_pwr_c_data.val[ i ];
	}

	unlock_sem( g_ctrl_sem_id, g_ctrl_sem_key );

	cnv_addr_to_strip( ptronoff_data->ctl_base.op_ip, szip );

    print_dbg(DBG_INFO,1, "############ Recv ONOFF from OP (ON_OFF : %d ) SubIndex : %d, SnsrType:%d, SnsrSubType : %d, OP_IP:%s\r\n"
			,onoff, ptronoff_data->ctl_base.idxsub 
            ,ptronoff_data->ctl_base.esnsrtype  
            ,ptronoff_data->ctl_base.esnsrsub
			,szip );

	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		snsr_id 		= g_do_val[ i ].snsr_id;		/* snsr  index */
		l_snsr_sub_idx	= g_do_val[ i ].snsr_sub_idx;	/* snsr sub index */
		l_snsr_type 	= g_do_val[ i ].snsr_type;		/* snsr type */
		l_snsr_sub_type = g_do_val[ i ].snsr_sub_type; 		/* snsr sub type */

		if( (l_snsr_sub_idx == ptronoff_data->ctl_base.idxsub) && 
			(l_snsr_type == ptronoff_data->ctl_base.esnsrtype) && 
			(l_snsr_sub_type == ptronoff_data->ctl_base.esnsrsub ))
		{
			mcu_data.do_[ i ] = onoff;
			print_dbg( DBG_INFO,1,"Set DO :%d,NO:%d, SUB_ID:%d, SNSR_TYPE:%d, SNSR_SUB_TYPE:%d, ONOFF:%d, OP_IP:%s",
					i,
					g_do_val[ i ].snsr_no,
					g_do_val[ i ].snsr_sub_idx,
					g_do_val[ i ].snsr_type,
					g_do_val[ i ].snsr_sub_type,
					onoff,
					szip );

			flag = SNS_ONOFF_MCU;
			set_snsr_id = snsr_id;
			break;
		}
	}

	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		snsr_id 		= g_doe_val[ i ].snsr_id;			/* snsr  index */
		l_snsr_sub_idx	= g_doe_val[ i ].snsr_sub_idx;		/* snsr sub index */
		l_snsr_type 	= g_doe_val[ i ].snsr_type;			/* snsr type */
		l_snsr_sub_type = g_doe_val[ i ].snsr_sub_type; 	/* snsr sub type */

		if( (l_snsr_sub_idx == ptronoff_data->ctl_base.idxsub) && 
			(l_snsr_type == ptronoff_data->ctl_base.esnsrtype) && 
			(l_snsr_sub_type == ptronoff_data->ctl_base.esnsrsub ))
		{
			mcu_data.doe[ i ] = onoff;

			print_dbg( DBG_INFO,1,"Set DOE :%d,NO:%d, SUB_ID:%d, SNSR_TYPE:%d, SNSR_SUB_TYPE:%d, ONOFF:%d, OP_IP:%s",
					i,
					g_doe_val[ i ].snsr_no,
					g_doe_val[ i ].snsr_sub_idx,
					g_doe_val[ i ].snsr_type,
					g_doe_val[ i ].snsr_sub_type,
					onoff,
					szip );

			set_snsr_id = snsr_id;
			flag = SNS_ONOFF_MCU;
			break;

		}
	}

	for( i = 0 ; i < MAX_PWR_C_PORT_CNT ; i++ )
	{
		snsr_id 		= g_pwr_c_val[ i ].snsr_id;			/* snsr  index */
		l_snsr_sub_idx	= g_pwr_c_val[ i ].snsr_sub_idx;		/* snsr sub index */
		l_snsr_type 	= g_pwr_c_val[ i ].snsr_type;			/* snsr type */
		l_snsr_sub_type = g_pwr_c_val[ i ].snsr_sub_type; 	/* snsr sub type */

		if( (l_snsr_sub_idx == ptronoff_data->ctl_base.idxsub) && 
			(l_snsr_type == ptronoff_data->ctl_base.esnsrtype) && 
			(l_snsr_sub_type == ptronoff_data->ctl_base.esnsrsub ))
		{
			pwr_c_data.val[ i ] = onoff;

			print_dbg( DBG_INFO,1,"Set Pwr C :%d,NO:%d, SUB_ID:%d, SNSR_TYPE:%d, SNSR_SUB_TYPE:%d, ONOFF:%d, OP_IP:%s",
					i,
					g_pwr_c_val[ i ].snsr_no,
					g_pwr_c_val[ i ].snsr_sub_idx,
					g_pwr_c_val[ i ].snsr_type,
					g_pwr_c_val[ i ].snsr_sub_type,
					onoff,
					szip );

			set_snsr_id = snsr_id;
			flag = SNS_ONOFF_PWR_C;
			break;
		}
	}

	/* remote control onoff check */
	snsr_id 		= g_remote_val.snsr_id;		/* snsr  index */
	l_snsr_sub_idx	= g_remote_val.snsr_sub_idx;	/* snsr sub index */
	l_snsr_type 	= g_remote_val.snsr_type;		/* snsr type */
	l_snsr_sub_type = g_remote_val.snsr_sub_type; 		/* snsr sub type */

	if( (l_snsr_sub_idx == ptronoff_data->ctl_base.idxsub) && 
			(l_snsr_type == ptronoff_data->ctl_base.esnsrtype) && 
			(l_snsr_sub_type == ptronoff_data->ctl_base.esnsrsub ))
	{
		remote_data.remote_val = onoff;
		print_dbg( DBG_INFO,1,"Set Remote Control :%d,NO:%d, SUB_ID:%d, SNSR_TYPE:%d, SNSR_SUB_TYPE:%d, ONOFF:%d, OP_IP:%s",
				i,
				g_remote_val.snsr_no,
				g_remote_val.snsr_sub_idx,
				g_remote_val.snsr_type,
				g_remote_val.snsr_sub_type,
				onoff,
				szip );
		set_snsr_id = snsr_id;
		flag = SNS_ONOFF_REMOTE;
	}

	if ( flag > 0  )
	{
		/* DB UPDATE, history 저장  */
		/* updat_db( snsr_id, ptrdi_thrd ); */
		
		set_last_sns_onoff_sts(set_snsr_id,  clientid, flag );
		
		if ( flag == SNS_ONOFF_MCU )
		{
			/* mcu 제어 요청 */
			if ( g_first_mcu == 0 )
			{
				print_dbg( DBG_INFO,1,"Cannot ONOFF Control MCU becase of Not recv first Status");
				return ERR_SUCCESS;
			}

			send_data_mcu( EFT_SNSRCTL_POWER,  &mcu_data );
		}
		else if ( flag == SNS_ONOFF_PWR_C )
		{
			/* mcu 제어 요청 */
			if ( g_first_pwr_c == 0 )
			{
				print_dbg( DBG_INFO,1,"Cannot ONOFF Control MCU becase of Not recv first Status");
				return ERR_SUCCESS;
			}

			send_data_pwr_c( EFT_SNSRCTL_POWER,  &pwr_c_data);
		}
		else if ( flag == SNS_ONOFF_REMOTE )
		{
			/* remote control 제어 요청 */
			send_data_remote( EFT_SNSRCTL_POWER, &remote_data );
		}
		sys_sleep( 500 );

		/* fms 이력 전송 */
		send_onoff_fms( 0, ptronoff_data );
	}

	return ERR_SUCCESS;
}

static int recv_onoff_req( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t * ptrmsg =NULL;
	fclt_ctrl_snsronoff_t onoff_data;

	int clientid;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset( &onoff_data, 0, sizeof( onoff_data ));

	ptrmsg = ( inter_msg_t *)ptrdata;
	clientid = ptrmsg->client_id;

	if ( clientid == WEB_CLIENTID )
	{
		print_dbg( DBG_INFO, 1, "Recv sns onoff from WebClient");
	}

	memcpy( &onoff_data, ptrmsg->ptrbudy, sizeof( onoff_data ));

	/* DO OFF 요청 */
	if ( (onoff_data.ctl_base.ectltype ==  EFCLTCTLTYP_DOCTRL) && ( onoff_data.ctl_base.ectlcmd == EFCLTCTLCMD_OFF )) 
	{
		print_dbg( DBG_INFO,1, "Recv DO OFF Control REQ ");
		set_dodoe_onoff(clientid,  0, &onoff_data );
	}

	/* DO ON 요청 */
	if ( (onoff_data.ctl_base.ectltype ==  EFCLTCTLTYP_DOCTRL) && ( onoff_data.ctl_base.ectlcmd == EFCLTCTLCMD_ON )) 
	{
		print_dbg( DBG_INFO,1, "Recv DO ON Control REQ ");
		set_dodoe_onoff(clientid, 1 , &onoff_data );
	}

	return ERR_SUCCESS;
}

static int recv_dbupdate_req( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t * ptrmsg =NULL;
	fclt_evt_dbdataupdate_t db_update;
	int chg = 0;
	int ret = 0;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memset( &db_update, 0, sizeof( db_update ));


	ptrmsg = ( inter_msg_t *)ptrdata;

	if ( ptrmsg->ptrbudy == NULL )
	{
		print_dbg( DBG_ERR,1, "is budy [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memcpy( &db_update, ptrmsg->ptrbudy, sizeof( db_update ));
    
    if( db_update.ectlcmd != EFCLTCTLCMD_WORKRUN)
    {
		print_dbg( DBG_ERR,1, "is not valid db update work run [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
    }
	if ( ptrmsg->client_id == WEB_CLIENTID )
	{
		print_dbg( DBG_INFO, 1, "Recv DB Update from WebClient");
	}

    if ( g_reboot == 1 )
    {
		//send_base_db_update_res( ret, ptrmsg->client_id, db_update.edbeditinfo, EFCLTCTLCMD_WORKREADYFAIL   );
		print_dbg( DBG_ERR,1, "######## Can not update becase of rtu rebooting.[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
        return ERR_RETURN;
    }

	if ( db_update.edbeditinfo == EDBEDIT_ALL )
	{
		chg = 1;
		print_dbg( DBG_INFO,1, "########## Recv DB Update  ALL ");
	}
	else if ( db_update.edbeditinfo == EDBEDIT_SITE )
	{
		chg = 1;
		print_dbg( DBG_INFO,1, "########## Recv DB Update  SITE ");

	}
	else if ( db_update.edbeditinfo == EDBEDIT_RTU )
	{
		chg = 1;
		print_dbg( DBG_INFO,1, "########## Recv DB Update  RTU ");
	}
	else if ( db_update.edbeditinfo == EDBEDIT_EQP )
	{
		chg = 1;
		print_dbg( DBG_INFO,1, "########## Recv DB Update  EQP ");

	}
	else if ( db_update.edbeditinfo == EDBEDIT_SNSR )
	{
		chg = 1;
		print_dbg( DBG_INFO,1, "########## Recv DB Update  SNSR ");

	}
	else if ( db_update.edbeditinfo == EDBEDIT_COMMONCD )
	{
		chg = 1;
		print_dbg( DBG_INFO,1, "########## Recv DB Update  COMMON ");
	}
	else if ( db_update.edbeditinfo == EDBEDIT_DVR )
	{
		chg = 1;
		print_dbg( DBG_INFO,1, "########## Recv DB Update  DVR ");
	}
	
	send_base_db_update_res( ret, ptrmsg->client_id, db_update.edbeditinfo, EFCLTCTLCMD_WORKCOMPLETE   );

	if ( chg ==1 )
	{
		ret = load_db();
	}

	return ret;
}

static int recv_timesync_req( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t * ptrmsg =NULL;
	fclt_timersltdata_t time_data;

	//int clientid;
	time_t recv_time;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset( &time_data, 0, sizeof( time_data ));

	ptrmsg = ( inter_msg_t *)ptrdata;
	//clientid = ptrmsg->client_id;
	if ( ptrmsg->ptrbudy == NULL )
	{
		print_dbg( DBG_ERR,1, "is budy [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
	
	memcpy( &time_data, ptrmsg->ptrbudy, sizeof( time_data ));
	recv_time = (time_t)time_data.ttimerslt;
	
	//recv_time = 1475384966;
	
	set_rtc_time( recv_time, 0, 0 );

	print_dbg( DBG_INFO,1, "######## Recv Time Data:%u ", recv_time );

	return ERR_SUCCESS;
}

static int recv_fclt_netinfo_req( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t * ptrmsg =NULL;
    inter_msg_t send_msg;
    fclt_net_t net_info;

    fclt_evt_fcltnetworkinfo_req_t  net_req;
    fclt_evt_fcltnetworkinfo_res_t  net_resp;

    int site_id, fclt_id;
    int cmd;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	memset( &net_req, 0, sizeof( net_req));
	memset( &net_resp, 0, sizeof( net_resp));
    memset( &send_msg, 0, sizeof( send_msg ));
    memset( &net_info, 0, sizeof( net_info ));

	ptrmsg = ( inter_msg_t *)ptrdata;
	memcpy( &net_req, ptrmsg->ptrbudy, sizeof( net_req));

    site_id = net_req.tfcltelem.nsiteid;
    fclt_id = net_req.tfcltelem.nfcltid;

    print_dbg( DBG_INFO,1, "######## Recv FCLT NET Info SiteID:%d, Fclt_ID :%d",site_id, fclt_id); 

    /* DB 조회 */
    load_fclt_net_ctrl_db(site_id, fclt_id, &net_info );

    if( strlen( net_info.szip) <= 0  || net_info.port <= 0 )
    {
        print_dbg( DBG_ERR,1, "######## Fail to Select DB IP:%s, Port:%d, SiteID:%d, Fclt_ID :%d",net_info.szip, net_info.port, site_id, fclt_id); 
        return ERR_RETURN;
    }
    else
    {
        print_dbg( DBG_ERR,1, "######## Select FRS DB IP:%s, Port:%d, SiteID:%d, Fclt_ID :%d",net_info.szip, net_info.port, site_id, fclt_id); 
    }
    
    /* network resp 등록 */
    memcpy( &net_resp.tfcltelem, &net_req.tfcltelem, sizeof( fms_elementfclt_t ));
    net_resp.timet = net_req.timet;
    memcpy( net_resp.sip, net_info.szip , strlen( net_info.szip ));
    net_resp.nport = net_info.port;

    /* radio 전송 */
    cmd                 = EFT_FCLTNETINFO_RES;
    send_msg.msg 		= cmd;
    send_msg.ptrbudy 	= &net_resp;
    /* send transfer */
    send_data_radio( cmd, (void *)&send_msg );
    return ERR_SUCCESS;
}

static int recv_allim_web_req( UINT16 inter_msg, void * ptrdata )
{
	return ERR_SUCCESS;
}

static int recv_web_firm_update_req( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t send_msg;
	allim_msg_t allim_msg ;
	
	print_dbg( DBG_INFO,1, "Recv Firmware Update from Web");
	
	memset( &allim_msg, 0, sizeof( allim_msg ));
	memset( &send_msg, 0, sizeof( send_msg ));

	allim_msg.allim_msg = ALM_UPDATE_DOWN_OK_MSG ;
	
	send_msg.client_id = WEB_CLIENTID;
	send_msg.msg 		= EFT_ALLIM_MSG;
	send_msg.ptrbudy   = &allim_msg;

	/* allim process */
	recv_allim_msg(EFT_ALLIM_MSG, &send_msg );

	return ERR_SUCCESS;
}

static int recv_allim_msg( UINT16 inter_msg, void * ptrdata )
{
	inter_msg_t * ptrmsg =NULL;
	allim_msg_t allim_msg ;
	int clientid;
	
	inter_msg_t send_msg;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}
	
	memset(&send_msg, 0, sizeof( send_msg ));
	memset( &allim_msg, 0, sizeof( allim_msg ));
	ptrmsg = ( inter_msg_t *)ptrdata;

	if ( ptrmsg->ptrbudy == NULL )
	{
		print_dbg( DBG_ERR,1, "is budy [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
	
	memcpy( &allim_msg, ptrmsg->ptrbudy, sizeof( allim_msg ));
	
	if ( allim_msg.allim_msg == ALM_UPDATE_DOWN_OK_MSG )
	{
		print_dbg( DBG_SAVE,1, "Recv Update Download OK Msg");


		allim_msg.allim_msg = ALM_UPDATE_WRITE_OK_MSG;
		/* intr msg */
		send_msg.client_id = ptrmsg->client_id;
		send_msg.msg 		= EFT_ALLIM_MSG;
		send_msg.ptrbudy 	= &allim_msg;
		/* send transfer */
		send_update_transfer(EFT_ALLIM_MSG,  (void *)&send_msg );
		/* reboot */
		print_dbg( DBG_SAVE,1, "RTU Reboot after 5 sec, becase of RTU Firmwate Updte !!" );

        /* update 상태 등록 */
        set_update_conf( get_sectick()  );
        sys_sleep( 2000 );
        
        if( g_eqp_auto.run == 0 )
        {
            g_reboot =1;
            sys_sleep( 5000 );
            //system_cmd("reboot");
            killall( APP_PNAME, 9 );
            killall( APP_PNAME, 9 );
        }
        else
        {
            print_dbg( DBG_ERR, 1, "Can not RTU Reboot With Firmware Update, becase of EPQ AUTOMOD run" );
        }
	}
	else if ( allim_msg.allim_msg == ALM_OP_CLOSE_NOTI_MSG  )
	{
		clientid = ptrmsg->client_id;
		set_cur_req_client( 0, clientid );
		set_cur_radio_req_all_client( 0, clientid );
		print_dbg( DBG_SAVE,1, "Recv OP Close Msg, ClientID:%d", clientid );
	}

	return ERR_SUCCESS;
}

/*================================================================================================
send 함수  정의 
================================================================================================*/
static int send_data_transfer( UINT16 inter_msg, void * ptrdata, int send_op  )
{
	int fms_net_sts = 0;
	int ret = ERR_RETURN;
	send_data_func ptrsend_data_func =  NULL;
	inter_msg_t * ptrmsg = NULL;

	if ( g_checked_ver == 0 )
	{
		print_dbg( DBG_ERR,1, "is not initialized [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}
    
    if ( g_reboot == 1 )
    {
		print_dbg( DBG_ERR,1, "Not Send to transfer becase of Rebooting... [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
    }

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR,1, "is null ptrdata [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_SUCCESS;
	}

	fms_net_sts = get_fms_server_net_sts();

	if (get_print_debug_shm() == 1 )
		print_dbg( DBG_INFO,1, "FMS NET STATUS :%d ########", fms_net_sts );

	if ( send_op == SEND_FMS )
	{
		if ( fms_net_sts == 0 )
		{
			ptrsend_data_func = g_ptrsend_fms_client;
		}
		else
		{
			ptrmsg = ( inter_msg_t *)ptrdata;
			ptrmsg->client_id = 0;
			ptrsend_data_func = g_ptrsend_op_server;
		}
	}
	else if (send_op == SEND_OP )
	{
		ptrsend_data_func = g_ptrsend_op_server;
	}

	if ( ptrsend_data_func != NULL )
	{
		ret = ptrsend_data_func( inter_msg, ptrdata );
	}
	else
	{
		if ( send_op != SEND_WEB )
		{
			print_dbg( DBG_ERR,1, "Isnull Send Function:%d, [%s:%d:%s]", send_op, __FILE__, __LINE__,__FUNCTION__);
		}
	}

	/*무조건 WebSocketServer로 보낸다 */
	if( g_ptrsend_websock != NULL )
	{
		g_ptrsend_websock( inter_msg, ptrdata );
	}
	return ret;
}

static int send_update_transfer( UINT16 inter_msg, void * ptrdata  )
{
	int ret = ERR_RETURN;
	
	if ( g_ptrsend_update != NULL )
	{
		ret = g_ptrsend_update( inter_msg, ptrdata );
	}

	return ret;
}

static int send_data_radio( UINT16 inter_msg, void * ptrdata )
{
	int ret = ERR_SUCCESS;

	ret = recv_ctrl_data_radio( inter_msg, ptrdata );
	return ret ;
}

static int send_data_mcu( UINT16 inter_msg, void * ptrdata )
{
	int ret = ERR_SUCCESS;

	ret = recv_ctrl_data_mcu( inter_msg, ptrdata );

	return ret;
}

static int send_data_pwr_c( UINT16 inter_msg, void * ptrdata )
{
	int ret = ERR_SUCCESS;

	ret = recv_ctrl_data_pwr_c( inter_msg, ptrdata );

	return ret;
}

static int send_data_remote( UINT16 inter_msg, void * ptrdata )
{
	int ret = ERR_SUCCESS;

	ret = recv_ctrl_data_remote( inter_msg, ptrdata );

	return ret;
}

/*====================================================================================================
	contorl -> transfer   
  ===================================================================================================*/
static int send_network_chang( int msg )
{
	inter_msg_t inter_msg;
	allim_msg_t allim_msg;
	int cmd = EFT_ALLIM_MSG;

	memset( &inter_msg, 0, sizeof( inter_msg ));
	memset( &allim_msg, 0, sizeof( allim_msg ));
	
	/* allim msg */
	allim_msg.allim_msg = msg;

	/* intr msg */
	inter_msg.client_id	= 0;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= &allim_msg;


	if ( msg == ALM_RTU_NET_CHG_NOTI_MSG )
	{
		send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );
		send_data_transfer( cmd, (void *)&inter_msg , SEND_OP  );
		send_update_transfer( cmd, (void *)&inter_msg);
		send_data_radio(cmd, (void *)&inter_msg);

	}
	else if ( msg == ALM_OP_NET_CHG_NOTI_MSG )
	{
		send_data_transfer( cmd, (void *)&inter_msg , SEND_OP  );
	}
	else if ( msg == ALM_FMS_NET_CHG_NOTI_MSG )
	{
		send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );
	}
	else if ( msg == ALM_FRE_NET_CHG_NOTI_MSG ||
			  msg == ALM_SRE_NET_CHG_NOTI_MSG ||	
			  msg == ALM_FDE_NET_CHG_NOTI_MSG || 
			  msg == ALM_FRE_NET_ADD_NOTI_MSG ||
			  msg == ALM_SRE_NET_ADD_NOTI_MSG ||	
			  msg == ALM_FDE_NET_ADD_NOTI_MSG || 
	          msg == ALM_FRE_NET_DEL_NOTI_MSG ||
			  msg == ALM_SRE_NET_DEL_NOTI_MSG ||	
			  msg == ALM_FDE_NET_DEL_NOTI_MSG  )
	{
		send_data_radio(cmd, (void *)&inter_msg);
	}
	else if ( msg == ALM_UPS_NET_CHG_NOTI_MSG ||
			  msg == ALM_UPS_NET_ADD_NOTI_MSG ||
			  msg == ALM_UPS_NET_DEL_NOTI_MSG  )
	{
		//send_data_ups(cmd, (void *)&inter_msg);
	}

	return ERR_SUCCESS;
}	

static int send_di_thrd_complet(int clientid,int sts, fclt_ctl_thrlddi_t * ptrdi_thrd , UINT16 cmd, int result )
{
	fclt_ctlthrldcompleted_t complete;
	inter_msg_t inter_msg;

	if( ptrdi_thrd == NULL )
	{
		print_dbg( DBG_ERR, 1, "is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memset( &complete, 0, sizeof( complete ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	memcpy( &complete.tfcltelem, &ptrdi_thrd->ctl_base.tfcltelem, sizeof( fms_elementfclt_t ));
	complete.esnsrtype 	= ptrdi_thrd->ctl_base.esnsrtype;
	complete.esnsrsub 	= ptrdi_thrd->ctl_base.esnsrsub;
	complete.idxsub		= ptrdi_thrd->ctl_base.idxsub; 
	complete.iresult 	= result;

	/* intr msg */
	inter_msg.client_id	= clientid;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= &complete;

	/* send transfer */
	send_data_transfer( cmd, (void *)&inter_msg , SEND_OP  );

	return ERR_SUCCESS;
}

static int send_di_thrd_fms(int clientid, fclt_ctl_thrlddi_t * ptrdi_thrd, int sns_type, UINT16 cmd )
{
	static volatile int di_thrd_send_cnt = 45;
	tid_t tid;
	inter_msg_t inter_msg;

	if( ptrdi_thrd == NULL )
	{
		print_dbg( DBG_ERR, 1, "is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	if ( di_thrd_send_cnt++ > MAX_SEND_CNT )
	{
		di_thrd_send_cnt = 1;
	}

	memset( &tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	tid.cur_time 	= time( NULL );
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= sns_type;
	tid.seq 		= di_thrd_send_cnt ;

	cnvt_fclt_tid( &tid );
	//memcpy( &ptrdi_thrd->ctl_base.tdbtans.sdbfclt_tid,tid.szdata , MAX_DBFCLT_TID );

	/* intr msg */
	cmd = cmd;
	inter_msg.client_id	= clientid;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= ptrdi_thrd;

	/* send transfer */
	send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

	return ERR_SUCCESS;
}

static int send_ai_thrd_fms(int clientid, fclt_ctl_thrldai_t * ptrai_thrd  )
{

	static volatile int ai_thrd_send_cnt = 90;
	tid_t tid;
	UINT16 cmd;
	inter_msg_t inter_msg;

	if( ptrai_thrd == NULL )
	{
		print_dbg( DBG_ERR, 1, "is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	if ( ai_thrd_send_cnt++ > MAX_SEND_CNT )
	{
		ai_thrd_send_cnt = 1;
	}

	memset( &tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	tid.cur_time 	= time( NULL );
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_AI;
	tid.seq 		= ai_thrd_send_cnt ;

	cnvt_fclt_tid( &tid );
	//memcpy( &ptrai_thrd->ctl_base.tdbtans.sdbfclt_tid, tid.szdata, MAX_DBFCLT_TID );

	/* intr msg */
	cmd = EFT_SNSRCTL_THRLD ;
	inter_msg.client_id	= clientid;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= ptrai_thrd;

	/* send transfer */
	send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

	return ERR_SUCCESS;
}

static int send_ai_thrd_complet(int clientid,int sts, fclt_ctl_thrldai_t * ptrai_thrd, int result )
{
	UINT16 cmd;
	fclt_ctlthrldcompleted_t complete;
	inter_msg_t inter_msg;

	if( ptrai_thrd == NULL )
	{
		print_dbg( DBG_ERR, 1, "is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memset( &complete, 0, sizeof( complete ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	memcpy( &complete.tfcltelem, &ptrai_thrd->ctl_base.tfcltelem, sizeof( fms_elementfclt_t ));
	complete.esnsrtype 	= ptrai_thrd->ctl_base.esnsrtype;
	complete.esnsrsub 	= ptrai_thrd->ctl_base.esnsrsub;
	complete.idxsub		= ptrai_thrd->ctl_base.idxsub; 
	complete.iresult 	= result ;

	/* intr msg */
	cmd = EFT_SNSRCTLCOMPLETED_THRLD;
	inter_msg.client_id	= clientid;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= &complete;

	/* send transfer */
	send_data_transfer( cmd, (void *)&inter_msg , SEND_OP  );

	return ERR_SUCCESS;
}

static int send_onoff_fms(int clientid, fclt_ctrl_snsronoff_t * ptronoff )
{
	static volatile int sns_onoff_send_cnt = 70 ;
	tid_t tid;
	UINT16 cmd;
	inter_msg_t inter_msg;
	time_t cur_time;

	if( ptronoff == NULL )
	{
		print_dbg( DBG_ERR, 1, "is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	if ( sns_onoff_send_cnt++ > MAX_SEND_CNT )
	{
		sns_onoff_send_cnt = 1;
	}

	memset( &tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	cur_time 		= time( NULL );
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DO;
	tid.seq 		= sns_onoff_send_cnt ;

	cnvt_fclt_tid( &tid );
	memcpy( &ptronoff->ctl_base.tdbtans.sdbfclt_tid, tid.szdata, MAX_DBFCLT_TID );
	ptronoff->ctl_base.tdbtans.tdatetime = (UINT32)cur_time;

	/* intr msg */
	cmd = EFT_SNSRCTL_POWER;
	inter_msg.client_id	= clientid;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= ptronoff ;

	/* send transfer */
	send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );
	return ERR_SUCCESS;
}

static int send_snsr_onoff_result_fms( int result )
{
	time_t cur_time ;
	fclt_collectrslt_dido_t dido_data;
	tid_t tid;
	inter_msg_t inter_msg;
	int send_cnt = 0;
	int i;
	int sel_pos = -1;
	sns_onoff_sts_t onoff_sts;
	UINT16 cmd =0;

	cur_time = time( NULL );
	memset( &dido_data, 0, sizeof( dido_data ));
	memset(&tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));
	memset(&onoff_sts, 0, sizeof( onoff_sts ));

	/* lock */
	lock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	if ( g_dido_send_cnt++ > MAX_SEND_CNT )
	{
		g_dido_send_cnt = 1;
	}

	send_cnt = g_dido_send_cnt;
	unlock_sem( g_ctrl_sem_id, g_ctrl_sem_key );

	/* unlock */

	/* make tid */
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DO;
	tid.seq 		= send_cnt;

	cnvt_fclt_tid( &tid );

	/* fcltelem */
	dido_data.aidido.tfcltelem.nsiteid 	= get_my_siteid_shm();
	dido_data.aidido.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
	dido_data.aidido.tfcltelem.efclt 	= EFCLT_RTU;

	/* transdbdata */
	dido_data.aidido.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( dido_data.aidido.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );

	/*d0 */
	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		if( get_last_sns_onoff_sts(g_do_val[ i ].snsr_id,  &onoff_sts ) == ERR_SUCCESS )
		{
				sel_pos = i;
				dido_data.rslt[0].esnsrtype = g_do_val[ i ].snsr_type;
				dido_data.rslt[0].esnsrsub 	= g_do_val[ i ].snsr_sub_type;
				dido_data.rslt[0].idxsub	= g_do_val[ i ].snsr_sub_idx;
				dido_data.rslt[0].ecnnstatus= g_mcu_sr_timeout;
				dido_data.rslt[0].brslt		= g_do_val[ i ].last_val;
				break;
		}
	}
	
	if ( sel_pos < 0 )
	{
		for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
		{
			if( get_last_sns_onoff_sts(g_doe_val[ i ].snsr_id,  &onoff_sts ) == ERR_SUCCESS )
			{
                print_dbg(DBG_INFO, 1, "######### SNSR ID...:%d.....LIST SNSR ID:%d....", onoff_sts.snsr_id, g_doe_val[ i ].snsr_id );

				sel_pos = i;
				dido_data.rslt[ 0 ].esnsrtype 	= g_doe_val[ i ].snsr_type;
				dido_data.rslt[ 0 ].esnsrsub 	= g_doe_val[ i ].snsr_sub_type;
				dido_data.rslt[ 0 ].idxsub		= g_doe_val[ i ].snsr_sub_idx;
				dido_data.rslt[ 0 ].ecnnstatus	= g_mcu_sr_timeout;
				dido_data.rslt[ 0 ].brslt		= g_doe_val[ i ].last_val;
				break;
			}
		}
	}

	if ( sel_pos >= 0 )
	{
		/* send count */
		dido_data.aidido.nfcltsubcount = 1;

		/* intr msg */
		cmd = EFT_SNSRCTL_RES;
		inter_msg.client_id	= onoff_sts.clientid;
		inter_msg.msg 		= cmd;
		inter_msg.ptrbudy 	= &dido_data;

		/* send transfer */
		send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );
		//printf("==============================sssssssssssssssssssssssssss:result:%d\r\n", result);	
	}
	return ERR_SUCCESS;
}

static int send_pwr_c_onoff_result_fms( int result )
{
	time_t cur_time ;
	fclt_collectrslt_dido_t dido_data;
	tid_t tid;
	inter_msg_t inter_msg;
	int send_cnt = 0;
	int i;
	int sel_pos = -1;
	sns_onoff_sts_t onoff_sts;
	UINT16 cmd;

	cur_time = time( NULL );
	memset( &dido_data, 0, sizeof( dido_data ));
	memset(&tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));
	memset(&onoff_sts, 0, sizeof( onoff_sts ));

	/* lock */
	lock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	if ( g_dido_send_cnt++ > MAX_SEND_CNT )
	{
		g_dido_send_cnt = 1;
	}

	send_cnt = g_dido_send_cnt;
	unlock_sem( g_ctrl_sem_id, g_ctrl_sem_key );

	/* unlock */

	/* make tid */
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DO;
	tid.seq 		= send_cnt;

	cnvt_fclt_tid( &tid );

	/* fcltelem */
	dido_data.aidido.tfcltelem.nsiteid 	= get_my_siteid_shm();
	dido_data.aidido.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
	dido_data.aidido.tfcltelem.efclt 	= EFCLT_RTU;

	/* transdbdata */
	dido_data.aidido.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( dido_data.aidido.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );

	/*pwr c */
	for( i = 0 ; i < MAX_PWR_C_PORT_CNT ; i++ )
	{
		if( get_last_sns_onoff_sts( g_pwr_c_val[ i ].snsr_id, &onoff_sts ) == ERR_SUCCESS )
		{
			sel_pos = i;
			dido_data.rslt[0].esnsrtype = g_pwr_c_val[ i ].snsr_type;
			dido_data.rslt[0].esnsrsub 	= g_pwr_c_val[ i ].snsr_sub_type;
			dido_data.rslt[0].idxsub	= g_pwr_c_val[ i ].snsr_sub_idx;
			dido_data.rslt[0].ecnnstatus= g_pwr_c_sr_timeout;
			g_pwr_c_val[ i ].last_val   = g_pwr_c_data.val[ i ];
			dido_data.rslt[0].brslt		= g_pwr_c_val[ i ].last_val;
			break;
		}
	}

	if ( sel_pos >= 0 )
	{
		/* send count */
		dido_data.aidido.nfcltsubcount = 1;

		/* intr msg */
		cmd = EFT_SNSRCTL_RES;
		inter_msg.client_id	= onoff_sts.clientid;
		inter_msg.msg 		= cmd;
		inter_msg.ptrbudy 	= &dido_data;

		/* send transfer */
		send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );
		//printf("==============================sssssssssssssssssssssssssss:result:%d\r\n", result);	
	}
	return ERR_SUCCESS;
}

static int send_snsr_remote_result_fms( int result )
{
	time_t cur_time ;
	fclt_collectrslt_dido_t dido_data;
	tid_t tid;
	inter_msg_t inter_msg;
	int send_cnt = 0;
	int sel_pos = -1;
	sns_onoff_sts_t onoff_sts;
	UINT16 cmd;

	cur_time = time( NULL );
	memset( &dido_data, 0, sizeof( dido_data ));
	memset(&tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));
	memset(&onoff_sts, 0, sizeof( onoff_sts ));

	/* lock */
	lock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	if ( g_dido_send_cnt++ > MAX_SEND_CNT )
	{
		g_dido_send_cnt = 1;
	}

	send_cnt = g_dido_send_cnt;
	unlock_sem( g_ctrl_sem_id, g_ctrl_sem_key );

	/* unlock */

	/* make tid */
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DO;
	tid.seq 		= send_cnt;

	cnvt_fclt_tid( &tid );

	/* fcltelem */
	dido_data.aidido.tfcltelem.nsiteid 	= get_my_siteid_shm();
	dido_data.aidido.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
	dido_data.aidido.tfcltelem.efclt 	= EFCLT_RTU;

	/* transdbdata */
	dido_data.aidido.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( dido_data.aidido.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );

	if( get_last_sns_onoff_sts(g_remote_val.snsr_id , &onoff_sts ) == ERR_SUCCESS )
	{
		sel_pos = 0;
		dido_data.rslt[0].esnsrtype = g_remote_val.snsr_type;
		dido_data.rslt[0].esnsrsub 	= g_remote_val.snsr_sub_type;
		dido_data.rslt[0].idxsub	= g_remote_val.snsr_sub_idx;
		dido_data.rslt[0].ecnnstatus= g_remote_sr_timeout;
		dido_data.rslt[0].brslt		= g_remote_val.last_val;
	}

	if ( sel_pos >=0 )
	{
		/* send count */
		dido_data.aidido.nfcltsubcount = 1;

		/* intr msg */
		cmd = EFT_SNSRCTL_RES;
		inter_msg.client_id	= onoff_sts.clientid;
		inter_msg.msg 		= cmd;
		inter_msg.ptrbudy 	= &dido_data;

		/* send transfer */
		send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );
		//printf("==============================sssssssssssssssssssssssssss:result:%d\r\n", result);	
	}

	return ERR_SUCCESS;
}

static int send_ai_data(int clientid, UINT16 cmd, int send_op )
{
	time_t cur_time;
	fclt_collectrslt_ai_t ai_data;
	tid_t tid;
	inter_msg_t inter_msg;
	int send_cnt = 0;
	int sts = 0;
	int i = 0;
	int ai_cnt = 0;


	/* lock */
	lock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	if ( g_ai_send_cnt++ > MAX_SEND_CNT )
	{
		g_ai_send_cnt = 1;
	}
	send_cnt = g_ai_send_cnt;
	unlock_sem( g_ctrl_sem_id, g_ctrl_sem_key );

	/* unlock */

	/* make tid */
	memset(&tid, 0, sizeof( tid ));
	cur_time = time( NULL );
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_AI;
	tid.seq 		= send_cnt;
	
	cnvt_fclt_tid( &tid );

	/* fcltelem */
	ai_data.aidido.tfcltelem.nsiteid 	= get_my_siteid_shm();
	ai_data.aidido.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
	ai_data.aidido.tfcltelem.efclt 	= EFCLT_RTU;

	/* transdbdata */
	ai_data.aidido.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( ai_data.aidido.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );

	/* TEMP */
	lock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	sts = g_temp_sr_timeout;
	unlock_sem( g_ctrl_sem_id, g_ctrl_sem_key );

	for( i = 0 ; i < MAX_TEMP_CNT ; i++ )
	{
		if ( g_temp_val[ i ].snsr_id != 0 && g_temp_val[ i ].snsr_sub_type != 0 )
		{
			if ( ai_cnt < MAX_GRP_RSLT_AI )
			{
				ai_data.rslt[ ai_cnt ].esnsrtype 	= g_temp_val[ i ].snsr_type;
				ai_data.rslt[ ai_cnt ].esnsrsub 	= g_temp_val[ i ].snsr_sub_type;
				ai_data.rslt[ ai_cnt ].idxsub		= g_temp_val[ i ].snsr_sub_idx;
				ai_data.rslt[ ai_cnt ].ecnnstatus	= sts;
                if ( sts == ESNSRCNNST_ERROR )
                {
                    ai_data.rslt[ ai_cnt ].frslt		= DI_UN_VAL;
                }
                else
                {
                    ai_data.rslt[ ai_cnt ].frslt		= g_temp_val[ i ].last_val;
                }

				ai_cnt++;
			}
		}
	}

	/* PWR M */
	lock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	sts = g_pwr_m_sr_timeout;
	unlock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	for( i = 0 ; i < MAX_PWR_M_CNT ; i++ )
	{
		if ( g_pwr_m_val[ i ].snsr_id != 0 && g_pwr_m_val[ i ].snsr_sub_type != 0 )
		{
			if ( ai_cnt < MAX_GRP_RSLT_AI )
			{
				ai_data.rslt[ ai_cnt ].esnsrtype 	= g_pwr_m_val[ i ].snsr_type;
				ai_data.rslt[ ai_cnt ].esnsrsub 	= g_pwr_m_val[ i ].snsr_sub_type;
				ai_data.rslt[ ai_cnt ].idxsub		= g_pwr_m_val[ i ].snsr_sub_idx;
				ai_data.rslt[ ai_cnt ].ecnnstatus	= sts;
                if ( sts == ESNSRCNNST_ERROR )
                {
                    ai_data.rslt[ ai_cnt ].frslt		= DI_UN_VAL;
                }
                else
                {
				    ai_data.rslt[ ai_cnt ].frslt		= g_pwr_m_val[ i ].last_val;
                }
				ai_cnt++;
			}
		}
	}

	sts = g_apc_ups_sr_timeout;
	for( i = 0; i < MAX_APC_UPS_DATA_CNT ; i++ )
	{
		if ( ai_cnt < MAX_GRP_RSLT_DI )
		{
			if ( g_apc_ups_ai_val[ i ].snsr_id != 0 && g_apc_ups_ai_val[ i ].snsr_sub_type != 0 && g_apc_ups_ai_val[ i ].last_val >=0 )
			{
				sts = g_apc_ups_sr_timeout;
				ai_data.rslt[ ai_cnt ].esnsrtype 	= g_apc_ups_ai_val[ i ].snsr_type;
				ai_data.rslt[ ai_cnt ].esnsrsub 	= g_apc_ups_ai_val[ i ].snsr_sub_type;
				ai_data.rslt[ ai_cnt ].idxsub		= g_apc_ups_ai_val[ i ].snsr_sub_idx;
				ai_data.rslt[ ai_cnt ].ecnnstatus	= sts;
				if ( sts == ESNSRCNNST_ERROR )
				{
					ai_data.rslt[ ai_cnt ].frslt		= DI_UN_VAL;
				}
				else
				{
					ai_data.rslt[ ai_cnt ].frslt		= g_apc_ups_ai_val[ i ].last_val;
				}
				ai_cnt++;
			}
		}
	}
	//printf("======ai_cnt:%d.......%s.............\r\n", ai_cnt,tid.szdata);
	/* send count */
	if ( ai_cnt > 0 )
	{
		ai_data.aidido.nfcltsubcount = ai_cnt;

		/* intr msg */
		inter_msg.client_id	= clientid;
		inter_msg.msg 		= cmd;
		inter_msg.ptrbudy 	= &ai_data;

		/* send transfer */
		send_data_transfer( cmd, (void *)&inter_msg , send_op  );
	}

	return ERR_SUCCESS;
}

static int send_dido_data(int clientid, UINT16 cmd, int send_op )
{
	time_t cur_time ;
	fclt_collectrslt_dido_t dido_data;
	tid_t tid;
	inter_msg_t inter_msg;
	int send_cnt = 0;
	int sts = 0;
	int i;
	int dido_cnt = 0;


	cur_time = time( NULL );
	memset( &dido_data, 0, sizeof( dido_data ));
	memset(&tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	/* lock */
	lock_sem( g_ctrl_sem_id, g_ctrl_sem_key );
	if ( g_dido_send_cnt++ > MAX_SEND_CNT )
	{
		g_dido_send_cnt = 1;
	}
	send_cnt = g_dido_send_cnt;

	unlock_sem( g_ctrl_sem_id, g_ctrl_sem_key );

	/* unlock */

	/* make tid */
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DI;
	tid.seq 		= send_cnt;

	cnvt_fclt_tid( &tid );

	/* fcltelem */
	dido_data.aidido.tfcltelem.nsiteid 	= get_my_siteid_shm();
	dido_data.aidido.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
	dido_data.aidido.tfcltelem.efclt 	= EFCLT_RTU;

	/* transdbdata */
	dido_data.aidido.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( dido_data.aidido.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );

	sts = g_mcu_sr_timeout;
	/* di */
	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		if ( g_di_val[ i ].snsr_id != 0 && g_di_val[ i ].snsr_sub_type != 0 )
		{
			if ( dido_cnt < MAX_GRP_RSLT_DI )
			{
				dido_data.rslt[ dido_cnt ].esnsrtype 	= g_di_val[ i ].snsr_type;
				dido_data.rslt[ dido_cnt ].esnsrsub 	= g_di_val[ i ].snsr_sub_type;
				dido_data.rslt[ dido_cnt ].idxsub		= g_di_val[ i ].snsr_sub_idx;
				dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;

                if ( sts == ESNSRCNNST_ERROR )
                {
				    dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                }
                else
                {
				    dido_data.rslt[ dido_cnt ].brslt		= g_di_val[ i ].last_val;
                }
				dido_cnt++;
			}
		}
	}

	/*do */
	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		if ( g_do_val[ i ].snsr_id != 0 && g_do_val[ i ].snsr_sub_type != 0 )
		{
			if ( dido_cnt < MAX_GRP_RSLT_DI )
			{
				dido_data.rslt[ dido_cnt ].esnsrtype 	= g_do_val[ i ].snsr_type;
				dido_data.rslt[ dido_cnt ].esnsrsub 	= g_do_val[ i ].snsr_sub_type;
				dido_data.rslt[ dido_cnt ].idxsub		= g_do_val[ i ].snsr_sub_idx;
				dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
                if ( sts == ESNSRCNNST_ERROR )
                {
				    dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                }
                else
                {
				    dido_data.rslt[ dido_cnt ].brslt		= g_do_val[ i ].last_val;
                }

				dido_cnt++;
			}
		}
	}

	/* doe */
	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		if ( g_doe_val[ i ].snsr_id != 0 && g_doe_val[ i ].snsr_sub_type != 0 )
		{
			if ( dido_cnt < MAX_GRP_RSLT_DI )
			{
				dido_data.rslt[ dido_cnt ].esnsrtype 	= g_doe_val[ i ].snsr_type;
				dido_data.rslt[ dido_cnt ].esnsrsub 	= g_doe_val[ i ].snsr_sub_type;
				dido_data.rslt[ dido_cnt ].idxsub		= g_doe_val[ i ].snsr_sub_idx;
				dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
                if ( sts == ESNSRCNNST_ERROR )
                {
				    dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                }
                else
                {
				    dido_data.rslt[ dido_cnt ].brslt		= g_doe_val[ i ].last_val;
                }
				dido_cnt++;
			}
		}
	}
	
	/* remote control */
	sts = g_remote_sr_timeout;
	if ( dido_cnt < MAX_GRP_RSLT_DI )
	{

		if ( g_remote_val.snsr_id != 0 && g_remote_val.snsr_sub_type != 0 )
		{
			sts = g_remote_sr_timeout;
			dido_data.rslt[ dido_cnt ].esnsrtype 	= g_remote_val.snsr_type;
			dido_data.rslt[ dido_cnt ].esnsrsub 	= g_remote_val.snsr_sub_type;
			dido_data.rslt[ dido_cnt ].idxsub		= g_remote_val.snsr_sub_idx;
			dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
            if ( sts == ESNSRCNNST_ERROR )
            {
                dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
            }
            else
            {
			    dido_data.rslt[ dido_cnt ].brslt		= g_remote_val.last_val;
            }

			dido_cnt++;
		}
	}

	/* 영상 on/off */
	if ( dido_cnt < MAX_GRP_RSLT_DI )
	{
		if ( g_video_val.snsr_id != 0 && g_video_val.snsr_sub_type != 0 )
		{
			sts = g_video_tcp_timeout;
			dido_data.rslt[ dido_cnt ].esnsrtype 	= g_video_val.snsr_type;
			dido_data.rslt[ dido_cnt ].esnsrsub 	= g_video_val.snsr_sub_type;
			dido_data.rslt[ dido_cnt ].idxsub		= g_video_val.snsr_sub_idx;
			dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
            if ( sts == ESNSRCNNST_ERROR )
            {
                dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
            }
            else
            {
			    dido_data.rslt[ dido_cnt ].brslt		= g_video_val.last_val;
            }

			dido_cnt++;
		}
	}

	/* ground */
	sts = g_pwr_m_sr_timeout;
	if ( dido_cnt < MAX_GRP_RSLT_DI )
	{
		if ( g_ground_val.snsr_id != 0 && g_ground_val.snsr_sub_type != 0 )
		{
			sts = g_pwr_m_sr_timeout;
			dido_data.rslt[ dido_cnt ].esnsrtype 	= g_ground_val.snsr_type;
			dido_data.rslt[ dido_cnt ].esnsrsub 	= g_ground_val.snsr_sub_type;
			dido_data.rslt[ dido_cnt ].idxsub		= g_ground_val.snsr_sub_idx;
			dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
            if ( sts == ESNSRCNNST_ERROR )
            {
                dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
            }
            else
            {
			    dido_data.rslt[ dido_cnt ].brslt		= g_ground_val.last_val;
            }

			dido_cnt++;
		}
	}

	/* ups */
	sts = g_apc_ups_sr_timeout;
	for( i = 0; i < MAX_APC_UPS_DATA_CNT ; i++ )
	{
		if ( dido_cnt < MAX_GRP_RSLT_DI )
		{
			if ( g_apc_ups_di_val[ i ].snsr_id != 0 && g_apc_ups_di_val[ i ].snsr_sub_type != 0 )
			{
				sts = g_apc_ups_sr_timeout;
				dido_data.rslt[ dido_cnt ].esnsrtype 	= g_apc_ups_di_val[ i ].snsr_type;
				dido_data.rslt[ dido_cnt ].esnsrsub 	= g_apc_ups_di_val[ i ].snsr_sub_type;
				dido_data.rslt[ dido_cnt ].idxsub		= g_apc_ups_di_val[ i ].snsr_sub_idx;
				dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
				if ( sts == ESNSRCNNST_ERROR )
				{
					dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
				}
				else
				{
					dido_data.rslt[ dido_cnt ].brslt		= g_apc_ups_di_val[ i ].last_val;
				}
				dido_cnt++;
			}
		}
	}

#if 1
	/* pwr c */
	sts = g_pwr_c_sr_timeout;
	for( i = 0 ; i < MAX_PWR_C_PORT_CNT ; i++ )
	{
		if ( g_pwr_c_val[ i ].snsr_id != 0 && g_pwr_c_val[ i ].snsr_sub_type != 0 )
		{
			if ( dido_cnt < MAX_GRP_RSLT_DI )
			{
				dido_data.rslt[ dido_cnt ].esnsrtype 	= g_pwr_c_val[ i ].snsr_type;
				dido_data.rslt[ dido_cnt ].esnsrsub 	= g_pwr_c_val[ i ].snsr_sub_type;
				dido_data.rslt[ dido_cnt ].idxsub		= g_pwr_c_val[ i ].snsr_sub_idx;
				dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
                if ( sts == ESNSRCNNST_ERROR )
                {
				    dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                }
                else
                {
				    dido_data.rslt[ dido_cnt ].brslt		= g_pwr_c_data.val[ i ];
                }
				dido_cnt++;
			}
		}
	}
#endif
	/* send count */
	if ( dido_cnt > 0 )
	{
		dido_data.aidido.nfcltsubcount = dido_cnt;

		//printf("kkkkkkkkkkkkkk....:%d................\r\n", dido_cnt);

		/* intr msg */
		inter_msg.client_id	= clientid;
		inter_msg.msg 		= cmd;
		inter_msg.ptrbudy 	= &dido_data;

		/* send transfer */
		send_data_transfer( cmd, (void *)&inter_msg , send_op  );
	}
	return ERR_SUCCESS;
}

static int send_radio_data( int clientid, UINT16 cmd, int send_op, volatile int *ptrsend_cnt, radio_val_manager_t * ptrmanager, int fclt_code, int tcp_sts )
{
	time_t cur_time ;
	fclt_collectrslt_dido_t dido_data;
	tid_t tid;
	inter_msg_t inter_msg;
	int send_cnt = 0;
	int sts = 0;
	int i;
	int dido_cnt = 0;
	int fcltid =0;
	int pos, dev_cnt;
    int flag = 0;


	cur_time = time( NULL );
	memset( &dido_data, 0, sizeof( dido_data ));
	memset(&tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));
	
	send_cnt = *ptrsend_cnt;

	if ( send_cnt++ >= MAX_SEND_CNT )
	{
		send_cnt  = 1;
	}
    
    *ptrsend_cnt = send_cnt;

	sts = tcp_sts;

	/* make tid */
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DI;
	tid.seq 		= send_cnt;

	cnvt_fclt_tid( &tid );

	for( i = 0 ; i < MAX_RADIO_SNS_CNT ; i++ )
	{
		if ( ptrmanager->radio_val[ i ].snsr_id > 0 )
		{
			fcltid 	 = ptrmanager->radio_val[ i ].fclt_id;
			break;
		}
	}

	/* fcltelem */
	dido_data.aidido.tfcltelem.nsiteid 	= get_my_siteid_shm();
	dido_data.aidido.tfcltelem.nfcltid 	= fcltid;;
	dido_data.aidido.tfcltelem.efclt 	= fclt_code;

	/* transdbdata */
	dido_data.aidido.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( dido_data.aidido.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );

	/*  */
	for( i = 0 ; i < MAX_RADIO_SNS_CNT; i++ )
	{
		if ( ptrmanager->radio_val[ i ].snsr_id != 0 && ptrmanager->radio_val[ i ].snsr_sub_type != 0 )
		{
            if ( ( ptrmanager->radio_val[ i ].snsr_sub_type != ESNSRSUB_EQPFRE_POWER ) &&
                    ( ptrmanager->radio_val[ i ].snsr_sub_type != ESNSRSUB_EQPSRE_POWER ) &&
                    ( ptrmanager->radio_val[ i ].snsr_sub_type != ESNSRSUB_EQPFDE_POWER ) )
            {
                if ( dido_cnt < MAX_GRP_RSLT_DI )
                {
                    dido_data.rslt[ dido_cnt ].esnsrtype 	= ptrmanager->radio_val[ i ].snsr_type;
                    dido_data.rslt[ dido_cnt ].esnsrsub 	= ptrmanager->radio_val[ i ].snsr_sub_type;
                    dido_data.rslt[ dido_cnt ].idxsub		= ptrmanager->radio_val[ i ].snsr_sub_idx;
                    dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
                    if ( sts == ESNSRCNNST_ERROR )
                    {
                        dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                    }
                    else
                    {
                        dido_data.rslt[ dido_cnt ].brslt		= ptrmanager->radio_val[ i ].last_val;
                    }
                    dido_cnt++;
                }
            }
		}
	}

	/* power dev : 전원 장치  */
	for ( i = 0 ; i < MAX_PWR_DEV_CNT ; i++ )
	{
		if ( g_pwr_dev_val[ i ].snsr_id != 0 && g_pwr_dev_val[ i ].snsr_sub_type != 0 )
		{
			dev_cnt = 0;
			pos = 0;
			dev_cnt = g_pwr_dev_val[ i ].pwr_mthod_mng.cnt;
			/* 마지막 정보를 가져옴 */
			dev_cnt -=1;

			/* mthod가 존재할경우 */
			if ( dev_cnt >= 0 ) 
			{
				pos    = g_pwr_dev_val[ i ].pwr_mthod_mng.dev[ dev_cnt ].dev_pos;

				if ( dido_cnt < MAX_GRP_RSLT_DI )
				{
					/* 준고정일때 */
					if ( ( g_pwr_dev_val[ i ].snsr_sub_type == ESNSRSUB_EQPSRE_POWER ) && ( fclt_code == g_sre_fclt_code ) )
					{
						//sts = g_sre_tcp_sts;
						sts = g_mcu_sr_timeout;

						dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
                        if ( sts == ESNSRCNNST_ERROR )
                        {
                            dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                        }
                        else
                        {
                            dido_data.rslt[ dido_cnt ].brslt		= g_doe_val[ pos ].last_val;
                        }

                        dido_data.rslt[ dido_cnt ].esnsrtype 	= g_pwr_dev_val[ i ].snsr_type;
                        dido_data.rslt[ dido_cnt ].esnsrsub 	= g_pwr_dev_val[ i ].snsr_sub_type;
                        dido_data.rslt[ dido_cnt ].idxsub		= g_pwr_dev_val[ i ].snsr_sub_idx;

						dido_cnt++;
                        flag = 1;
					}
					/* 고정 일때 */
					else if ( ( g_pwr_dev_val[ i ].snsr_sub_type == ESNSRSUB_EQPFRE_POWER) && ( fclt_code == g_fre_fclt_code )   )
					{
						//sts = g_sre_tcp_sts;
						sts = g_pwr_c_sr_timeout;

                        dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
                        if ( sts == ESNSRCNNST_ERROR )
                        {
                            dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                        }
                        else
                        {
                            dido_data.rslt[ dido_cnt ].brslt		= g_pwr_c_data.val[ pos ];
                        }

                        dido_data.rslt[ dido_cnt ].esnsrtype 	= g_pwr_dev_val[ i ].snsr_type;
                        dido_data.rslt[ dido_cnt ].esnsrsub 	= g_pwr_dev_val[ i ].snsr_sub_type;
                        dido_data.rslt[ dido_cnt ].idxsub		= g_pwr_dev_val[ i ].snsr_sub_idx;
                        dido_cnt++;
                        flag = 1;
					}
					/* 고정 방탐 일때 */
					else if ( ( g_pwr_dev_val[ i ].snsr_sub_type == ESNSRSUB_EQPFDE_POWER) && ( fclt_code == g_fde_fclt_code )   )
					{
						//sts = g_fde_tcp_sts;
						sts = g_pwr_c_sr_timeout;
						dido_data.rslt[ dido_cnt ].ecnnstatus	= sts;
                        if ( sts == ESNSRCNNST_ERROR )
                        {
                            dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                        }
                        else
                        {
						    dido_data.rslt[ dido_cnt ].brslt		= g_pwr_c_data.val[ pos ];
                        }

                        dido_data.rslt[ dido_cnt ].esnsrtype 	= g_pwr_dev_val[ i ].snsr_type;
                        dido_data.rslt[ dido_cnt ].esnsrsub 	= g_pwr_dev_val[ i ].snsr_sub_type;
                        dido_data.rslt[ dido_cnt ].idxsub		= g_pwr_dev_val[ i ].snsr_sub_idx;
						dido_cnt++;
                        flag = 1;
                    } 
				}
			}
		}
	}
   
    /* 전원제어 포트 정보가 없을 경우 강제로 -1 한다 */
    if ( flag == 0 )
    {
        for( i = 0 ; i < MAX_RADIO_SNS_CNT; i++ )
        {
            if ( ptrmanager->radio_val[ i ].snsr_id != 0 && ptrmanager->radio_val[ i ].snsr_sub_type != 0 )
            {
                if ( ( ptrmanager->radio_val[ i ].snsr_sub_type == ESNSRSUB_EQPFRE_POWER ) ||
                        ( ptrmanager->radio_val[ i ].snsr_sub_type == ESNSRSUB_EQPSRE_POWER ) ||
                        ( ptrmanager->radio_val[ i ].snsr_sub_type == ESNSRSUB_EQPFDE_POWER ) )
                {
                    if ( dido_cnt < MAX_GRP_RSLT_DI )
                    {
                        dido_data.rslt[ dido_cnt ].esnsrtype 	= ptrmanager->radio_val[ i ].snsr_type;
                        dido_data.rslt[ dido_cnt ].esnsrsub 	= ptrmanager->radio_val[ i ].snsr_sub_type;
                        dido_data.rslt[ dido_cnt ].idxsub		= ptrmanager->radio_val[ i ].snsr_sub_idx;
                        dido_data.rslt[ dido_cnt ].ecnnstatus	= ESNSRCNNST_ERROR;
                        dido_data.rslt[ dido_cnt ].brslt		= DI_UN_VAL;
                        dido_cnt++;
                    }
                }
            }
        }
    }

	/* send count */
	if ( dido_cnt > 0 )
	{
		dido_data.aidido.nfcltsubcount = dido_cnt;

		if ( dido_cnt == 0 )
			return ERR_SUCCESS;

		/* intr msg */
		inter_msg.client_id	= clientid;
		inter_msg.msg 		= cmd;
		inter_msg.ptrbudy 	= &dido_data;

		/* send transfer */
		send_data_transfer( cmd, (void *)&inter_msg , send_op  );
		/* DB 등록 */
	}
	return ERR_SUCCESS;
}

static int send_fre_data(int clientid, UINT16 cmd, int send_op )
{
	static volatile int fre_send_cnt = 110;

	send_radio_data( clientid, cmd, send_op, &fre_send_cnt, &g_fre_mng , g_fre_fclt_code, g_fre_tcp_sts );
	
	return ERR_SUCCESS;
}

static int send_frs_data(int clientid, UINT16 cmd, int send_op )
{
	static volatile int frs_send_cnt = 155;
	
	send_radio_data( clientid, cmd, send_op, &frs_send_cnt, &g_frs_mng , g_frs_fclt_code, g_fre_tcp_sts );

	return ERR_SUCCESS;
}

static int send_sre_data(int clientid, UINT16 cmd, int send_op )
{
	static volatile int sre_send_cnt = 134;
	
	send_radio_data( clientid, cmd, send_op, &sre_send_cnt, &g_sre_mng , g_sre_fclt_code, g_sre_tcp_sts );

	return ERR_SUCCESS;
}

static int send_fde_data(int clientid, UINT16 cmd, int send_op )
{
	static volatile int fde_send_cnt = 198;
	
	send_radio_data( clientid, cmd, send_op, &fde_send_cnt, &g_fde_mng , g_fde_fclt_code, g_fde_tcp_sts );

	return ERR_SUCCESS;
}

static fclt_info_t * get_fclt_withcode( int fcltcode )
{
	int i;

	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_fclt_info[ i ].fcltid == 0 )
			break;

		if ( g_fclt_info[ i ].fcltcode == fcltcode )
		{
			return &g_fclt_info[ i ];
		}
	}

	return NULL;
}

static int send_fclt_netsts( int fcltcode, int sts, int snsr_sub_type )
{
	time_t cur_time;

	static volatile int fclt_evt_send_cnt = 10;
	fclt_evt_faultfclt_t fault_fclt;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;
	fclt_info_t * ptrfclt = NULL;

	cur_time = time( NULL );
	memset( &fault_fclt, 0, sizeof( fault_fclt ));
	memset(&tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	if ( fclt_evt_send_cnt++ > MAX_SEND_CNT )
	{
		fclt_evt_send_cnt = 1;
	}
	/* make tid */
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DI;
	tid.seq 		= fclt_evt_send_cnt;

	cnvt_fclt_tid( &tid );

	ptrfclt = get_fclt_withcode( fcltcode );
	
	if ( ptrfclt == NULL )
	{
		print_dbg( DBG_ERR,1, "not find sts [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	/* fcltelem */
	fault_fclt.tfcltelem.nsiteid 	= get_my_siteid_shm();
	fault_fclt.tfcltelem.nfcltid 	= ptrfclt->fcltid;;
	fault_fclt.tfcltelem.efclt 	    = ptrfclt->fcltcode;
    fault_fclt.ecnnstatus           = sts;

	/* transdbdata */
	fault_fclt.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( fault_fclt.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );
   
    /* 감시 장치의 네트워크 상태가 변경되었을 경우 ip와 port  정보를 올려준다 */
    memcpy( inter_msg.szdata, ptrfclt->szip , strlen( ptrfclt->szip ));
    inter_msg.ndata = ptrfclt->port;

	/* intr msg */
	cmd = EFT_EVT_FCLTNETWORK_ERR;
	inter_msg.client_id	= 0;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= &fault_fclt;
    
	/* send transfer */
	send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

	return ERR_SUCCESS;
}

static int send_sns_netsts( int sts , int snsr_type, int snsr_sub_type, int snsr_id )
{
	time_t cur_time;

	static volatile int sns_evt_send_cnt = 30;
	fclt_evt_faultdi_t fault_di;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;

	cur_time = time( NULL );
	memset( &fault_di, 0, sizeof( fault_di ));
	memset(&tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	if ( sns_evt_send_cnt++ > MAX_SEND_CNT )
	{
		sns_evt_send_cnt = 1;
	}
	/* make tid */
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DI;
	tid.seq 		= sns_evt_send_cnt;

	cnvt_fclt_tid( &tid );

	/* fcltelem */
	fault_di.fault_aidi.tfcltelem.nsiteid 	= get_my_siteid_shm();
	fault_di.fault_aidi.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();
	fault_di.fault_aidi.tfcltelem.efclt 	= EFCLT_RTU;

	/* transdbdata */
	fault_di.fault_aidi.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( fault_di.fault_aidi.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );
#if 0
	fault_di.rslt[ 0 ].esnsrtype 			= ptrfclt->snsr_type ;
	fault_di.rslt[ 0 ].esnsrsub 			= ptrflct->snsr_sub_type;
	fault_di.rslt[ 0 ].idxsub 				= ptrfclt->snsr_sub_idx;
#else
	fault_di.rslt[ 0 ].esnsrtype 			= snsr_type ;
	fault_di.rslt[ 0 ].esnsrsub 			= snsr_sub_type;
	fault_di.rslt[ 0 ].idxsub 				= 0 ;
#endif
	fault_di.rslt[ 0 ].ecnnstatus 			= sts ;
    if ( sts != ESNSRCNNST_NORMAL )
    {
	    fault_di.rslt[ 0 ].egrade				= EFCLTGRADE_UNKNOWN;
	    fault_di.rslt[ 0 ].brslt				= DI_UN_VAL;
    }
    else
    {
	    fault_di.rslt[ 0 ].egrade				= EFCLTGRADE_NORMAL;
	    fault_di.rslt[ 0 ].brslt				= DI_UN_VAL;
    }

	fault_di.fault_aidi.nfcltsubcount 		= 1;
    inter_msg.fault_snsr_id[ 0 ] = snsr_id;

	/* intr msg */
	cmd = EFT_SNSREVT_FAULT;
	inter_msg.client_id	= 0;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= &fault_di;

	/* send transfer */
	send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

	return ERR_SUCCESS;

}

static int send_req_time(void )
{
	int ret = ERR_SUCCESS;

	UINT16 cmd;
	inter_msg_t inter_msg;
	fclt_reqtimedata_t req_time;

	memset(&inter_msg, 0, sizeof( inter_msg ));
	memset(&req_time, 0, sizeof( req_time));

	/* fcltelem */
	req_time.tfcltelem.nsiteid 	= get_my_siteid_shm();
	req_time.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
	req_time.tfcltelem.efclt 	= EFCLT_RTU;
	
	req_time.timet =(UINT32)time(NULL);

	/* intr msg */
	cmd = EFT_TIMEDAT_REQ;
	inter_msg.client_id	= 0;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= &req_time;

	/* send transfer */
	ret = send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );
	print_dbg( DBG_INFO,1,"########## Send Time Sync Request");
	return ret; 
}

static int send_base_db_update_res( int ret, int clientid, int editinfo , int ctlcmd )
{
	UINT16 cmd;
	inter_msg_t inter_msg;
	fclt_evt_dbdataupdate_t db_update;
	int send_target = 0;

	memset(&inter_msg, 0, sizeof( inter_msg ));
	memset(&db_update, 0, sizeof( db_update));

	/* fcltelem */
	db_update.tfcltelem.nsiteid 	= get_my_siteid_shm();
	db_update.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
	db_update.tfcltelem.efclt 	    = EFCLT_RTU;

    db_update.ectltype          = EFCLTCTLTYP_BASEDATAUPDATE;
    db_update.ectlcmd           = EFCLTCTLCMD_WORKCOMPLETE;
    db_update.edbeditinfo       = editinfo;

	/* intr msg */
	cmd = EFT_EVT_BASEDATUPDATE_RES;
	inter_msg.client_id	= clientid;
	inter_msg.msg 		= cmd;
	inter_msg.ptrbudy 	= &db_update;

	/* send transfer */
	if (clientid > 0 )
		send_target = SEND_OP;
	else
		send_target = SEND_FMS;

	print_dbg(DBG_INFO,1,"########## Send Update DB Result Client:%d", send_target );
	send_data_transfer( cmd, (void *)&inter_msg , send_target  );
	
	return ERR_SUCCESS;
}

static int get_cmd_func( unsigned short inter_msg, void * ptrdata)
{
	UINT16 msg;
	proc_func ptrfunc = NULL;
	int i, cnt;

	if( inter_msg != 0 && ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	cnt = g_trans_func_cnt;

	for( i = 0 ; i < cnt  ; i++ )
	{
		msg 	= trans_proc_list[ i ].inter_msg;
		ptrfunc	= trans_proc_list[ i ].ptrproc; 

		if ( ptrfunc != NULL && msg == inter_msg )
		{
			ptrfunc( msg, ptrdata );
		}
	}
	
	return ERR_SUCCESS;
}

static int internal_recv_cmd_data_transfer( unsigned short inter_msg, void * ptrdata )
{
	return get_cmd_func( inter_msg, ptrdata );
}

static int internal_recv_cmd_data_websock( unsigned short inter_msg, void * ptrdata )
{
	return get_cmd_func( inter_msg, ptrdata );
}


static int internal_recv_update_transfer( unsigned short inter_msg, void * ptrdata )
{
	UINT16 msg;
	proc_func ptrfunc = NULL;
	int i, cnt;

	if( inter_msg != 0 && ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	cnt = g_update_func_cnt;

	for( i = 0 ; i < cnt  ; i++ )
	{
		msg 	= update_proc_list[ i ].inter_msg;
		ptrfunc	= update_proc_list[ i ].ptrproc; 

		if ( ptrfunc != NULL && msg == inter_msg )
		{
			ptrfunc( msg, ptrdata );
		}
	}

	return ERR_SUCCESS;
}

/* not used */
static int internal_recv_sns_data_sensor( unsigned short inter_msg, void * ptrdata )
{
	if( inter_msg != 0 && ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	return ERR_SUCCESS;
}

/* 모니터링 데이터를 FMS 로 보낸다 */
static int check_mor_data( UINT32 cur_time  )
{
	UINT32 interval = 0;
	int send_time = 0;
    
    //UINT32 st,ed = 0;

	send_time = get_send_cycle_shm();
	//send_time = 10;

	interval = cur_time - g_last_mor_send_time;
    

	if ( interval > send_time || g_last_mor_send_time == 0)
	{
		/* send mornitor data : send FMS Server */
		//st = get_sectick();

		send_dido_data( 0, EFT_SNSRDAT_RES, SEND_FMS );
		send_ai_data( 0, EFT_SNSRDAT_RES, SEND_FMS );

		//ed = get_sectick();
		//print_dbg(DBG_NONE, 1, "..............st:%d, ed:%d, int:%d...............\r\n", st,ed, ed-st);
		//print_dbg(DBG_NONE, 1, "..............sensor send curtime:%d..inteval(%d)...............\r\n", cur_time , interval);

		g_last_mor_send_time = cur_time;
	}

	return ERR_SUCCESS;
}

/* 등록한 실시간 요청 OP에게  실시간데이터를 보낸다 */
static int check_cur_data( UINT32 cur_time )
{
	int i;
	UINT32 inter_time;
	int l_id;
	static volatile UINT32 last_websend_time = 0;
	
	for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
	{
		l_id = g_cur_req[ i ].clientid;

		if ( (l_id > 0 ) )
		{
			inter_time = cur_time - g_cur_req[ i ].last_send_time;

			if ( inter_time >=  REAL_CUR_TIME_SEC )
			{
				//print_dbg(DBG_INFO, 1, "###################################### send cur_time : i:%d, cur_time:%u..clientid:%d..\r\n", i, cur_time, l_id );
				send_dido_data( l_id, EFT_SNSRCUDAT_RES, SEND_OP );
				send_ai_data( l_id,   EFT_SNSRCUDAT_RES, SEND_OP );
				g_cur_req[ i ].last_send_time = cur_time;
			}
		}
	}

	/* WebSocket Server 전송용 */
	inter_time = cur_time - last_websend_time;
	if ( inter_time >= REAL_CUR_TIME_SEC )
	{
		send_dido_data( 0, EFT_SNSRCUDAT_RES, SEND_WEB );
		send_ai_data( 0,   EFT_SNSRCUDAT_RES, SEND_WEB );
		last_websend_time = cur_time;
	}

	return ERR_SUCCESS;
}

static int check_mor_radio_data( UINT32 cur_time )
{
	UINT32 interval = 0;

	static volatile int radio_flag = 0;
	int send_time =0;
    static volatile int first_req = 0;
    static volatile UINT32 first_req_time = 0;

	send_time = get_send_cycle_shm();
	//send_time = 10;
	interval = cur_time - g_last_mor_radio_send_time;
	
	if ( (interval > ( send_time - 290 )) || first_req == 0 )
	{
		if ( radio_flag == 0 )
		{
			if ( get_proc_used( PROC_RADIO )== 1 )
			{
				idle_radio( NULL);
			}

			radio_flag = 1;
            first_req = 1;
            first_req_time = cur_time;

		}
	}
	if ( ( interval > send_time ) ||
         ( first_req == 1 && ( cur_time - first_req_time > 10 ) ))
	{
		/* send mornitor data : send FMS Server */
            send_fre_data( 0, EFT_EQPDAT_RES, SEND_FMS );
            send_frs_data( 0, EFT_EQPDAT_RES, SEND_FMS );
            send_sre_data( 0, EFT_EQPDAT_RES, SEND_FMS );
            send_fde_data( 0, EFT_EQPDAT_RES, SEND_FMS );

            //print_dbg(DBG_NONE,1, "..............radio send curtime:%d.inteval(%d)................\r\n", cur_time, interval );
            /* DB 등록 */
            g_last_mor_radio_send_time = cur_time;
            radio_flag = 0;
            first_req = 2;
	}

	return ERR_SUCCESS;
}

static int com_cur_radio_data( cur_req_t * ptrreq, UINT32 cur_time , int fclt_code )
{
	int i;
	UINT32 inter_time;
	int l_id;
	cur_req_t * req = NULL;

	for( i = 0 ; i < MAX_CLIENT_CNT ; i++ )
	{
		req = ( cur_req_t *)&ptrreq[ i ];

		if ( req != NULL )
		{
			l_id = req->clientid;

			if ( (l_id > 0 ) )
			{
				inter_time = cur_time - req->last_send_time;

				if ( inter_time >=  REAL_CUR_TIME_SEC )
				{
                        if ( fclt_code == g_fre_fclt_code )
                        {
                            send_fre_data( l_id, EFT_EQPCUDAT_RES , SEND_OP );
                            /* DB 등록 */
                        }
                        else if ( fclt_code == g_frs_fclt_code )
                        {
                            send_frs_data( l_id, EFT_EQPCUDAT_RES , SEND_OP );
                            /* DB 등록 */
                        }
                        else if ( fclt_code == g_sre_fclt_code )
                        {
                            send_sre_data( l_id, EFT_EQPCUDAT_RES , SEND_OP );
                            /* DB 등록 */
                        }
                        else if ( fclt_code == g_fde_fclt_code )
                        {
                            send_fde_data( l_id, EFT_EQPCUDAT_RES , SEND_OP );
                            /* DB 등록 */
                        }
                        req->last_send_time = cur_time;
                        print_dbg(DBG_INFO, 1, "###################################### eqp cur_time : fclt_code:%d, i:%d, cur_time:%u..clientid:%d..\r\n", fclt_code, i, cur_time, l_id );

				}
			}
		}
	}

	return ERR_SUCCESS;
}

static int check_cur_radio_data( UINT32 cur_time )
{
	com_cur_radio_data( g_cur_fre_req , cur_time, g_fre_fclt_code );
	com_cur_radio_data( g_cur_frs_req , cur_time, g_frs_fclt_code );
	com_cur_radio_data( g_cur_sre_req , cur_time, g_sre_fclt_code );
	com_cur_radio_data( g_cur_fde_req , cur_time, g_fde_fclt_code );
	
	return ERR_SUCCESS;
}


static int check_eqp_auto_release( void )
{
    UINT32 cur_tick = 0;
    UINT32 int_val;
	inter_msg_t inter_msg;
	allim_msg_t allim_msg;
	int cmd = EFT_ALLIM_MSG;

    cur_tick = get_sectick();


    if ( g_eqp_auto.run == 0 )
    {
        return ERR_SUCCESS;
    }
    else
    {
        int_val = cur_tick - g_eqp_auto.run_time;
        if ( int_val >= MAX_RELEASE_TIME )
        {
            if ( g_eqp_auto.run == 1 )
            {
                memset( &g_eqp_auto, 0, sizeof( g_eqp_auto ));

                /* send allim msg */
                memset( &inter_msg, 0, sizeof( inter_msg ));
                memset( &allim_msg, 0, sizeof( allim_msg ));

                /* allim msg */
                allim_msg.allim_msg = ALM_FORCE_PWR_END_MSG;

                /* intr msg */
                inter_msg.client_id	= 0;
                inter_msg.msg 		= cmd;
                inter_msg.ptrbudy 	= &allim_msg;

                send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );
                send_data_transfer( cmd, (void *)&inter_msg , SEND_OP  );

                /* 전원 제어 메니저 상태를 초기화한다 , err_code, err_step, max_step */
                recv_pwr_ctrl_release_pwr_mng( EEQPONOFFRSLT_PROCTIMEOUTOVER , 2, 2 );
                print_dbg( DBG_SAVE, 1, "Force Release of EQP ONOFF Control"); 
            }
        }
    }
    
    return ERR_SUCCESS;
}


static int set_app_version( void )
{
	int total_len;
	char szker[ 100 ];
	BYTE szapp_ver[ 2 ];
	BYTE szobs_ver[ 2 ] ;

	memset( szker, 0, sizeof( szker ));
	memset( szapp_ver , 0, sizeof( szapp_ver ));
	memset( szobs_ver , 0, sizeof( szobs_ver ));

	/* app version */
	memcpy( szker, APP_VER, strlen( APP_VER ));
	total_len = strlen( szker );
	if ( total_len > 2 )
	{    
		get_stringtover( szker, szapp_ver );
	}    
	else 
	{    
		szapp_ver[ 0 ] = 0x00;
		szapp_ver[ 1 ] = 0x00;
	}

	/* Observer version */
	memset( szker, 0, sizeof( szker ));
	memcpy( szker, OBSERVER_VER, strlen( OBSERVER_VER ));

	total_len = strlen( szker );
	if ( total_len > 2 )
	{    
		get_stringtover( szker, szobs_ver );
	}    
	else 
	{    
		szobs_ver[ 0 ] = 0x00;
		szobs_ver[ 1 ] = 0x00;
	}    


	g_version.app_ver[ 0 ] = szapp_ver[ 0 ];
	g_version.app_ver[ 1 ] = szapp_ver[ 1 ];

	g_version.ob_ver[ 0 ] = szobs_ver[ 0 ];
	g_version.ob_ver[ 1 ] = szobs_ver[ 1 ];

	return ERR_SUCCESS;
}

static int check_req_time_data( UINT32 cur_time )
{
	UINT32 interval = 0;
	int req_time;

	interval = cur_time - g_last_req_time_send_time;
	req_time = get_time_cycle_shm();

	/* DB 처리 */
	//req_time = 6000;
	if ( interval  > req_time )
	{
		if ( send_req_time( ) == ERR_SUCCESS )
		{
			g_last_req_time_send_time = cur_time;
		}
	}

	return ERR_SUCCESS;

}

static int check_version( void )
{
	int ret = 1;
	static volatile time_t pre_time =0;
    static volatile int c_flag = 0;

	UINT32 cur_time =0;

	cur_time = get_sectick(); 
	
	if( pre_time == 0 ) 
		pre_time = cur_time;

	/* about 5sec */
	if( cur_time - pre_time > 15  && g_checked_ver == 0 )
	{
#if  0
			print_dbg(DBG_NONE, 1, "RTU Observer Version:%d.%d"			, g_version.ob_ver[ 0 ], 	g_version.ob_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU Logger Version:%d.%d"			, g_version.app_ver[ 0 ], 	g_version.app_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU MCU Version:%d.%d"				, g_version.mcu_ver[ 0 ], 	g_version.mcu_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU MCU Version:%d.%d"				, g_version.mcu_ver[ 0 ], 	g_version.mcu_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU Remote Control Version:%d.%d"	, g_version.remote_ver[ 0 ],g_version.remote_ver[ 1 ]);
			print_dbg(DBG_NONE, 1, "RTU Temprature Version:%d.%d"		, g_version.temp_ver[ 0 ], 	g_version.temp_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU Power Control Version:%d.%d"	, g_version.pwr_c_ver[ 0 ], g_version.pwr_c_ver[ 1 ]  );
			print_dbg(DBG_LINE, 1, NULL );
#endif
			set_app_version();
			set_rtu_version_shm( &g_version );

			g_checked_ver = 1;
	}
	else
	{
		if( g_checked_ver == 0 )
		{
			print_dbg(DBG_NONE, 1, "RTU Initializing...."  );
			print_dbg(DBG_LINE, 1, NULL );
            
            if ( c_flag == 1 )
            {
                //idle_pwr_c( NULL );
                //idle_remote( NULL );
                //idle_temp( NULL );
                //idle_radio_etc();
                c_flag = 0;
            }
            else
            {
                c_flag = 1;
            }

		}
	}

	return ret;
}

/* 전원 제어 메니저에서 요청한 전원을 제어한다 */
static int internal_set_eqp_pwr_value_ctrl( void * ptrset )
{
	set_port_t * ptrport = NULL;
	BYTE comport;
	BYTE req_val;
	BYTE pos ;
	mcu_data_t mcu_data;
	pwr_c_data_t pwr_data;

	int i;
	int ret = ERR_SUCCESS;

	if( ptrset == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrset is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	memset( &mcu_data, 0, sizeof( mcu_data ));
	memset( &pwr_data, 0, sizeof( pwr_data ));

	ptrport = ( set_port_t *)ptrset;
	
	comport = ptrport->comport;
	req_val = ptrport->req_val;
	pos		= ptrport->pos;

	/* MCU */
	if( comport == COM1 )
	{
		for( i = 0 ; i < MAX_GPIO_CNT ;i++ )
		{
			mcu_data.do_[ i ] = g_do_val[ i ].last_val;
			mcu_data.doe[ i ] = g_doe_val[ i ].last_val;
		}

		mcu_data.doe[ pos ] = req_val;
		ret= send_data_mcu( EFT_SNSRCTL_POWER,  &mcu_data );
	}

	/* 전원제어기 */
	else if ( comport == COM5 )
	{
		for( i = 0 ; i < MAX_PWR_C_PORT_CNT  ;i++ )
		{
			pwr_data.val[ i ] = g_pwr_c_data.val[ i ];
		}

		pwr_data.val[ pos ] = req_val;
		ret= send_data_pwr_c( EFT_SNSRCTL_POWER,  &pwr_data);
    }

    return ret;
}

static int print_cli_di( void )
{
    int i;
    char * ptr = NULL;
    static volatile int cnt = 0;

    if ( g_di_test == 0 )
        return 0;

    if ( cnt++ < 2 )
        return 0;

    cnt = 0;
    print_dbg( DBG_LINE, 1, NULL);
    print_dbg( DBG_NONE, 1, "Information Of DO");

    for( i = 0 ; i < MAX_GPIO_CNT ;i++ )
    {
        if ( g_do_val[ i ].snsr_sub_type == ESNSRSUB_DO_AIRCON)
        {
            ptr = "Aircondition Sensor";
        }
        else
            ptr = "ETC Sensor";

        if ( ptr != NULL )
        {
            print_dbg( DBG_NONE, 1, "DO [ %d ]%-20s Val[ %d ]",i+1, ptr, g_do_val[ i ].last_val);
        }
    }

    /* aircon */
    print_dbg( DBG_NONE, 1, "DO %-25s Val[ %d ]","Aircondition", g_remote_val.last_val);
    print_dbg( DBG_LINE, 1, NULL);

    print_dbg( DBG_NONE, 1, "Information Of DOE");

    for( i = 0 ; i < MAX_GPIO_CNT ;i++ )
    {
        if ( g_doe_val[ i ].snsr_sub_type == ESNSRSUB_DO_LIGHT)
        {
            ptr = "Light Sensor";
        }
        else
        {
            if ( i == 1 )
                ptr = "SRE Power 1";
            else if ( i == 2 )
                ptr = "SRE Power 2";
            else
                ptr = "ETC Sensor";
        }

        if ( ptr != NULL )
        {
            print_dbg( DBG_NONE, 1, "DOE [ %d ]%-20s Val[ %d ]", i+1, ptr, g_doe_val[ i ].last_val);
        }
    }

    print_dbg( DBG_LINE, 1, NULL);
    print_dbg( DBG_NONE, 1, "Information Of Power Controler");
    for( i = 0 ; i < MAX_PWR_C_PORT_CNT  ;i++ )
    {
        if ( i < 3 )
            ptr = "FRE";
        else
            ptr = "FDE";

        print_dbg( DBG_NONE, 1, "Power [ %d ] %-17s Val[ %d ]", i +1, ptr, g_pwr_c_data.val[ i ] );
    }

    print_dbg( DBG_LINE, 1, NULL);
    print_dbg( DBG_NONE, 1, "Information Of DI");
    for( i = 0 ; i < MAX_GPIO_CNT ;i++ )
    {
        if ( g_di_val[ i ].snsr_sub_type == ESNSRSUB_DI_HEAT )
        {
            ptr = "Heat Sensor";
        }
        else if ( g_di_val[ i ].snsr_sub_type == ESNSRSUB_DI_SMOKE )
        {
            ptr = "Smoke Sensor";
        }
        else if ( g_di_val[ i ].snsr_sub_type == ESNSRSUB_DI_WATER )
        {
            ptr = "Water Sensor";
        }
        else if ( g_di_val[ i ].snsr_sub_type == ESNSRSUB_DI_DOOR )
        {
            ptr = "Door Sensor";
        }
        else
            ptr = "ETC Sensor";

        if ( ptr != NULL )
        {
            print_dbg( DBG_NONE, 1, "DI [ %d ]%-20s Val[ %d ]", i+1, ptr, g_di_val[ i ].last_val);
        }
    }
    //%-5s  
    print_dbg( DBG_NONE, 1, "DI %-25s Val[ %d ]", "Recode Video", g_video_val.last_val);
    print_dbg( DBG_NONE, 1, "DI %-25s Val[ %d ]", "Power Ground", g_ground_val.last_val);

    print_dbg( DBG_LINE, 1, NULL);
    print_dbg( DBG_NONE, 1, "Information Of AI");
    for( i = 0 ; i < MAX_TEMP_CNT ;i++ )
    {
        if ( g_temp_val[i].snsr_sub_type == 0 )
            break;

        if ( g_temp_val[i].snsr_sub_type == ESNSRSUB_AI_TEMPERATURE )
        {
            ptr ="Temprature";
        }
        else if( g_temp_val[i].snsr_sub_type == ESNSRSUB_AI_HUMIDITY) 
        {
            ptr ="Humidity";
        }
        else
            ptr = "ETC Sensor";

        if ( ptr != NULL )
        {
            print_dbg( DBG_NONE, 1, "AI_1 [ %d ]%-17s Val[ %-8.2f ]",i+1, ptr, g_temp_val[ i ].last_val);
        }
    }

    for( i = 0 ; i <MAX_PWR_M_CNT ;i++ )
    {
        if ( g_pwr_m_val[i].snsr_sub_type == 0 )
            break;

        if ( g_pwr_m_val[i].snsr_sub_type == ESNSRSUB_AI_POWERVR ||
			g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVS ||
	        g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVT ||
    	    g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERFREQ )
		{
			ptr ="Power R";
        }
        else
            ptr = "ETC Sensor";

        if ( ptr != NULL )
        {
            print_dbg( DBG_NONE, 1, "AI_2 [ %d ]%-17s Data Pos:%02d, Val[ %-8.2f ]",i+1, ptr, g_pwr_m_val[ i ].data_pos, g_pwr_m_val[ i ].last_val );
        }
    }

    print_dbg( DBG_LINE, 1, NULL);
    print_dbg( DBG_NONE, 1, "Information Of FRE");
    int l_sub = 0;

    for( i = 0 ; i < MAX_RADIO_SNS_CNT ; i++ )
    {
        l_sub = g_fre_mng.radio_val[ i ].snsr_sub_type;

        if ( l_sub != 0  )
        {
            print_dbg( DBG_NONE, 1, "FRE RX DATA[ %-14s %d, Val: %d ]","SUB: ",g_fre_mng.radio_val[ i ].snsr_sub_type,
                    g_fre_mng.radio_val[ i ].last_val );
        }
    }

    print_dbg( DBG_LINE, 1, NULL);
    print_dbg( DBG_NONE, 1, "Information Of FRS");
    for( i = 0 ; i < MAX_RADIO_SNS_CNT ; i++ )
    {
        l_sub = g_frs_mng.radio_val[ i ].snsr_sub_type;

        if ( l_sub != 0  )
        {
            print_dbg( DBG_NONE, 1, "FRS RX DATA[ %-14s %d, Val: %d ]","SUB: ",g_frs_mng.radio_val[ i ].snsr_sub_type,
                    g_frs_mng.radio_val[ i ].last_val );
        }
    }

    print_dbg( DBG_LINE, 1, NULL);
    print_dbg( DBG_NONE, 1, "Information Of SRE");
    for( i = 0 ; i < MAX_RADIO_SNS_CNT ; i++ )
    {
        l_sub = g_sre_mng.radio_val[ i ].snsr_sub_type;

        if ( l_sub != 0  )
        {
            print_dbg( DBG_NONE, 1, "SRE RX DATA[ %-14s %d, Val: %d ]","SUB: ",g_sre_mng.radio_val[ i ].snsr_sub_type,
                    g_sre_mng.radio_val[ i ].last_val );
        }
    }

    print_dbg( DBG_LINE, 1, NULL);
    print_dbg( DBG_NONE, 1, "Information Of FDE");
    for( i = 0 ; i < MAX_RADIO_SNS_CNT ; i++ )
    {
        l_sub = g_fde_mng.radio_val[ i ].snsr_sub_type;

        if ( l_sub != 0  )
        {
            print_dbg( DBG_NONE, 1, "FDE RX DATA[ %-14s %d, Val: %d ]","SUB: ", g_fde_mng.radio_val[ i ].snsr_sub_type,
                    g_fde_mng.radio_val[ i ].last_val );
        }
    }

    print_dbg( DBG_LINE, 1, NULL);
    return ERR_SUCCESS;
}

static int cli_test( char * ptrdata , int size )
{
	int i,type = 0;
	mcu_data_t mcu_data;
	remote_data_t remote_data;
	pwr_c_data_t pwr_data;
	
	type = ptrdata[ 0 ];
	
	memset( &mcu_data, 0, sizeof( mcu_data ));
	memset( &remote_data, 0, sizeof( remote_data ));
	memset( &pwr_data, 0, sizeof( pwr_data ));

	if ( type == DO_TYPE )
	{
		print_dbg( DBG_INFO, 1,"Recv DO from CLI");
		
        for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
        {
            mcu_data.do_[ i ] = g_do_val[ i ].last_val;    
            mcu_data.doe[ i ] = g_doe_val[ i ].last_val;    
        }
		for( i = 0 ; i < MAX_GPIO_CNT ;i++ )
		{
			mcu_data.do_[ i ] = ptrdata[ i+1 ];
			//printf("do[%d], val[%d]..\r\n", i,mcu_data.do_[ i ]);
		}
		send_data_mcu( EFT_SNSRCTL_POWER,  &mcu_data );
	}
	else if ( type == LIGHT_TYPE )
	{
		print_dbg( DBG_INFO, 1,"Recv LIGHT from CLI");
        for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
        {
            mcu_data.do_[ i ] = g_do_val[ i ].last_val;    
            mcu_data.doe[ i ] = g_doe_val[ i ].last_val;    
        }
		mcu_data.doe[ 0 ] = ptrdata[ 1 ];
		printf("Light[%d]..\r\n", mcu_data.doe[ 0 ]);

		send_data_mcu( EFT_SNSRCTL_POWER,  &mcu_data );
	}
	else if ( type == DOE_TYPE )
	{
		print_dbg( DBG_INFO, 1,"Recv Inside Power from CLI");
        for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
        {
            mcu_data.do_[ i ] = g_do_val[ i ].last_val;    
            mcu_data.doe[ i ] = g_doe_val[ i ].last_val;    
        }
		for( i = 0 ; i < 2 ; i++ )
		{
			mcu_data.doe[ i+1 ] = ptrdata[ i+1 ];
			printf("Inside Power[%d:%d]..\r\n", i+1,mcu_data.doe[ i+1 ]);
		}

		send_data_mcu( EFT_SNSRCTL_POWER,  &mcu_data );
	}
	else if ( type == PWR_TYPE )
	{
		print_dbg( DBG_INFO, 1,"Recv Outside Power from CLI");
		for( i = 0 ; i < MAX_PWR_M_CNT ;i++ )
		{
			pwr_data.val[ i ] = ptrdata[ i+1 ];
			printf("Outside Power[%d], val[%d]..\r\n", i+1,pwr_data.val[ i ]);
		}
		send_data_pwr_c( EFT_SNSRCTL_POWER,  &pwr_data );
	}
	else if ( type == AIR_TYPE )
	{
		print_dbg( DBG_INFO, 1,"Recv Aircondition Power from CLI");
		remote_data.remote_val = ptrdata[ 1 ]; 
		printf("Remote Power[%d]..\r\n", remote_data.remote_val );

		send_data_remote( EFT_SNSRCTL_POWER,  &remote_data);
	}
	else if ( type == DI_TYPE )
	{
		/* S */
		print_dbg( DBG_INFO, 1,"Recv DI Data from CLI");
		if ( ptrdata[ 1 ] == 0x53 )
		{
			g_di_test = 1;
			set_print_debug_shm( 1 );
		}
		else
		{
			g_di_test = 0;
			g_rtu_test = 0;
			set_print_debug_shm( 0 );
		}
    }
	else if ( type == VER_TYPE )
	{
		/* S */
		if ( ptrdata[ 1 ] == 0x53 )
		{
		    print_dbg( DBG_INFO, 1,"Recv Version & Protocol from CLI");
			print_dbg(DBG_NONE, 1, "RTU [ %-20s:%d.%d ]"	, "Logger Ver",  g_version.app_ver[ 0 ], 	g_version.app_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU [ %-20s:%d.%d ]"	, "Observer Ver",  g_version.ob_ver[ 0 ], 	g_version.ob_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU [ %-20s:%d.%d ]"	, "MCU Ver",  g_version.mcu_ver[ 0 ], 	g_version.mcu_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU [ %-20s:%d.%d ]"	, "Aircondition Ver",  g_version.remote_ver[ 0 ],g_version.remote_ver[ 1 ]);
			print_dbg(DBG_NONE, 1, "RTU [ %-20s:%d.%d ]"	, "Temprature Ver",  g_version.temp_ver[ 0 ], 	g_version.temp_ver[ 1 ] );
			print_dbg(DBG_NONE, 1, "RTU [ %-20s:%d.%d ]"	, "Power Ver",  g_version.pwr_c_ver[ 0 ], g_version.pwr_c_ver[ 1 ]  );
			print_dbg(DBG_LINE, 1, NULL );

            char * ptrfmsip = NULL;
            UINT16 fmsport = 0;
            UINT16 opport  = 0;

		    print_dbg( DBG_INFO, 1,"FMS Server Network Information");

            ptrfmsip = get_fms_server_ip_shm();
            fmsport  = get_fms_server_port_shm();
            opport  = get_op_listen_port_shm();

            if ( ptrfmsip != NULL )
		        print_dbg( DBG_NONE, 1,"FMS Server IP : %s, Port : %d", ptrfmsip, fmsport );

		    print_dbg( DBG_NONE, 1,"OP Listen Port : %d", opport );

		    print_dbg( DBG_INFO, 1,"EQP Network Information");
            for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
            {
                if ( g_fclt_info[ i ].fcltid == 0 )
                    break;

                print_dbg( DBG_NONE, 1, "FCLT ID : %d, FCLT Code : %d, IP : %s, Port :%d",
                        g_fclt_info[ i ].fcltid, g_fclt_info[ i ].fcltcode, g_fclt_info[ i ].szip, g_fclt_info[ i ].port );
            }


		}
	}
    else if ( type == REBOOT_TYPE )
    {
        g_reboot = 1; 
		print_dbg( DBG_INFO, 1,"FMS Logger Restart becase of Recv CLI");
        sys_sleep( 3000 );
		killall( APP_PNAME, 9);

    }
    else if ( type == RESERVED_TYPE )
    {
		print_dbg( DBG_INFO, 1,"Recv Reserved Command from CLI");
		print_dbg(DBG_INFO, 1,"First Data:0x%x, Second Data:0x%x",ptrdata[ 1 ] , ptrdata[ 2 ] );

    }


	return ERR_SUCCESS;
}

#if 0
static int test_mcu( void )
{
	mcu_data_t mcu_data;
	static volatile int mcu_test = -1;
	int i;
	static volatile int mcu_cnt = 0;

	if ( mcu_cnt ++ < 3 )
	{
		return 0;
	}
	else
	{
		mcu_cnt = 0;
	}

	memset(&mcu_data, 0, sizeof( mcu_data ));

#if 1
	if( mcu_test < 0 )
	{
		memset(&mcu_data, 0, sizeof( mcu_data ));
		mcu_test ++;
	}
	else if ( mcu_test <= 7 )
	{
		memset(&mcu_data, 0, sizeof( mcu_data ));
		mcu_data.do_[ mcu_test ] = 1;
		mcu_data.doe[ mcu_test ] = 1;
		mcu_test ++;
	}
	else if ( mcu_test == 8 )
	{
		for( i = 0 ; i< MAX_GPIO_CNT; i++ )
		{	
			mcu_data.do_[i] = 1;
			mcu_data.doe[i] = 1;
		}
		mcu_test ++;
	}
	else 
	{
		mcu_test = -1;

	}
#else
	if( mcu_test ==  0 )
	{
		for( i = 0 ; i< MAX_GPIO_CNT; i++ )
		{	
			mcu_data.do_[i] = 0;
			mcu_data.doe[i] = 0;
		}
		mcu_test =1;
	}
	else
	{
		for( i = 0 ; i< MAX_GPIO_CNT; i++ )
		{	
			mcu_data.do_[i] = 1;
			mcu_data.doe[i] = 1;
		}
		mcu_test =0;
	}

#endif
#if 0
	for( i = 0 ; i< MAX_GPIO_CNT; i++ )
	{
		print_dbg( DBG_INFO, 1, "DO_VAL:%d", mcu_data.do_[ i ]) ;
		print_dbg( DBG_INFO, 1, "DOE_VAL:%d", mcu_data.doe[ i ]) ;
	}
#endif
	set_last_sns_onoff_sts( 0,  0,  SNS_ONOFF_MCU );
	send_data_mcu( EFT_SNSRCTL_POWER,  &mcu_data );
	return ERR_SUCCESS;
}

static int test_remote( void )
{
	remote_data_t remote_data;
	static volatile int remote_cnt = 0;
	static int val = 0;

	if ( remote_cnt ++ < 3 )
	{
		return 0;
	}
	else
	{
		remote_cnt = 0;
	}

	memset(&remote_data, 0, sizeof( remote_data ));
	
	if ( val == 0 )
		val =1;
	else
		val = 0;

	remote_data.remote_val = val; 

	//print_dbg( DBG_NONE, 1, ".................VAL....:%x" , val );

	set_last_sns_onoff_sts( 1,  1,  SNS_ONOFF_REMOTE );
	send_data_remote( EFT_SNSRCTL_POWER,  &remote_data );
	return ERR_SUCCESS;
}

static int test_pwr_c( void )
{
	pwr_c_data_t pwr_data;
	static volatile int pwr_test = -1;
	int i;
	static volatile int pwr_cnt = 0;

	if ( pwr_cnt ++ < 3 )
	{
		return 0;
	}
	else
	{
		pwr_cnt = 0;
	}

	memset(&pwr_data, 0, sizeof( pwr_data ));

#if 1
	if( pwr_test < 0 )
	{
		memset(&pwr_data, 0, sizeof( pwr_data ));
		pwr_test ++;
	}
	else if ( pwr_test <= 5 )
	{
		memset(&pwr_data, 0, sizeof( pwr_data ));
		pwr_data.val[ pwr_test ] = 1;
		pwr_test ++;
	}
	else if ( pwr_test == 6 )
	{
		for( i = 0 ; i< MAX_GPIO_CNT; i++ )
		{	
			pwr_data.val[i] = 1;
		}
		pwr_test ++;
	}
	else 
	{
		pwr_test = -1;

	}
#else
	if( pwr_test ==  0 )
	{
		for( i = 0 ; i< MAX_PWR_C_PORT_CNT; i++ )
		{	
			pwr_data.val[i] = 0;
		}
		pwr_test =1;
	}
	else
	{
		for( i = 0 ; i< MAX_PWR_C_PORT_CNT; i++ )
		{	
			pwr_data.val[i] = 1;
		}
		pwr_test =0;
	}

#endif
	set_last_sns_onoff_sts( 0,  0,  SNS_ONOFF_MCU );
	send_data_pwr_c( EFT_SNSRCTL_POWER,  &pwr_data );
	return ERR_SUCCESS;
}
#endif

static void *  ctrl_pthread_idle( void * ptrdata )
{
	( void ) ptrdata;
	int status;
	UINT32 cur_time ;
	g_end_ctrl_pthread = 0;
    static volatile int flag = 0;

	while( g_release == 0 && g_start_ctrl_pthread == 1 )
	{
		if ( get_rtu_initialize_shm() == 1 && g_checked_ver == 1 )
		{
			cur_time = get_sectick();
			
			check_req_time_data( cur_time );
#if 0
			int recv_time;
			recv_time = 1475384966;
			set_rtc_time( recv_time, 0, 0 );
			print_dbg( DBG_INFO,1, "######## Recv Time Data:%u ", recv_time );
#endif
            /* 2초 단위로 별도 체크 */
            /* idle_mcu( NULL ); */
            //idle_pwr_m( NULL ); 
			
			if ( get_proc_used( PROC_PWR_C )== 1 )
			{
				idle_pwr_c( NULL );
			}

			if ( get_proc_used( PROC_REMOTE )== 1 )
			{
            	idle_remote( NULL );
			}
			if ( get_proc_used( PROC_TEMP )== 1 )
			{
            	idle_temp( NULL );
			}
			if ( get_proc_used( PROC_RADIO )== 1 )
			{	
            	idle_radio_etc();
			}

            sys_sleep( 6000 );
            g_chk_sns = 1;

            /* 시실간 또는 모니터링 데이터를 전송한다 */
            if ( flag >= 2 )
            {
                check_cur_data( cur_time );
                check_mor_data( cur_time );
                //test_mcu( );
                //test_remote();
                //test_pwr_c( );
            }
			if ( flag < 5 )
			{
            	flag++ ;
			}

            check_eqp_auto_release();
		}
		else
		{
			check_version();
			sys_sleep( 1000 );
		}
		print_cli_di( );
	}

	if( g_end_ctrl_pthread == 0 )
	{
		pthread_join( ctrl_pthread , ( void **)&status );
		g_start_ctrl_pthread 	= 0;
		g_end_ctrl_pthread 	= 1;
	}

	return ERR_SUCCESS;
}

static void *  radio_pthread_idle( void * ptrdata )
{
	( void ) ptrdata;
	int status;

	g_end_radio_pthread = 0;
	volatile UINT32 cur_time;

	while( g_release == 0 && g_start_radio_pthread == 1 )
	{
		if ( get_rtu_initialize_shm() == 1 && g_checked_ver == 1 )
		{
			if( g_chk_sns == 1 && g_chk_sns2 == 1 )
			{
				cur_time = get_sectick();;
				check_mor_radio_data( cur_time );
				check_cur_radio_data( cur_time );

				sys_sleep( 2000 );
			}
		}
	}

	if( g_end_radio_pthread == 0 )
	{
		pthread_join( radio_pthread , ( void **)&status );
		g_start_radio_pthread 	= 0;
		g_end_radio_pthread 	= 1;
	}

	return ERR_SUCCESS;
}

static int create_ctrl_thread( void )
{
	int ret = ERR_SUCCESS;

	if ( g_release == 0 && g_start_ctrl_pthread == 0 && g_end_ctrl_pthread == 1 )
	{
		g_start_ctrl_pthread = 1;

		if ( pthread_create( &ctrl_pthread, NULL, ctrl_pthread_idle , NULL ) < 0 )
		{
			g_start_ctrl_pthread = 0;
			print_dbg( DBG_ERR, 1, "Fail to Create Control Thread" );
			ret = ERR_RETURN;
		}
		else
		{
			//print_dbg( DBG_INIT, 1, "mini-SEED Thread Create OK. ");
		}
	}

	return ret;
}

/* 전파 감시 장치용 idle를 별도로 처리한다 . */
static int create_radio_thread( void )
{
	int ret = ERR_SUCCESS;

	if ( g_release == 0 && g_start_radio_pthread == 0 && g_end_radio_pthread == 1 )
	{
		g_start_radio_pthread = 1;

		if ( pthread_create( &radio_pthread, NULL, radio_pthread_idle , NULL ) < 0 )
		{
			g_start_radio_pthread = 0;
			print_dbg( DBG_ERR, 1, "Fail to Create Radio Thread" );
			ret = ERR_RETURN;
		}
		else
		{
			//print_dbg( DBG_INIT, 1, "mini-SEED Thread Create OK. ");
		}
	}

	return ret;
}

static int load_db( void )
{
	int ret = ERR_SUCCESS;

	set_proc_used( PROC_TEMP, 0 );
	set_proc_used( PROC_PWR_C, 0 );
	set_proc_used( PROC_REMOTE, 0 );
	set_proc_used( PROC_PWR_M, 0 );
	set_proc_used( PROC_RADIO, 0 );
	set_proc_used( PROC_APC_UPS, 0 );

	ret = load_rtu_info();

	if ( ret == ERR_SUCCESS )
		ret = load_eqp_fclt_info();

	if ( ret == ERR_SUCCESS )
		ret = load_rtu_fclt_info();

	if ( ret == ERR_SUCCESS )
		ret = load_sns_col_val();

	if ( ret == ERR_SUCCESS )
		ret = load_di_val();

	if ( ret == ERR_SUCCESS )
		ret = load_do_val();

	if ( ret == ERR_SUCCESS )
		ret = load_ai_val();

	if ( ret == ERR_SUCCESS )
		ret = load_pwr_dev_val();
	
	if ( ret == ERR_SUCCESS )
		ret = load_di_ups_val();

	if ( ret == ERR_SUCCESS )
		ret = load_ai_ups_val();

	print_proc_used();

	return ret ;
}

static int internal_init( void )
{
	int ret = ERR_SUCCESS;
	int i;
	
	memset( &g_proc_mng , 0, sizeof( g_proc_mng ));
	memset( &g_version, 0, sizeof( g_version ));
	memset( &g_cur_req, 0 , sizeof( g_cur_req ));
	memset( &g_sns_onoff_sts, 0, sizeof( g_sns_onoff_sts ));
	memset( &g_cur_net_mng, 0, sizeof( g_cur_net_mng ));
    memset( &g_eqp_auto, 0, sizeof( g_eqp_auto ));

	/* com_sns.c에 등록 */
	set_get_proc_used_func( get_proc_used );

	/* 네트워크 메니져 등록 */
	for( i = 0 ; i < MAX_CUR_NET_CNT ;i++ )
	{
		g_cur_net_mng.nets[ i ].type = i+1;
	}

	g_cur_net_mng.cnt = NET_MAX_CNT;


	if( load_db( ) != ERR_SUCCESS )
	{
		print_dbg( DBG_ERR,1, "Cannot load Local DB [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	/* warring을 없애기 위한 함수 호출 */

	send_update_transfer( 0, NULL );

	g_trans_func_cnt = ( sizeof( trans_proc_list ) / sizeof( proc_func_t ));
	g_update_func_cnt = ( sizeof( update_proc_list ) / sizeof( proc_func_t ));
	g_sns_func_cnt = ( sizeof( sns_proc_list ) / sizeof( proc_func_t ));
	
	ret = create_ctrl_thread();
	
	if ( ret == ERR_SUCCESS )
	{
		ret = create_radio_thread();
	}
	else
	{
		print_dbg( DBG_ERR,1, "Cannot Create Control Thread [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	/* debug */
	create_debug_thread();
	create_debug_sock();
	set_debug_send_func_util( send_debug_data );

	if( ret == ERR_SUCCESS )
	{
		g_ctrl_sem_id = create_sem( g_ctrl_sem_key );
		print_dbg( DBG_INFO, 1, " Control SEMA : %d", g_ctrl_sem_id );
		print_dbg(DBG_INFO, 1, "Success of Control Initialize");
	}

	return ERR_SUCCESS;
}

static int internal_idle( void * ptr )
{
	( void )ptr;
	static volatile int cnt = 0;
	static volatile int m_cnt = 0;
	static volatile int first = 0;

	if ( get_rtu_initialize_shm() == 1 && g_checked_ver == 1 ) 	
	{
		if ( first == 0 || cnt++ >=2 )
		{
			idle_mcu( NULL );
			cnt = 0;
		}

		if ( first == 0 || m_cnt++ >=3 )
		{
			if ( get_proc_used( PROC_PWR_M )== 1 )
			{
				idle_pwr_m( NULL );
			}
			m_cnt = 0;
		}
	
		if ( get_proc_used( PROC_APC_UPS )== 1 )
		{
			idle_apc_ups( NULL );
		}

		first = 1;
		g_chk_sns2 = 1;
	}

	return ERR_SUCCESS;
}

static int internal_release( void )
{
	g_release = 1;
	print_dbg(DBG_INFO, 1, "Release of Control");

	if ( g_ctrl_sem_id > 0 )
	{
		destroy_sem( g_ctrl_sem_id, g_ctrl_sem_key );
		g_ctrl_sem_id = -1;
	}

	if( g_debug_fd > 0 )
		close( g_debug_fd );

	return ERR_SUCCESS;
}

/*================================================================================================
외부  함수  정의 
================================================================================================*/
int init_control( send_data_func ptrsend_data )
{
	( void ) ptrsend_data;

	return internal_init();
}

int idle_control( void * ptr )
{
	return internal_idle( ptr );
}

int release_control( void )
{
	return internal_release(); 
}

int recv_cmd_data_transfer( unsigned short inter_msg, void * ptrdata )
{
	return internal_recv_cmd_data_transfer( inter_msg, ptrdata );
}

int recv_update_data_transfer( unsigned short inter_msg, void * ptrdata )
{
	return internal_recv_update_transfer( inter_msg, ptrdata );
}

int recv_sns_data_sensor( unsigned short inter_msg, void * ptrdata )
{
	return internal_recv_sns_data_sensor( inter_msg, ptrdata );
}

int recv_cmd_data_websock( unsigned short inter_msg, void * ptrdata )
{
	return internal_recv_cmd_data_websock( inter_msg, ptrdata );
}

int set_trans_module_recv_func( send_data_func ptrfms_client_func, send_data_func ptrop_server_func ,
								send_data_func ptrupdate_func, send_data_func ptrwebsock_func )
{
	g_ptrsend_fms_client 	= ptrfms_client_func;
	g_ptrsend_op_server 	= ptrop_server_func;
	g_ptrsend_update 		= ptrupdate_func;
	g_ptrsend_websock		= ptrwebsock_func;
	return ERR_SUCCESS;
}

int set_sns_module_recv_func( send_data_func ptrradio_func, send_data_func ptrmcu_func, 
							  send_data_func ptrpwr_c_func, send_data_func ptrremote_func,
							  send_data_func ptrtemp_func,  send_data_func ptrpwr_m_func, 
							  send_data_func ptrapc_ups_func  )
{
	
	g_ptrsend_data_radio 	= ptrradio_func;
	g_ptrsend_data_mcu 		= ptrmcu_func ;
	g_ptrsend_data_pwr_c 	= ptrpwr_c_func;
	g_ptrsend_data_remote 	= ptrremote_func;
	g_ptrsend_data_temp 	= ptrtemp_func;
	g_ptrsend_data_pwr_m 	= ptrpwr_m_func;
	g_ptrsend_data_apc_ups 	= ptrapc_ups_func;

	return ERR_SUCCESS;
}

/*================================================================================================
  Sensor 데이터 처리 함수 
 ================================================================================================*/
static int load_rtu_info( void )
{
	int ret = ERR_SUCCESS;
	rtu_info_t rtu_info;

	memset( &rtu_info, 0, sizeof( rtu_info ));
	
	rtu_info.siteid = get_my_siteid_shm();

	/* db select */
	ret = load_rtu_info_ctrl_db( &rtu_info );

	if ( ret == ERR_SUCCESS )
	{
		/* rtu, fms, op 네트워크 정보 변경 여부 확인 */
		check_rtu_net_change( &rtu_info );
#if 0
		memcpy(rtu_info.net.ip, "192.168.0.135", MAX_IP_SIZE );
		memcpy(rtu_info.net.netmask, "255.255.255.0", MAX_IP_SIZE );
		memcpy(rtu_info.net.gateway, "192.168.0.1", MAX_IP_SIZE );

		memcpy(rtu_info.fms_server_ip, "192.168.0.135", MAX_IP_SIZE );
		rtu_info.fms_server_port = 3000;

		rtu_info.op_port = 3001;

		check_rtu_net_change( &rtu_info );
#endif
		set_rtu_info_db_shm( &rtu_info );
	}

	return ret;
}

static int load_eqp_fclt_info( void )
{
	int ret = ERR_SUCCESS;
	int i,j;
	int cnt ;
	char szip[ MAX_IP_SIZE ];
	unsigned short port =0;
	char * ptrip = NULL;
	int net_type = 0;
	UINT16 port_org = 0;
	int chg_fre = 0;
	int chg_sre = 0;
	int chg_fde = 0;

	int add_fre = 0;
	int add_sre = 0;
	int add_fde = 0;

	int del_fre = 0;
	int del_sre = 0;
	int del_fde = 0;
	static volatile int init_load = 1;
	
	int proc_eqp = 0;

	memset( &g_fclt_info, 0, sizeof( g_fclt_info ));
	memset( &g_fre_mng, 0, sizeof( g_fre_mng ));
	memset( &g_frs_mng, 0, sizeof( g_frs_mng ));
	memset( &g_sre_mng, 0, sizeof( g_sre_mng ));
	memset( &g_fde_mng, 0, sizeof( g_fde_mng ));
	
	load_fclt_info_ctrl_db( &g_fclt_info );
	
	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_fclt_info[ i ].fcltid == 0 )
			break;

		if ( g_fclt_info[ i ].fcltcode == g_fre_fclt_code )
		{
			load_fclt_sns_ctrl_db( g_fclt_info[ i ].fcltid, &g_fre_mng );
			proc_eqp =1;
		}

		if ( g_fclt_info[ i ].fcltcode == g_frs_fclt_code )
		{
			load_fclt_sns_ctrl_db( g_fclt_info[ i ].fcltid, &g_frs_mng );
			proc_eqp =1;
		}

		if ( g_fclt_info[ i ].fcltcode == g_sre_fclt_code )
		{
			load_fclt_sns_ctrl_db( g_fclt_info[ i ].fcltid, &g_sre_mng );
			proc_eqp =1;
		}

		if ( g_fclt_info[ i ].fcltcode == g_fde_fclt_code )
		{
			load_fclt_sns_ctrl_db( g_fclt_info[ i ].fcltid, &g_fde_mng );
			proc_eqp =1;
		}
	}
	
	set_proc_used( PROC_RADIO, proc_eqp );

	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_fclt_info[ i ].fcltid == 0 )
			break;

		print_dbg( DBG_LINE, 1, NULL );
		print_dbg( DBG_SAVE, 1, "DB Data:: FCLT Pos:%d, ID:%d, FCLT Code ;%d, IP:%s, Port:%d, Send Cycle:%d, Gather Cycle:%d",
				                 i, g_fclt_info[ i ].fcltid, g_fclt_info[ i ].fcltcode, g_fclt_info[ i ].szip, g_fclt_info[ i ].port, 
								 g_fclt_info[ i ].send_cycle,g_fclt_info[ i ].gather_cycle );


		if ( g_fclt_info[ i ].fcltcode == g_fre_fclt_code )
		{
			print_dbg( DBG_LINE, 1, NULL );
			print_dbg( DBG_SAVE, 1, "DB Data:: FRE SNS CNT:%d", g_fre_mng.cnt );

			for( j = 0 ; j < MAX_RADIO_SNS_CNT ; j++ )
			{
				if ( g_fre_mng.radio_val[ j ].fclt_id == 0 )
					break;
				print_dbg( DBG_SAVE, 1, "DB Data:: FRE SNS Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
										j, g_fre_mng.radio_val[ j ].fclt_id, g_fre_mng.radio_val[ j ].snsr_id, g_fre_mng.radio_val[ j ].snsr_no, 
										g_fre_mng.radio_val[ j ].snsr_sub_idx ,g_fre_mng.radio_val[ j ].snsr_type ,
										g_fre_mng.radio_val[ j ].snsr_sub_type , g_fre_mng.radio_val[ j ].alarm_yn, g_fre_mng.radio_val[ j ].grade, 
										g_fre_mng.radio_val[ j ].good_val); 
			}
		}

		if ( g_fclt_info[ i ].fcltcode == g_frs_fclt_code )
		{
			print_dbg( DBG_LINE, 1, NULL );
			print_dbg( DBG_SAVE, 1, "DB Data:: FRS SNS CNT:%d", g_frs_mng.cnt );

			for( j = 0 ; j < MAX_RADIO_SNS_CNT ; j++ )
			{
				if ( g_frs_mng.radio_val[ j ].fclt_id == 0 )
					break;
				print_dbg( DBG_SAVE, 1, "DB Data:: FRS SNS Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
										j, g_frs_mng.radio_val[ j ].fclt_id, g_frs_mng.radio_val[ j ].snsr_id, g_frs_mng.radio_val[ j ].snsr_no, 
										g_frs_mng.radio_val[ j ].snsr_sub_idx ,g_frs_mng.radio_val[ j ].snsr_type ,
										g_frs_mng.radio_val[ j ].snsr_sub_type , g_frs_mng.radio_val[ j ].alarm_yn, g_frs_mng.radio_val[ j ].grade, 
										g_frs_mng.radio_val[ j ].good_val); 
			}
		}
		
		if ( g_fclt_info[ i ].fcltcode == g_sre_fclt_code )
		{
			print_dbg( DBG_LINE, 1, NULL );
			print_dbg( DBG_SAVE, 1, "DB Data:: SRE SNS CNT:%d", g_sre_mng.cnt );

			for( j = 0 ; j < MAX_RADIO_SNS_CNT ; j++ )
			{
				if ( g_sre_mng.radio_val[ j ].fclt_id == 0 )
					break;
				print_dbg( DBG_SAVE, 1, "DB Data:: SRE SNS Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
										j, g_sre_mng.radio_val[ j ].fclt_id, g_sre_mng.radio_val[ j ].snsr_id, g_sre_mng.radio_val[ j ].snsr_no, 
										g_sre_mng.radio_val[ j ].snsr_sub_idx ,g_sre_mng.radio_val[ j ].snsr_type ,
										g_sre_mng.radio_val[ j ].snsr_sub_type , g_sre_mng.radio_val[ j ].alarm_yn, g_sre_mng.radio_val[ j ].grade, 
										g_sre_mng.radio_val[ j ].good_val); 
			}
		}

		if ( g_fclt_info[ i ].fcltcode == g_fde_fclt_code )
		{
			print_dbg( DBG_LINE, 1, NULL );
			print_dbg( DBG_SAVE, 1, "DB Data:: FDE SNS CNT:%d", g_fde_mng.cnt );

			for( j = 0 ; j < MAX_RADIO_SNS_CNT ; j++ )
			{
				if ( g_fde_mng.radio_val[ j ].fclt_id == 0 )
					break;
				print_dbg( DBG_SAVE, 1, "DB Data:: FDE SNS Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
										j, g_fde_mng.radio_val[ j ].fclt_id, g_fde_mng.radio_val[ j ].snsr_id, g_fde_mng.radio_val[ j ].snsr_no, 
										g_fde_mng.radio_val[ j ].snsr_sub_idx ,g_fde_mng.radio_val[ j ].snsr_type ,
										g_fde_mng.radio_val[ j ].snsr_sub_type , g_fde_mng.radio_val[ j ].alarm_yn, g_fde_mng.radio_val[ j ].grade, 
										g_fde_mng.radio_val[ j ].good_val); 
			}
		}


	}

	cnt = g_cur_net_mng.cnt;

	for( i = 0 ; i < cnt ;i++ )
	{
		net_type 	= g_cur_net_mng.nets[ i ].type;
		ptrip		= g_cur_net_mng.nets[ i ].net.ip;
		port		= g_cur_net_mng.nets[ i ].net.port;

		port_org = 0;
		memset( szip, 0, MAX_IP_SIZE );

		/* RTU NET 확인  */
		if ( net_type == NET_FRE )
		{
            //printf("............NET_FRE..........\r\n");
			if ( get_fclt_ip_port( g_fre_fclt_code , szip, &port_org ) == ERR_SUCCESS )
			{
                printf("...fre oldip:%s, new ip:%s, old port:%d.. new port:%d..................................\r\n", ptrip, szip,port, port_org );
				if( strlen( ptrip ) != 0  && strlen( szip ) != 0 && strcmp( ptrip , szip ) != 0)
				{
					chg_fre = 1;	
					print_dbg( DBG_SAVE,1, "Change Of FRE IP(%s ->%s)", ptrip, szip  );
					memset( ptrip, 0, MAX_IP_SIZE );
					memcpy( ptrip, szip, MAX_IP_SIZE );

				}
				else if ( strlen( ptrip ) == 0 && strlen( szip ) != 0 )
				{
					add_fre = 1;
					print_dbg( DBG_SAVE,1, "New TCP FRE IP(%s ->%s)", ptrip, szip  );
					memset( ptrip, 0, MAX_IP_SIZE );
					memcpy( ptrip, szip, MAX_IP_SIZE );
				}

				if( port != 0  && port_org != 0 && ( port != port_org ))
				{
					chg_fre = 1;	
					print_dbg( DBG_SAVE,1, "Change Of FRE Port(%d ->%d)", port , port_org  );
					g_cur_net_mng.nets[ i ].net.port = port_org;
				}
				else if ( port ==0 && port_org != 0  )
				{
					add_fre = 1;
					print_dbg( DBG_SAVE,1, "New TCP FRE Port(%d ->%d)", port , port_org  );
					g_cur_net_mng.nets[ i ].net.port = port_org;
				}
			}
			else
			{
				/* 존재하지 않을 경우 삭제 */
				del_fre = 1;
				print_dbg( DBG_SAVE,1, "DEL TCP FRE Network"  );
				memset( g_cur_net_mng.nets[ i ].net.ip, 0, MAX_IP_SIZE );
				g_cur_net_mng.nets[ i ].net.port = 0;
			}
		}

		if ( net_type == NET_SRE )
		{
			if ( get_fclt_ip_port( g_sre_fclt_code , szip, &port_org ) == ERR_SUCCESS )
			{
                printf("...sre oldip:%s, new ip:%s, old port:%d.. new port:%d..................................\r\n", ptrip, szip,port, port_org );

				if( strlen( ptrip ) != 0  && strlen( szip ) != 0 && strcmp( ptrip , szip ) != 0)
				{
					chg_sre = 1;	
					print_dbg( DBG_SAVE,1, "Change Of SRE IP(%s ->%s)", ptrip, szip  );
					memset( ptrip, 0, MAX_IP_SIZE );
					memcpy( ptrip, szip, MAX_IP_SIZE );
				}
				else if ( strlen( ptrip ) == 0 && strlen( szip ) != 0 )
				{
					add_sre = 1;
					print_dbg( DBG_SAVE,1, "New TCP SRE IP(%s ->%s)", ptrip, szip  );
					memset( ptrip, 0, MAX_IP_SIZE );
					memcpy( ptrip, szip, MAX_IP_SIZE );
				}

				if( port != 0  && port_org != 0 && ( port != port_org ))
				{
					chg_sre =1;
					print_dbg( DBG_SAVE,1, "Change Of SRE Port(%d ->%d)", port , port_org  );
					g_cur_net_mng.nets[ i ].net.port = port_org;
				}
				else if ( port ==0 && port_org != 0  )
				{
					add_sre = 1;
					print_dbg( DBG_SAVE,1, "New TCP SRE Port(%d ->%d)", port , port_org  );
					g_cur_net_mng.nets[ i ].net.port = port_org;
				}
			}
			else
			{
				/* 존재하지 않을 경우 삭제 */
				del_sre = 1;
				print_dbg( DBG_SAVE,1, "DEL TCP SRE Network"  );
				memset( g_cur_net_mng.nets[ i ].net.ip, 0, MAX_IP_SIZE );
				g_cur_net_mng.nets[ i ].net.port = 0;
			}

		}

		if ( net_type == NET_FDE )
		{
			if ( get_fclt_ip_port( g_fde_fclt_code , szip, &port_org ) == ERR_SUCCESS )
			{
                printf("...fde oldip:%s, new ip:%s, old port:%d.. new port:%d..................................\r\n", ptrip, szip, port, port_org );
				if( strlen( ptrip ) != 0  && strlen( szip ) != 0 && strcmp( ptrip , szip ) != 0)
				{
					chg_fde = 1;	
					print_dbg( DBG_SAVE,1, "Change Of FDE IP(%s ->%s)", ptrip, szip  );
					memset( ptrip, 0, MAX_IP_SIZE );
					memcpy( ptrip, szip, MAX_IP_SIZE );
				}
				else if ( strlen( ptrip ) == 0 && strlen( szip ) != 0 )
				{
					add_fde = 1;
					print_dbg( DBG_SAVE,1, "New TCP FDE IP(%s ->%s)", ptrip, szip  );
					memset( ptrip, 0, MAX_IP_SIZE );
					memcpy( ptrip, szip, MAX_IP_SIZE );
				}

				if( port != 0  && port_org != 0 && ( port != port_org ))
				{
					chg_fde = 1;
					print_dbg( DBG_SAVE,1, "Change Of FDE Port(%d ->%d)", port , port_org  );
					g_cur_net_mng.nets[ i ].net.port = port_org;
				}
				else if ( port ==0 && port_org != 0  )
				{
					add_fde = 1;
					print_dbg( DBG_SAVE,1, "New TCP FDE Port(%d ->%d)", port , port_org  );
					g_cur_net_mng.nets[ i ].net.port = port_org;
				}
			}
			else
			{
				/* 존재하지 않을 경우 삭제 */
				del_fde = 1;
				print_dbg( DBG_SAVE,1, "DEL TCP FDE Network"  );
				memset( g_cur_net_mng.nets[ i ].net.ip, 0, MAX_IP_SIZE );
				g_cur_net_mng.nets[ i ].net.port = 0;
			}

		}
	}
		
	/* Change */
	if ( chg_fre == 1 && init_load == 0 )
	{
		send_network_chang( ALM_FRE_NET_CHG_NOTI_MSG );
	}

	if ( chg_sre == 1 && init_load == 0 )
	{
		send_network_chang( ALM_SRE_NET_CHG_NOTI_MSG );
	}

	if ( chg_fde == 1 && init_load == 0 )
	{
		send_network_chang( ALM_FDE_NET_CHG_NOTI_MSG );
	}

	/* ADD */
	if ( add_fre == 1 && init_load == 0 )
	{
		send_network_chang( ALM_FRE_NET_ADD_NOTI_MSG );
	}

	if ( add_sre == 1 && init_load == 0 )
	{
		send_network_chang( ALM_SRE_NET_ADD_NOTI_MSG );
	}

	if ( add_fde == 1 && init_load == 0 )
	{
		send_network_chang( ALM_FDE_NET_ADD_NOTI_MSG );
	}

	/* Delete */
	if ( del_fre == 1 && init_load == 0 )
	{
		send_network_chang( ALM_FRE_NET_DEL_NOTI_MSG );

	}

	if ( del_sre == 1 && init_load == 0 )
	{
		send_network_chang( ALM_SRE_NET_DEL_NOTI_MSG );
	}

	if ( del_fde == 1 && init_load == 0 )
	{
		send_network_chang( ALM_FDE_NET_DEL_NOTI_MSG );
	}

	print_dbg( DBG_LINE, 1, NULL );
	
	init_load = 0;

	return ret;
}
static int get_fclt_id( int fclt_code )
{
	int i;
	int id = -1;

	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_rtu_fclt_info[ i ].fcltid == 0 )
			break;
		
		if ( g_rtu_fclt_info[ i ].fcltcode  == fclt_code )
		{
			id = g_rtu_fclt_info[ i ].fcltid ;
			break;
		}
	}

	return id;
}

static int load_rtu_fclt_info( void )
{
	int ret = ERR_SUCCESS;
	int i;
	int cnt ;
	char szip[ MAX_IP_SIZE ];
	unsigned short port =0;
	char * ptrip = NULL;
	int net_type = 0;
	UINT16 port_org = 0;
	int chg_ups = 0;

	int add_ups = 0;

	int del_ups = 0;
	static volatile int init_rtu_load = 1;

	memset( &g_rtu_fclt_info, 0, sizeof( g_rtu_fclt_info ));
	
	load_rtu_fclt_info_ctrl_db( &g_rtu_fclt_info );
	
	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_rtu_fclt_info[ i ].fcltid == 0 )
			break;
	}

	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_rtu_fclt_info[ i ].fcltid == 0 )
			break;

		print_dbg( DBG_LINE, 1, NULL );
		print_dbg( DBG_SAVE, 1, "DB Data:: FCLT Pos:%d, ID:%d, FCLT Code ;%d, IP:%s, Port:%d, Send Cycle:%d, Gather Cycle:%d",
				                 i, g_rtu_fclt_info[ i ].fcltid, g_rtu_fclt_info[ i ].fcltcode, g_rtu_fclt_info[ i ].szip, g_rtu_fclt_info[ i ].port, 
								 g_rtu_fclt_info[ i ].send_cycle,g_rtu_fclt_info[ i ].gather_cycle );
	}

	cnt = g_cur_net_mng.cnt;

	for( i = 0 ; i < cnt ;i++ )
	{
		net_type 	= g_cur_net_mng.nets[ i ].type;
		ptrip		= g_cur_net_mng.nets[ i ].net.ip;
		port		= g_cur_net_mng.nets[ i ].net.port;

		port_org = 0;
		memset( szip, 0, MAX_IP_SIZE );

		/* UPS NET 확인  */
		if ( net_type == NET_UPS )
		{
            //printf("............NET_FRE..........\r\n");
			if ( get_rtu_fclt_ip_port( EFCLT_UPS, szip, &port_org ) == ERR_SUCCESS )
			{
                printf("...ups oldip:%s, new ip:%s, old port:%d.. new port:%d..................................\r\n", ptrip, szip,port, port_org );
				if( strlen( ptrip ) != 0  && strlen( szip ) != 0 && strcmp( ptrip , szip ) != 0)
				{
					chg_ups = 1;	
					print_dbg( DBG_SAVE,1, "Change Of UPS IP(%s ->%s)", ptrip, szip  );
					memset( ptrip, 0, MAX_IP_SIZE );
					memcpy( ptrip, szip, MAX_IP_SIZE );

				}
				else if ( strlen( ptrip ) == 0 && strlen( szip ) != 0 )
				{
					add_ups = 1;
					print_dbg( DBG_SAVE,1, "New TCP UPS IP(%s ->%s)", ptrip, szip  );
					memset( ptrip, 0, MAX_IP_SIZE );
					memcpy( ptrip, szip, MAX_IP_SIZE );
				}

				if( port != 0  && port_org != 0 && ( port != port_org ))
				{
					chg_ups = 1;	
					print_dbg( DBG_SAVE,1, "Change Of UPS Port(%d ->%d)", port , port_org  );
					g_cur_net_mng.nets[ i ].net.port = port_org;
				}
				else if ( port ==0 && port_org != 0  )
				{
					add_ups = 1;
					print_dbg( DBG_SAVE,1, "New TCP UPS Port(%d ->%d)", port , port_org  );
					g_cur_net_mng.nets[ i ].net.port = port_org;
				}
			}
			else
			{
				/* 존재하지 않을 경우 삭제 */
				del_ups = 1;
				print_dbg( DBG_SAVE,1, "DEL TCP UPS Network"  );
				memset( g_cur_net_mng.nets[ i ].net.ip, 0, MAX_IP_SIZE );
				g_cur_net_mng.nets[ i ].net.port = 0;
			}

			/* Change */
			if ( chg_ups == 1 && init_rtu_load == 0 )
			{
				send_network_chang( ALM_UPS_NET_CHG_NOTI_MSG );
			}

			/* ADD */
			if ( add_ups == 1 && init_rtu_load == 0 )
			{
				send_network_chang( ALM_UPS_NET_ADD_NOTI_MSG );
			}

			/* Delete */
			if ( del_ups == 1 && init_rtu_load == 0 )
			{
				send_network_chang( ALM_UPS_NET_DEL_NOTI_MSG );

			}

		}
	}

	print_dbg( DBG_LINE, 1, NULL );
	init_rtu_load = 0;
	return ret;
}


static int load_sns_col_val( void )
{
	int ret = ERR_SUCCESS;
	int i;
	int siteid ;
	int cnt ;
	snsr_col_mng_t * ptrcol_mng = NULL;

	snsr_col_nm_t * ptr = NULL;
	
	siteid = get_my_siteid_shm();
	ptrcol_mng = get_db_col_nm_shm();

	if ( ptrcol_mng == NULL )
	{
		print_dbg( DBG_INFO, 1, "isnull ptrcol_mng data" , __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	/* 초기화 */
	ptrcol_mng->cnt = 0;

	ptr  = (snsr_col_nm_t *)ptrcol_mng->ptrcol_nm;
	for( i = 0 ; i < MAX_COL_NAME_CNT ; i++ )
	{
		if ( ptr != NULL )
		{	
			memset( ptr, 0, sizeof( snsr_col_nm_t ));
			ptr++;
		}
	}

	/* load db */
	ret = load_snsr_col_nm_ctrl_db(  siteid, ptrcol_mng );
	cnt = ptrcol_mng->cnt;

	if (ret != ERR_SUCCESS || cnt  <=0 )
	{
		print_dbg( DBG_ERR,1, "Can not load SNSR COL NAME");
		return ERR_RETURN;
	}

	print_dbg( DBG_LINE, 1, NULL );
	print_dbg( DBG_INFO, 1, "SNSR Col Name Count :%d", cnt );

	ptr  = (snsr_col_nm_t *)ptrcol_mng->ptrcol_nm;
	for( i = 0 ; i < cnt ; i++ )
	{
		if ( ptr != NULL )
		{
			print_dbg( DBG_SAVE, 1, "DB Data:: I:%d, Snsr ID:%d, FCLT ID:%d, SNSR TYPE:%d, SNSR SUB TYPE;%d, SUB IDX:%d, COL NAME:%s",
					i, ptr->snsr_id,  ptr->fclt_id, ptr->snsr_type, ptr->snsr_sub_type, ptr->snsr_idx, ptr->szcol);
			ptr++;
		}
	}

	//set_db_col_nm_shm( &ptrcol_mng );
#if 0
	snsr_info_t snsr_info;
	ptr  = (snsr_col_nm_t *)ptrcol_mng->ptrcol_nm;

	for( i = 0 ; i < cnt ; i++ )
	{
		if ( ptr != NULL )
		{
			memset( &snsr_info, 0, sizeof( snsr_info ));
			get_db_col_info_shm( ptr->snsr_type, ptr->snsr_sub_type, ptr->snsr_idx, &snsr_info );
			print_dbg(DBG_NONE, 1, " i:%d, SNSR ID:%d, NAME:%s", i, snsr_info.snsr_id, snsr_info.szcol );
			ptr++;
		}
	}
#endif
	return ret;

}

static int get_fclt_ip_port( int fcltcode, char * ptrip, unsigned short * ptrport )
{
	int ret = ERR_RETURN;
	int i;

	if ( ptrip == NULL || ptrport == NULL )
	{
		return ret;
	}

	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_fclt_info[ i ].fcltid == 0 )
			break;

		if ( g_fclt_info[ i ].fcltcode == fcltcode )
		{
			memcpy( ptrip, g_fclt_info[ i ].szip, MAX_IP_SIZE );
			*ptrport = g_fclt_info[ i ].port;
			ret = ERR_SUCCESS;
			break;
		}
	}

	return ret;
}

static int get_rtu_fclt_ip_port( int fcltcode, char * ptrip, unsigned short * ptrport )
{
	int ret = ERR_RETURN;
	int i;

	if ( ptrip == NULL || ptrport == NULL )
	{
		return ret;
	}

	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_rtu_fclt_info[ i ].fcltid == 0 )
			break;

		if ( g_rtu_fclt_info[ i ].fcltcode == fcltcode )
		{
			memcpy( ptrip, g_rtu_fclt_info[ i ].szip, MAX_IP_SIZE );
			*ptrport = g_rtu_fclt_info[ i ].port;
			ret = ERR_SUCCESS;
			break;
		}
	}

	return ret;
}

static int load_di_val( void )
{
	int ret = ERR_SUCCESS;
	int rtuid = 0;
	int i, pos;
	int ups_cnt = 0;

	di_val_t temp_di[ MAX_GPIO_CNT * 2 ];

	memset(&temp_di, 0, sizeof( temp_di ));
	memset( &g_di_val, 0, sizeof( g_di_val ));
	memset( &g_ground_val, 0, sizeof (g_ground_val ));
	memset( &g_video_val, 0, sizeof (g_video_val ));

	rtuid = get_my_rtu_fcltid_shm();
	
	load_di_ctrl_db( rtuid, &temp_di );


	for( i = 0 ; i < ( MAX_GPIO_CNT * 2 ) ; i++ )
	{
		if ( temp_di [ i ].snsr_id == 0 )
			break;

		/* 영상 녹화  : video */
		if ( temp_di [ i ].snsr_sub_type == ESNSRSUB_DI_RECVIDEO )
		{
			g_video_val.fcltid 			= temp_di[ i ].fcltid;
			g_video_val.snsr_id 		= temp_di[ i ].snsr_id;
			g_video_val.snsr_no 		= temp_di[ i ].snsr_no;
			g_video_val.snsr_sub_idx 	= temp_di[ i ].snsr_sub_idx;
			g_video_val.snsr_type 		= temp_di[ i ].snsr_type;
			g_video_val.snsr_sub_type 	= temp_di[ i ].snsr_sub_type;
			memcpy( g_video_val.alarm_yn, temp_di[ i ].alarm_yn, 1 );
			g_video_val.grade 			= temp_di[ i ].grade;
            g_video_val.alarm_keep_time = temp_di[ i ].alarm_keep_time;
			g_video_val.good_val 		= temp_di[ i ].good_val;


			memcpy( g_video_val.szip, temp_di[ i ].szip, MAX_IP_SIZE );
			memcpy( g_video_val.szport, temp_di[ i ].szport, MAX_PORT_SIZE );

			memcpy( g_video_val.szlabel0, temp_di[ i ].szlabel0, SZ_MAX_LABEL );
			memcpy( g_video_val.szlabel1, temp_di[ i ].szlabel1, SZ_MAX_LABEL );
		}
		/* 지락  경우 : ground */
		else if ( temp_di [ i ].snsr_sub_type == ESNSRSUB_DI_POWERGROUND)
		{
			g_ground_val.fcltid 		= temp_di[ i ].fcltid;
			g_ground_val.snsr_id 		= temp_di[ i ].snsr_id;
			g_ground_val.snsr_no 		= temp_di[ i ].snsr_no;
			g_ground_val.snsr_sub_idx 	= temp_di[ i ].snsr_sub_idx;
			g_ground_val.snsr_type 		= temp_di[ i ].snsr_type;
			g_ground_val.snsr_sub_type 	= temp_di[ i ].snsr_sub_type;
			memcpy( g_ground_val.alarm_yn, temp_di[ i ].alarm_yn, 1 );
			g_ground_val.grade 			= temp_di[ i ].grade;
			g_ground_val.good_val 		= temp_di[ i ].good_val;
            g_ground_val.alarm_keep_time = temp_di[ i ].alarm_keep_time;

            g_ground_val.last_sts       = g_ground_val.good_val;

			memcpy( g_ground_val.szlabel0, temp_di[ i ].szlabel0, SZ_MAX_LABEL );
			memcpy( g_ground_val.szlabel1, temp_di[ i ].szlabel1, SZ_MAX_LABEL );

			set_proc_used( PROC_PWR_M, 1 );

		}
		else if ( temp_di[ i ].snsr_sub_type == ESNSRSUB_DI_UPS_LOW_INPUT )
		{
			
			//printf("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk1\r\n");
			if ( ups_cnt < MAX_APC_UPS_DATA_CNT )
			{
			//printf("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk2\r\n");
				g_apc_ups_di_val[ ups_cnt ].fcltid 		= temp_di [ i ].fcltid;
				g_apc_ups_di_val[ ups_cnt ].snsr_id 		= temp_di [ i ].snsr_id;
				g_apc_ups_di_val[ ups_cnt ].snsr_no 		= temp_di [ i ].snsr_no;
				g_apc_ups_di_val[ ups_cnt ].snsr_sub_idx 	= temp_di [ i ].snsr_sub_idx;
				g_apc_ups_di_val[ ups_cnt ].snsr_type 		= temp_di [ i ].snsr_type;
				g_apc_ups_di_val[ ups_cnt ].snsr_sub_type 	= temp_di [ i ].snsr_sub_type;
				memcpy( g_apc_ups_di_val[ ups_cnt ].alarm_yn, temp_di [ i ].alarm_yn, 1 );
				g_apc_ups_di_val[ ups_cnt ].grade 			= temp_di [ i ].grade;
				g_apc_ups_di_val[ ups_cnt ].good_val 		= temp_di [ i ].good_val;
				g_apc_ups_di_val[ ups_cnt ].last_sts 		= temp_di [ i ].good_val;
				g_apc_ups_di_val[ ups_cnt ].alarm_keep_time = temp_di[ i ].alarm_keep_time;

				memcpy( g_apc_ups_di_val[ ups_cnt ].szlabel0, temp_di[ i ].szlabel0, SZ_MAX_LABEL );
				memcpy( g_apc_ups_di_val[ ups_cnt ].szlabel1, temp_di[ i ].szlabel1, SZ_MAX_LABEL );
				ups_cnt++;
			}

			set_proc_used( PROC_APC_UPS, 1 );
		}
		/* 순수 DO : di */
		else
		{
			pos = temp_di[ i ].snsr_no;

			g_di_val[ pos ].fcltid 			= temp_di [ i ].fcltid;
			g_di_val[ pos ].snsr_id 		= temp_di [ i ].snsr_id;
			g_di_val[ pos ].snsr_no 		= temp_di [ i ].snsr_no;
			g_di_val[ pos ].snsr_sub_idx 	= temp_di [ i ].snsr_sub_idx;
			g_di_val[ pos ].snsr_type 		= temp_di [ i ].snsr_type;
			g_di_val[ pos ].snsr_sub_type 	= temp_di [ i ].snsr_sub_type;
			memcpy( g_di_val[ pos ].alarm_yn, temp_di [ i ].alarm_yn, 1 );
			g_di_val[ pos ].grade 			= temp_di [ i ].grade;
			g_di_val[ pos ].good_val 		= temp_di [ i ].good_val;
			g_di_val[ pos ].last_sts 		= temp_di [ i ].good_val;
            g_di_val[ pos ].alarm_keep_time = temp_di[ i ].alarm_keep_time;

			memcpy( g_di_val[ pos ].szlabel0, temp_di[ i ].szlabel0, SZ_MAX_LABEL );
			memcpy( g_di_val[ pos ].szlabel1, temp_di[ i ].szlabel1, SZ_MAX_LABEL );

		}
	}
	print_dbg( DBG_LINE, 1, NULL );

	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		print_dbg( DBG_SAVE, 1, "DB Data:: DI Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
				i, g_di_val[ i ].fcltid, g_di_val[ i ].snsr_id, g_di_val[ i ].snsr_no, g_di_val[ i ].snsr_sub_idx, g_di_val[ i ].snsr_type ,
				g_di_val[ i ].snsr_sub_type, g_di_val[ i ].alarm_yn ,g_di_val[ i ].grade , g_di_val[ i ].good_val );
	}

	print_dbg( DBG_LINE, 1, NULL );

	print_dbg( DBG_SAVE, 1, "DB Data:: VIDEO ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d, IP:%s, PORT:%s",
			g_video_val.fcltid, g_video_val.snsr_id, g_video_val.snsr_no, g_video_val.snsr_sub_idx, g_video_val.snsr_type ,
			g_video_val.snsr_sub_type, g_video_val.alarm_yn ,g_video_val.grade , g_video_val.good_val, g_video_val.szip, g_video_val.szport );

	print_dbg( DBG_LINE, 1, NULL );

	print_dbg( DBG_SAVE, 1, "DB Data:: GROUND ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d,",
			g_ground_val.fcltid, g_ground_val.snsr_id, g_ground_val.snsr_no, g_ground_val.snsr_sub_idx, g_ground_val.snsr_type ,
			g_ground_val.snsr_sub_type, g_ground_val.alarm_yn ,g_ground_val.grade , g_ground_val.good_val );
	return ret;
}

static int load_do_val( void )
{
	do_val_t temp_do[ MAX_GPIO_CNT * 6 ];
	int rtuid = 0;
	int ret = ERR_SUCCESS;
	int i, pos ;

	//memset( &g_do_val, 0, sizeof( g_do_val ));
	//memset( &g_doe_val, 0, sizeof( g_doe_val ));
	memset( &g_remote_val, 0, sizeof( g_remote_val ));
	//memset( &g_pwr_c_val, 0, sizeof( g_pwr_c_val ));

	memset( temp_do, 0, sizeof( temp_do ));
	
	rtuid = get_my_rtu_fcltid_shm();
	load_do_ctrl_db( rtuid, &temp_do ); 
	
	
	for( i = 0 ; i < ( MAX_GPIO_CNT * 6 ) ; i++ )
	{
		if ( temp_do [ i ].snsr_id == 0 )
			break;

		/* 냉방방 경우 : remote */
		if ( temp_do [ i ].snsr_sub_type == ESNSRSUB_DO_AIRCON	)
		{
			g_remote_val.fcltid 		= temp_do [ i ].fcltid;
			g_remote_val.snsr_id 		= temp_do [ i ].snsr_id;
			g_remote_val.snsr_no 		= temp_do [ i ].snsr_no;
			g_remote_val.snsr_sub_idx 	= temp_do [ i ].snsr_sub_idx;
			g_remote_val.snsr_type 		= temp_do [ i ].snsr_type;
			g_remote_val.snsr_sub_type 	= temp_do [ i ].snsr_sub_type;
			memcpy( g_remote_val.alarm_yn, temp_do [ i ].alarm_yn, 1 );
			g_remote_val.grade 			= temp_do [ i ].grade;
			g_remote_val.good_val 		= temp_do [ i ].good_val;

			//memcpy( g_remote_val.szlabel0, temp_do[ i ].szlabel0, SZ_MAX_LABEL );
			//memcpy( g_remote_val.szlabel1, temp_do[ i ].szlabel1, SZ_MAX_LABEL );
			set_proc_used( PROC_REMOTE, 1 );

		}
		/* 전등 ON/OFF 경우 : doe */
		else if ( temp_do [ i ].snsr_sub_type == ESNSRSUB_DO_LIGHT)
		{
			pos = temp_do [ i ].snsr_no;

			g_doe_val[ pos ].fcltid 		= temp_do [ i ].fcltid;
			g_doe_val[ pos ].snsr_id 		= temp_do [ i ].snsr_id;
			g_doe_val[ pos ].snsr_no 		= temp_do [ i ].snsr_no;
			g_doe_val[ pos ].snsr_sub_idx 	= temp_do [ i ].snsr_sub_idx;
			g_doe_val[ pos ].snsr_type 		= temp_do [ i ].snsr_type;
			g_doe_val[ pos ].snsr_sub_type 	= temp_do [ i ].snsr_sub_type;
			memcpy( g_doe_val[ pos ].alarm_yn, temp_do [ i ].alarm_yn, 1 );
			g_doe_val[ pos ].grade 			= temp_do [ i ].grade;
			g_doe_val[ pos ].good_val 		= temp_do [ i ].good_val;
			
			memset( g_doe_val[ pos ].szlabel0, 0, SZ_MAX_LABEL );
			memset( g_doe_val[ pos ].szlabel1, 0, SZ_MAX_LABEL );

			memcpy( g_doe_val[ pos ].szlabel0, temp_do[ i ].szlabel0, SZ_MAX_LABEL );
			memcpy( g_doe_val[ pos ].szlabel1, temp_do[ i ].szlabel1, SZ_MAX_LABEL );

		}
		else if ( temp_do [ i ].snsr_sub_type == ESNSRSUB_DO_POWERRTU  )
		{
			pos = temp_do [ i ].snsr_no;

			g_doe_val[ pos ].fcltid 		= temp_do [ i ].fcltid;
			g_doe_val[ pos ].snsr_id 		= temp_do [ i ].snsr_id;
			g_doe_val[ pos ].snsr_no 		= temp_do [ i ].snsr_no;
			g_doe_val[ pos ].snsr_sub_idx 	= temp_do [ i ].snsr_sub_idx;
			g_doe_val[ pos ].snsr_type 		= temp_do [ i ].snsr_type;
			g_doe_val[ pos ].snsr_sub_type 	= temp_do [ i ].snsr_sub_type;
			memcpy( g_doe_val[ pos ].alarm_yn, temp_do [ i ].alarm_yn, 1 );
			g_doe_val[ pos ].grade 			= temp_do [ i ].grade;
			g_doe_val[ pos ].good_val 		= temp_do [ i ].good_val;

			memset( g_doe_val[ pos ].szlabel0, 0, SZ_MAX_LABEL );
			memset( g_doe_val[ pos ].szlabel1, 0, SZ_MAX_LABEL );

			memcpy( g_doe_val[ pos ].szlabel0, temp_do[ i ].szlabel0, SZ_MAX_LABEL );
			memcpy( g_doe_val[ pos ].szlabel1, temp_do[ i ].szlabel1, SZ_MAX_LABEL );

		}
		else if ( temp_do [ i ].snsr_sub_type ==  ESNSRSUB_DO_POWERELECCTL )
		{
			pos = temp_do [ i ].snsr_no;

			g_pwr_c_val[ pos ].fcltid 		= temp_do [ i ].fcltid;
			g_pwr_c_val[ pos ].snsr_id 		= temp_do [ i ].snsr_id;
			g_pwr_c_val[ pos ].snsr_no 		= temp_do [ i ].snsr_no;
			g_pwr_c_val[ pos ].snsr_sub_idx 	= temp_do [ i ].snsr_sub_idx;
			g_pwr_c_val[ pos ].snsr_type 		= temp_do [ i ].snsr_type;
			g_pwr_c_val[ pos ].snsr_sub_type 	= temp_do [ i ].snsr_sub_type;
			memcpy( g_pwr_c_val[ pos ].alarm_yn, temp_do [ i ].alarm_yn, 1 );
			g_pwr_c_val[ pos ].grade 			= temp_do [ i ].grade;
			g_pwr_c_val[ pos ].good_val 		= temp_do [ i ].good_val;
			
			memset( g_pwr_c_val[ pos ].szlabel0, 0, SZ_MAX_LABEL );
			memset( g_pwr_c_val[ pos ].szlabel1, 0, SZ_MAX_LABEL );


			memcpy( g_pwr_c_val[ pos ].szlabel0, temp_do[ i ].szlabel0, SZ_MAX_LABEL );
			memcpy( g_pwr_c_val[ pos ].szlabel1, temp_do[ i ].szlabel1, SZ_MAX_LABEL );

			set_proc_used( PROC_PWR_C, 1 );
		}
		/* 순수 DO : do */
		else
		{
			pos = temp_do [ i ].snsr_no;

			g_do_val[ pos ].fcltid 		= temp_do [ i ].fcltid;
			g_do_val[ pos ].snsr_id 		= temp_do [ i ].snsr_id;
			g_do_val[ pos ].snsr_no 		= temp_do [ i ].snsr_no;
			g_do_val[ pos ].snsr_sub_idx 	= temp_do [ i ].snsr_sub_idx;
			g_do_val[ pos ].snsr_type 		= temp_do [ i ].snsr_type;
			g_do_val[ pos ].snsr_sub_type 	= temp_do [ i ].snsr_sub_type;
			memcpy( g_do_val[ pos ].alarm_yn, temp_do [ i ].alarm_yn, 1 );
			g_do_val[ pos ].grade 			= temp_do [ i ].grade;
			g_do_val[ pos ].good_val 		= temp_do [ i ].good_val;

			memset( g_do_val[ pos ].szlabel0, 0, SZ_MAX_LABEL );
			memset( g_do_val[ pos ].szlabel1, 0, SZ_MAX_LABEL );

			memcpy( g_do_val[ pos ].szlabel0, temp_do[ i ].szlabel0, SZ_MAX_LABEL );
			memcpy( g_do_val[ pos ].szlabel1, temp_do[ i ].szlabel1, SZ_MAX_LABEL );

		}
	}

	print_dbg( DBG_LINE, 1, NULL );

	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		print_dbg( DBG_SAVE, 1, "DB Data:: DO Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
				i, g_do_val[ i ].fcltid, g_do_val[ i ].snsr_id, g_do_val[ i ].snsr_no, g_do_val[ i ].snsr_sub_idx, g_do_val[ i ].snsr_type ,
				g_do_val[ i ].snsr_sub_type, g_do_val[ i ].alarm_yn ,g_do_val[ i ].grade , g_do_val[ i ].good_val );
	}

	print_dbg( DBG_LINE, 1, NULL );

	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		print_dbg( DBG_SAVE, 1, "DB Data:: DOE Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
				i, g_doe_val[ i ].fcltid, g_doe_val[ i ].snsr_id, g_doe_val[ i ].snsr_no, g_doe_val[ i ].snsr_sub_idx, g_doe_val[ i ].snsr_type ,
				g_doe_val[ i ].snsr_sub_type, g_doe_val[ i ].alarm_yn ,g_doe_val[ i ].grade , g_doe_val[ i ].good_val );
	}

	print_dbg( DBG_LINE, 1, NULL );

	for( i = 0 ; i < MAX_PWR_C_PORT_CNT ; i++ )
	{
		print_dbg( DBG_SAVE, 1, "DB Data:: PWR C Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
				i, g_pwr_c_val[ i ].fcltid, g_pwr_c_val[ i ].snsr_id, g_pwr_c_val[ i ].snsr_no, g_pwr_c_val[ i ].snsr_sub_idx, g_pwr_c_val[ i ].snsr_type ,
				g_pwr_c_val[ i ].snsr_sub_type, g_pwr_c_val[ i ].alarm_yn ,g_pwr_c_val[ i ].grade , g_pwr_c_val[ i ].good_val );
	}

	print_dbg( DBG_LINE, 1, NULL );
	print_dbg( DBG_SAVE, 1, "DB Data:: REMOTE ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, Grade:%d, GoodVal:%d",
			g_remote_val.fcltid,g_remote_val.snsr_id, g_remote_val.snsr_no, g_remote_val.snsr_sub_idx, g_remote_val.snsr_type, 
			g_remote_val.snsr_sub_type, g_remote_val.alarm_yn, g_remote_val.grade, g_remote_val.good_val );

	print_dbg( DBG_LINE, 1, NULL );

	return ret;
}


static int load_ai_val( void )
{
	int ret = ERR_SUCCESS;
	int rtuid = 0;
	int i , j, pos;
	int data_pos = 0;
	int ups_cnt = 0;

	temp_val_t temp[ MAX_GRP_RSLT_AI ];

	memset( &g_temp_val, 0, sizeof( g_temp_val ));
	memset( &g_pwr_m_val, 0, sizeof( g_pwr_m_val ));

	memset( &temp, 0, sizeof( temp ));

	rtuid = get_my_rtu_fcltid_shm();

	load_ai_ctrl_db( rtuid, &temp ); 
	

	for( i = 0 ; i < MAX_GRP_RSLT_AI ;i++ )
	{
		if ( temp[ i ].snsr_id == 0 )
			break;

		/* 온습도 :temp val */
		if ( (temp[ i ].snsr_sub_type == ESNSRSUB_AI_TEMPERATURE) ||
			 (temp[ i ].snsr_sub_type == ESNSRSUB_AI_HUMIDITY) )
		{
			pos = temp[ i ].snsr_no;

			g_temp_val[ pos ].fcltid 		= temp[ i ].fcltid;
			g_temp_val[ pos ].snsr_id		= temp[ i ].snsr_id;
			g_temp_val[ pos ].snsr_no		= temp[ i ].snsr_no;
			g_temp_val[ pos ].snsr_sub_idx	= temp[ i ].snsr_sub_idx;
			g_temp_val[ pos ].snsr_type		= temp[ i ].snsr_type;
			g_temp_val[ pos ].snsr_sub_type	= temp[ i ].snsr_sub_type;
			memcpy( &g_temp_val[ pos ].alarm_yn, &temp[ i ].alarm_yn, 1 );
			g_temp_val[ pos ].min_val		= temp[ i ].min_val;
			g_temp_val[ pos ].max_val		= temp[ i ].max_val;
			g_temp_val[ pos ].offset_val	= temp[ i ].offset_val;
			g_temp_val[ pos ].alarm_keep_time = temp[ i ].alarm_keep_time ;

			for( j = 0 ; j< MAX_RANG_CNT ; j++ )
			{
				g_temp_val[ pos ].range_val[j] = temp[ i ].range_val[j];
			}

			set_proc_used( PROC_TEMP, 1 );

		}
		/* 전원 감시 */
#if 1
		/* 2016 11 16 modify */
		else if ((temp[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVR) ||
				(temp[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVS) ||
				(temp[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVT) || 
				(temp[ i ].snsr_sub_type == ESNSRSUB_AI_POWERFREQ) )
#else
		else if ((temp[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVR) )
#endif
		{
			pos = temp[ i ].snsr_no;

			g_pwr_m_val[ pos ].fcltid 		= temp[ i ].fcltid;
			g_pwr_m_val[ pos ].snsr_id		= temp[ i ].snsr_id;
			g_pwr_m_val[ pos ].snsr_no		= temp[ i ].snsr_no;
			g_pwr_m_val[ pos ].snsr_sub_idx	= temp[ i ].snsr_sub_idx;
			g_pwr_m_val[ pos ].snsr_type		= temp[ i ].snsr_type;
			g_pwr_m_val[ pos ].snsr_sub_type	= temp[ i ].snsr_sub_type;
			memcpy( &g_pwr_m_val[ pos ].alarm_yn, &temp[ i ].alarm_yn, 1 );
			g_pwr_m_val[ pos ].min_val		= temp[ i ].min_val;
			g_pwr_m_val[ pos ].max_val		= temp[ i ].max_val;
			g_pwr_m_val[ pos ].offset_val	= temp[ i ].offset_val;
			g_pwr_m_val[ pos ].alarm_keep_time = temp[ i ].alarm_keep_time ;

			for( j = 0 ; j< MAX_RANG_CNT ; j++ )
			{
				g_pwr_m_val[ pos ].range_val[j] = temp[ i ].range_val[j];
			}
			
			set_proc_used( PROC_PWR_M, 1 );

			/* get data position  2016 11 16 */
			if ( load_pwr_m_data_pos_ctrl_db( g_pwr_m_val[ pos ].snsr_id, &data_pos ) == ERR_SUCCESS )
			{
			 	g_pwr_m_val[ pos ].data_pos = data_pos ;
			}
			else
			{
			 	g_pwr_m_val[ pos ].data_pos = 1;
				print_dbg( DBG_ERR, 1, "Cannot find PWR M VAL");
				return ERR_SUCCESS;
			}
		}
		else if ( temp[ i ].snsr_sub_type == ESNSRSUB_AI_UPS_BATTERY_CHARGE || 
				  temp[ i ].snsr_sub_type == ESNSRSUB_AI_UPS_BATTERY_REMAIN_TIME )	
		{
		
			if ( ups_cnt < MAX_APC_UPS_DATA_CNT )
			{
				g_apc_ups_ai_val[ ups_cnt ].fcltid 		= temp[ i ].fcltid;
				g_apc_ups_ai_val[ ups_cnt].snsr_id		= temp[ i ].snsr_id;
				g_apc_ups_ai_val[ ups_cnt].snsr_no		= temp[ i ].snsr_no;
				g_apc_ups_ai_val[ ups_cnt].snsr_sub_idx	= temp[ i ].snsr_sub_idx;
				g_apc_ups_ai_val[ ups_cnt].snsr_type		= temp[ i ].snsr_type;
				g_apc_ups_ai_val[ ups_cnt].snsr_sub_type	= temp[ i ].snsr_sub_type;
				memcpy( &g_apc_ups_ai_val[ups_cnt ].alarm_yn, &temp[ i ].alarm_yn, 1 );
				g_apc_ups_ai_val[ ups_cnt].min_val		= temp[ i ].min_val;
				g_apc_ups_ai_val[ ups_cnt].max_val		= temp[ i ].max_val;
				g_apc_ups_ai_val[ ups_cnt].offset_val	= temp[ i ].offset_val;
				g_apc_ups_ai_val[ ups_cnt].alarm_keep_time = temp[ i ].alarm_keep_time ;
				g_apc_ups_ai_val[ ups_cnt].last_val 	= -1;

				for( j = 0 ; j< MAX_RANG_CNT ; j++ )
				{
					g_apc_ups_ai_val[ups_cnt ].range_val[j] = temp[ i ].range_val[j];
				}
				ups_cnt++;
			}
			set_proc_used( PROC_APC_UPS, 1 );
		}
	}

	print_dbg( DBG_LINE, 1, NULL );
	for ( i = 0 ; i < MAX_TEMP_CNT ; i++ )
	{
		if ( g_temp_val[i].snsr_id == 0 )
			break;
		print_dbg( DBG_SAVE, 1, "DB Data:: TEMP Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, MIN :%.2f, MAX:%.2f, OFFSET:%.2f",
				i, g_temp_val[ i ].fcltid, g_temp_val[ i ].snsr_id, g_temp_val[ i ].snsr_no, g_temp_val[ i ].snsr_sub_idx, g_temp_val[ i ].snsr_type ,
				g_temp_val[ i ].snsr_sub_type, g_temp_val[ i ].alarm_yn ,g_temp_val[ i ].min_val , g_temp_val[ i ].max_val,g_temp_val[ i ].offset_val);
		print_dbg( DBG_NONE, 1, "DA_LOW:%.2f, WA_LOW:%.2f, CA_LOW:%.2f, CA_HIGH:%.2f, WA_HIGH:%.2f, DA_HIGH:%.2f",
				g_temp_val[ i ].range_val[ 0 ],g_temp_val[ i ].range_val[ 1 ],g_temp_val[ i ].range_val[ 2 ],
				g_temp_val[ i ].range_val[ 3 ],g_temp_val[ i ].range_val[ 4 ],g_temp_val[ i ].range_val[ 5 ] );

	}

	print_dbg( DBG_LINE, 1, NULL );
	for ( i = 0 ; i < MAX_PWR_M_CNT ; i++ )
	{
		if ( g_pwr_m_val[i].snsr_id == 0 )
			break;
		print_dbg( DBG_SAVE, 1, "DB Data:: PWR M Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, MIN :%.2f, MAX:%.2f, OFFSET:%.2f, DATA_POS:%d",
				i, g_pwr_m_val[ i ].fcltid, g_pwr_m_val[ i ].snsr_id, g_pwr_m_val[ i ].snsr_no, g_pwr_m_val[ i ].snsr_sub_idx, 
				g_pwr_m_val[ i ].snsr_type ,g_pwr_m_val[ i ].snsr_sub_type, g_pwr_m_val[ i ].alarm_yn ,g_pwr_m_val[ i ].min_val , 
				g_pwr_m_val[ i ].max_val,g_pwr_m_val[ i ].offset_val,g_pwr_m_val[ i ].data_pos);
		print_dbg( DBG_NONE, 1, "DA_LOW:%.2f, WA_LOW:%.2f, CA_LOW:%.2f, CA_HIGH:%.2f, WA_HIGH:%.2f, DA_HIGH:%.2f",
				g_pwr_m_val[ i ].range_val[ 0 ],g_pwr_m_val[ i ].range_val[ 1 ],g_pwr_m_val[ i ].range_val[ 2 ],
				g_pwr_m_val[ i ].range_val[ 3 ],g_pwr_m_val[ i ].range_val[ 4 ],g_pwr_m_val[ i ].range_val[ 5 ] );

	}

	return ret;
}

static int load_di_ups_val( void )
{
	int ret = ERR_SUCCESS;
	int fcltid = 0;
	int i;
	int ups_cnt = 0;

	di_val_t temp_di[ MAX_GPIO_CNT * 2 ];

	memset(&temp_di, 0, sizeof( temp_di ));
	memset( &g_apc_ups_di_val, 0, sizeof (g_apc_ups_di_val ));

	fcltid = get_fclt_id( EFCLT_UPS );	
	load_di_ctrl_db( fcltid, &temp_di );


	for( i = 0 ; i < ( MAX_GPIO_CNT * 2 ) ; i++ )
	{
		if ( temp_di [ i ].snsr_id == 0 )
			break;

		if ( temp_di[ i ].snsr_sub_type == ESNSRSUB_DI_UPS_LOW_INPUT )
		{
			
			//printf("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk1\r\n");
			if ( ups_cnt < MAX_APC_UPS_DATA_CNT )
			{
			//printf("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk2\r\n");
				g_apc_ups_di_val[ ups_cnt ].fcltid 		= temp_di [ i ].fcltid;
				g_apc_ups_di_val[ ups_cnt ].snsr_id 		= temp_di [ i ].snsr_id;
				g_apc_ups_di_val[ ups_cnt ].snsr_no 		= temp_di [ i ].snsr_no;
				g_apc_ups_di_val[ ups_cnt ].snsr_sub_idx 	= temp_di [ i ].snsr_sub_idx;
				g_apc_ups_di_val[ ups_cnt ].snsr_type 		= temp_di [ i ].snsr_type;
				g_apc_ups_di_val[ ups_cnt ].snsr_sub_type 	= temp_di [ i ].snsr_sub_type;
				memcpy( g_apc_ups_di_val[ ups_cnt ].alarm_yn, temp_di [ i ].alarm_yn, 1 );
				g_apc_ups_di_val[ ups_cnt ].grade 			= temp_di [ i ].grade;
				g_apc_ups_di_val[ ups_cnt ].good_val 		= temp_di [ i ].good_val;
				g_apc_ups_di_val[ ups_cnt ].last_sts 		= temp_di [ i ].good_val;
				g_apc_ups_di_val[ ups_cnt ].alarm_keep_time = temp_di[ i ].alarm_keep_time;

				memcpy( g_apc_ups_di_val[ ups_cnt ].szlabel0, temp_di[ i ].szlabel0, SZ_MAX_LABEL );
				memcpy( g_apc_ups_di_val[ ups_cnt ].szlabel1, temp_di[ i ].szlabel1, SZ_MAX_LABEL );
				ups_cnt++;
			}

			set_proc_used( PROC_APC_UPS, 1 );
		}
	}
	print_dbg( DBG_LINE, 1, NULL );

	for( i = 0 ; i < MAX_APC_UPS_DATA_CNT ; i++ )
	{
		if ( g_apc_ups_di_val[ i ].fcltid != 0 &&  g_apc_ups_di_val[ i ].snsr_id != 0 )
		{
			print_dbg( DBG_SAVE, 1, "DB Data:: UPS Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
					ALARM YN:%s, Grade:%d, GoodVal:%d",
					i, g_apc_ups_di_val[ i ].fcltid, g_apc_ups_di_val[ i ].snsr_id, g_apc_ups_di_val[ i ].snsr_no, g_apc_ups_di_val[ i ].snsr_sub_idx, g_apc_ups_di_val[ i ].snsr_type ,
					g_apc_ups_di_val[ i ].snsr_sub_type, g_apc_ups_di_val[ i ].alarm_yn ,g_apc_ups_di_val[ i ].grade , g_apc_ups_di_val[ i ].good_val );
		}
	}

	return ret;
}

static int load_ai_ups_val( void )
{
	int ret = ERR_SUCCESS;
	int fcltid = 0;
	int i , j;
	int ups_cnt = 0;

	temp_val_t temp[ MAX_GRP_RSLT_AI ];

	memset( &g_apc_ups_ai_val, 0, sizeof (g_apc_ups_ai_val ));

	memset( &temp, 0, sizeof( temp ));

	fcltid = get_fclt_id( EFCLT_UPS );	

	load_ai_ctrl_db( fcltid, &temp ); 

	for( i = 0 ; i < MAX_GRP_RSLT_AI ;i++ )
	{
		if ( temp[ i ].snsr_id == 0 )
			break;

		if ( temp[ i ].snsr_sub_type == ESNSRSUB_AI_UPS_BATTERY_CHARGE || 
				  temp[ i ].snsr_sub_type == ESNSRSUB_AI_UPS_BATTERY_REMAIN_TIME )	
		{
		
			if ( ups_cnt < MAX_APC_UPS_DATA_CNT )
			{
				g_apc_ups_ai_val[ ups_cnt ].fcltid 		= temp[ i ].fcltid;
				g_apc_ups_ai_val[ ups_cnt].snsr_id		= temp[ i ].snsr_id;
				g_apc_ups_ai_val[ ups_cnt].snsr_no		= temp[ i ].snsr_no;
				g_apc_ups_ai_val[ ups_cnt].snsr_sub_idx	= temp[ i ].snsr_sub_idx;
				g_apc_ups_ai_val[ ups_cnt].snsr_type		= temp[ i ].snsr_type;
				g_apc_ups_ai_val[ ups_cnt].snsr_sub_type	= temp[ i ].snsr_sub_type;
				memcpy( &g_apc_ups_ai_val[ups_cnt ].alarm_yn, &temp[ i ].alarm_yn, 1 );
				g_apc_ups_ai_val[ ups_cnt].min_val		= temp[ i ].min_val;
				g_apc_ups_ai_val[ ups_cnt].max_val		= temp[ i ].max_val;
				g_apc_ups_ai_val[ ups_cnt].offset_val	= temp[ i ].offset_val;
				g_apc_ups_ai_val[ ups_cnt].alarm_keep_time = temp[ i ].alarm_keep_time ;
				g_apc_ups_ai_val[ ups_cnt].last_val 	= -1;

				for( j = 0 ; j< MAX_RANG_CNT ; j++ )
				{
					g_apc_ups_ai_val[ups_cnt ].range_val[j] = temp[ i ].range_val[j];
				}
				ups_cnt++;
			}
			set_proc_used( PROC_APC_UPS, 1 );
		}
	}

	print_dbg( DBG_LINE, 1, NULL );
	for ( i = 0 ; i < MAX_APC_UPS_DATA_CNT ; i++ )
	{
		if ( g_apc_ups_ai_val[i].snsr_id == 0 )
			break;
		print_dbg( DBG_SAVE, 1, "DB Data:: UPS AI Pos:%d, ID:%d, SNSR ID:%d, SNSR NO ;%d, SUB IDX:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, \
ALARM YN:%s, MIN :%.2f, MAX:%.2f, OFFSET:%.2f, DATA_POS:%d",
				i, g_apc_ups_ai_val[ i ].fcltid, g_apc_ups_ai_val[ i ].snsr_id, g_apc_ups_ai_val[ i ].snsr_no, g_apc_ups_ai_val[ i ].snsr_sub_idx, 
				g_apc_ups_ai_val[ i ].snsr_type ,g_apc_ups_ai_val[ i ].snsr_sub_type, g_apc_ups_ai_val[ i ].alarm_yn ,g_apc_ups_ai_val[ i ].min_val , 
				g_apc_ups_ai_val[ i ].max_val,g_apc_ups_ai_val[ i ].offset_val,g_apc_ups_ai_val[ i ].data_pos);
		print_dbg( DBG_NONE, 1, "DA_LOW:%.2f, WA_LOW:%.2f, CA_LOW:%.2f, CA_HIGH:%.2f, WA_HIGH:%.2f, DA_HIGH:%.2f",
				g_apc_ups_ai_val[ i ].range_val[ 0 ],g_apc_ups_ai_val[ i ].range_val[ 1 ],g_apc_ups_ai_val[ i ].range_val[ 2 ],
				g_apc_ups_ai_val[ i ].range_val[ 3 ],g_apc_ups_ai_val[ i ].range_val[ 4 ],g_apc_ups_ai_val[ i ].range_val[ 5 ] );
	}

	return ret;
}

static int set_pwr_dev_val( pwr_dev_val_t * ptrdev , int * ptrcnt )
{
	int dev_cnt = *ptrcnt ;
	int j;
	int mthod_cnt = 0;

	g_pwr_dev_val[ dev_cnt ].snsr_id 		= ptrdev->snsr_id;
	g_pwr_dev_val[ dev_cnt ].snsr_no 		= ptrdev->snsr_no;
	g_pwr_dev_val[ dev_cnt ].snsr_type 		= ptrdev->snsr_type;
	g_pwr_dev_val[ dev_cnt ].snsr_sub_idx 	= ptrdev->snsr_sub_idx;
	g_pwr_dev_val[ dev_cnt].snsr_sub_type 	= ptrdev->snsr_sub_type;
	g_pwr_dev_val[ dev_cnt ].snsr_comport 	= ptrdev->snsr_comport;						/* 전원제어 장치 직렬 포트 */

	mthod_cnt = ptrdev->pwr_mthod_mng.cnt;
	g_pwr_dev_val[ dev_cnt ].pwr_mthod_mng.cnt = mthod_cnt;

	for( j = 0 ; j < mthod_cnt ; j++ )
	{
		g_pwr_dev_val[ dev_cnt ].pwr_mthod_mng.dev[ j ].dev_pos = ptrdev->pwr_mthod_mng.dev[ j ].dev_pos ;
		g_pwr_dev_val[ dev_cnt ].pwr_mthod_mng.dev[ j ].comport = ptrdev->pwr_mthod_mng.dev[ j ].comport ;
	}
	dev_cnt++;
	*ptrcnt = dev_cnt;

	return ERR_SUCCESS;
}

static int load_pwr_dev_val( void )
{
	int ret = ERR_SUCCESS;
	pwr_dev_val_t pwr_dev;
	int dev_cnt = 0;
	int i, j, mthod_cnt;

	memset( &g_pwr_dev_val, 0, sizeof( g_pwr_dev_val ));

	/* 고정 전원 장치 검색 */
	memset( &pwr_dev , 0, sizeof( pwr_dev ));
	ret = load_pwr_dev_ctrl_db( ESNSRSUB_EQPFRE_POWER, &pwr_dev );
	if ( ret == ERR_SUCCESS )
	{
		set_pwr_dev_val( &pwr_dev, &dev_cnt );
	}

	/* 고정방탐 전원 장치 검색 */
	memset( &pwr_dev , 0, sizeof( pwr_dev ));
	ret = load_pwr_dev_ctrl_db( ESNSRSUB_EQPFDE_POWER, &pwr_dev );
	if ( ret == ERR_SUCCESS )
	{
		set_pwr_dev_val( &pwr_dev, &dev_cnt );
	}

	/* 준고정 전원 장치 검색 */
	memset( &pwr_dev , 0, sizeof( pwr_dev ));
	ret = load_pwr_dev_ctrl_db( ESNSRSUB_EQPSRE_POWER, &pwr_dev );
	if ( ret == ERR_SUCCESS )
	{
		set_pwr_dev_val( &pwr_dev, &dev_cnt );
	}
	
	for( i = 0 ; i < dev_cnt ; i++ )
	{
		if ( g_pwr_dev_val[ i ].snsr_id == 0 )
			break;

		print_dbg( DBG_LINE,1, NULL );

		mthod_cnt = g_pwr_dev_val[ i ].pwr_mthod_mng.cnt;
  
    if( mthod_cnt == 0 )
    {
      print_dbg( DBG_ERR, 1, "The use of the Power control device PORT does not exist !!!, SnsrID:%d, SiteID:%d, Snsr Sub Type:%d", 
                          g_pwr_dev_val[ i ].snsr_id, get_my_siteid_shm() ,g_pwr_dev_val[ i ].snsr_id );
    }

		print_dbg( DBG_SAVE, 1, "DB Data:: Power Control SNSR ID:%d, SNSR NO:%d, SNSR TYPE:%d, SNSR_SUB_TYPE:%d, COM PORT:%d, DEV_CNT:%d",
		g_pwr_dev_val[ i ].snsr_id, g_pwr_dev_val[ i ].snsr_no, g_pwr_dev_val[ i ].snsr_type, g_pwr_dev_val[ i ].snsr_sub_type,
		g_pwr_dev_val[ i ].snsr_comport ,mthod_cnt );
		for( j = 0 ; j < mthod_cnt ; j++ )
		{
			print_dbg( DBG_SAVE,1, "Power Control COM PORT:%d, Pos:%d", 
					               g_pwr_dev_val[ i ].pwr_mthod_mng.dev[ j ].comport, g_pwr_dev_val[ i ].pwr_mthod_mng.dev[ j ].dev_pos);
			
		}
	}

	print_dbg( DBG_LINE,1, NULL );

#if 0
	/* 센서 테이블로부터 전원 센서 정보를 가져온다. */
	/* 고정 장치 */
	g_pwr_dev_val[ 0 ].snsr_id 			= 59;
	g_pwr_dev_val[ 0 ].snsr_no 			= 0;
	g_pwr_dev_val[ 0 ].snsr_type 		= ESNSRTYP_DO;
	g_pwr_dev_val[ 0 ].snsr_sub_idx 	= 0;
	g_pwr_dev_val[ 0 ].snsr_sub_type 	= ESNSRSUB_EQPFRE_POWER;
	g_pwr_dev_val[ 0 ].snsr_comport 	= COM5;						/* 전원제어 장치 직렬 포트 */

	/* 센서 메소드 테이블에서 해당 센서의 전원제어 장치 정보를 가져온다. */
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].dev_pos = 0;			/* 안테나 제어 전원위치 */
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].comport= COM5;			/* 안테나 제어 전원위치 */
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].req_val = 0;
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].last_val= 0;
	cnt++;

	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].dev_pos = 1;			/* 고정 장치 전원 위치(SBC) */
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].comport= COM5;			/* 안테나 제어 전원위치 */
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].req_val = 0;
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].last_val= 0;
	cnt++;
	
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].dev_pos = 2;			/* SBC 대체 PC 전원 위치 */
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].comport= COM5;			/* 안테나 제어 전원위치 */
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].req_val = 0;
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.dev[ cnt ].last_val= 0;
	cnt++;
	g_pwr_dev_val[ 0 ].pwr_mthod_mng.cnt = cnt;
#endif

	return ERR_SUCCESS;
}

static int mapping_pwr_dev_and_pwr_c( void )
{
	int i,j;
	int dev_cnt =0;
	int dev_pos;

	/* pwr_c_data에 존재하는 최종값을 전원제어장치로 넣어준다 */
	for ( i = 0 ; i < MAX_PWR_DEV_CNT ; i++ )
	{
		if ( g_pwr_dev_val[ i ].snsr_comport == COM5 )
		{
			dev_cnt = g_pwr_dev_val[ i ].pwr_mthod_mng.cnt;

			for( j = 0 ; j< dev_cnt ; j++ )
			{
				dev_pos = g_pwr_dev_val[ i ].pwr_mthod_mng.dev[ j ].dev_pos;
				if ( dev_pos < MAX_PWR_C_PORT_CNT );
				{
					g_pwr_dev_val[ i ].pwr_mthod_mng.dev[ j ].last_val = g_pwr_c_data.val[ dev_pos ];
				}
			}
		}
	}

	return ERR_SUCCESS;
}

static int mapping_pwr_dev_and_doe( void )
{
	int i,j;
	int dev_cnt =0;
	int dev_pos;

	/* DOE 에 존재하는 최종값을 전원제어장치로 넣어준다 */
	for ( i = 0 ; i < MAX_PWR_DEV_CNT ; i++ )
	{
		if ( g_pwr_dev_val[ i ].snsr_comport == COM1 )
		{
			dev_cnt = g_pwr_dev_val[ i ].pwr_mthod_mng.cnt;

			for( j = 0 ; j< dev_cnt ; j++ )
			{
				dev_pos = g_pwr_dev_val[ i ].pwr_mthod_mng.dev[ j ].dev_pos;
				if ( dev_pos < MAX_GPIO_CNT );
				{
					g_pwr_dev_val[ i ].pwr_mthod_mng.dev[ j ].last_val = g_doe_val[ dev_pos ].last_val;
				}
			}
		}
	}
	return ERR_SUCCESS;
}

static int issend_alarm( UINT32 keep_time, time_t last_time )
{
	int ret = 0;
	time_t cur_time = time( NULL );
	UINT32 interv = 0;

	interv = cur_time - last_time;
	
	if ( keep_time  == 0 )
	{
		keep_time = 2;
		print_dbg( DBG_ERR,1, "Change of Alarm Duration Time 1min becase of Alarm Duration Time is 0" );
	}

	/* 분단위 */
	keep_time = ( keep_time * 60 );
	//print_dbg( DBG_NONE,1, "Alarm Duration Time is %d", keep_time );
	/* 최종 알람 전송 시간이 지속 시간을 넘을 경우 알람을 재 전송한다 */
	if ( interv >= keep_time )
	{
		ret = 1;
	}

	return ret ;
}

/* UPS 데이터의 변화가 있는 항목은 EVENT 메시지를 보낸다 */
static int check_mcu_event( void )
{
	int i;
	int last_val;
	int fault_cnt = 0;
	time_t cur_time;
	int last_sts =0;
	int good_val = 0;

	static volatile int mcu_evt_send_cnt = 50;
	fclt_evt_faultdi_t fault_di;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;
	UINT32 keep_time;
	time_t last_time;
	int send_alarm = 0;

	cur_time = time( NULL );
	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		last_val = g_di_val[ i ].last_val;
		last_sts = g_di_val[ i ].last_sts;
		good_val = g_di_val[ i ].good_val;
		keep_time  = g_di_val[ i ].alarm_keep_time;
		last_time  = g_di_val[ i ].alarm_last_time;

		send_alarm = 0;

		if ( last_val != good_val )
		{
			send_alarm = issend_alarm( keep_time, last_time );
		}

		/* 장애가 지속 시간 이후에도 발생 하고 있을 경우 장애 메시지를 보낸다 */
		if ( (last_sts != last_val ) || ( send_alarm == 1 ) )
		{
			if( fault_cnt < MAX_GRP_RSLT_DI )
			{
                if ( g_di_val[ i ].snsr_id > 0 &&  g_di_val[ i ].snsr_sub_type > 0 )
                {
                    fault_cnt = 0;

                    memset( &fault_di, 0, sizeof( fault_di ));
                    memset(&tid, 0, sizeof( tid ));
                    memset(&inter_msg, 0, sizeof( inter_msg ));

                    if ( mcu_evt_send_cnt++ > MAX_SEND_CNT )
                    {
                        mcu_evt_send_cnt = 1;
                    }
                    /* make tid */
                    tid.cur_time 	= cur_time;
                    tid.siteid 		= get_my_siteid_shm();
                    tid.sens_type 	= ESNSRTYP_DI;
                    tid.seq 		= mcu_evt_send_cnt;

                    cnvt_fclt_tid( &tid );

                    /* fcltelem */
                    fault_di.fault_aidi.tfcltelem.nsiteid 	= get_my_siteid_shm();
                    fault_di.fault_aidi.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
                    fault_di.fault_aidi.tfcltelem.efclt 	= EFCLT_RTU;

                    /* transdbdata */
                    fault_di.fault_aidi.tdbtans.tdatetime= (UINT32)cur_time;
                    memcpy( fault_di.fault_aidi.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );


                    fault_di.rslt[ fault_cnt ].esnsrtype 	= g_di_val[ i ].snsr_type ;
                    fault_di.rslt[ fault_cnt ].esnsrsub 	= g_di_val[ i ].snsr_sub_type;
                    fault_di.rslt[ fault_cnt ].idxsub 		= g_di_val[ i ].snsr_sub_idx;

                    if ( good_val != last_val )
                    {
                        fault_di.rslt[ fault_cnt ].egrade		= g_di_val[ i ].grade;
                    }
                    else
                    {
                        fault_di.rslt[ fault_cnt ].egrade		= EFCLTGRADE_NORMAL;
                    }

                    fault_di.rslt[ fault_cnt ].ecnnstatus 	= g_mcu_sr_timeout;
                    if ( g_mcu_sr_timeout ==  ESNSRCNNST_ERROR )
                    {
                        fault_di.rslt[ fault_cnt ].brslt		= DI_UN_VAL;
                        fault_di.rslt[ fault_cnt ].egrade		= EFCLTGRADE_UNKNOWN;

                    }
                    else
                    {
                        fault_di.rslt[ fault_cnt ].brslt		= g_di_val[ i ].last_val;

                        if ( fault_di.rslt[ fault_cnt ].brslt == good_val )
                        {
                            memcpy( fault_di.rslt[ fault_cnt ].slabel01, g_di_val[ i ].szlabel1, SZ_MAX_LABEL );
                        }
                        else
                        {
                            memcpy( fault_di.rslt[ fault_cnt ].slabel01, g_di_val[ i ].szlabel0, SZ_MAX_LABEL );
                        }
                    }

                    inter_msg.fault_snsr_id[ fault_cnt ] = g_di_val[ i ].snsr_id;

                    fault_cnt++;
                    print_dbg( DBG_SAVE,1, "Warning !! DI Event_SNSR_ID:%d, Grade:%d, cnt:%d", g_di_val[ i ].snsr_id ,fault_di.rslt[ fault_cnt ].egrade, fault_cnt );
                    g_di_val[ i ].last_sts = last_val;
					
					if ( fault_cnt > 0 )
					{
						fault_di.fault_aidi.nfcltsubcount = fault_cnt;

						/* intr msg */
						cmd = EFT_SNSREVT_FAULT;
						inter_msg.client_id	= 0;
						inter_msg.msg 		= cmd;
						inter_msg.ptrbudy 	= &fault_di;

						/* send transfer */
						send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

						/* 알람 전송 시간 설정 */
						if ( send_alarm == 1 )
						{
							g_di_val[ i ].alarm_last_time = cur_time;
							print_dbg( DBG_INFO, 1, "######## Send of Fault DI Alarm :%u", cur_time );
						}
						else
						{
							g_di_val[ i ].alarm_last_time = 0;
						}

						sys_sleep( 100 );
					}
                }
			}
		}
	}

	/* DB 등록 이벤트 등록 */

	return ERR_SUCCESS;
}

/* Temp 데이터 변화가 있는 항목은 Event 메시지 보낸다 */
static int check_temp_event( void )
{
	int i,j;
	float range_val[ MAX_RANG_CNT ];
	float last_val;
	//float offset_val;

	int fault_cnt = 0;
	time_t cur_time;
	static volatile int temp_evt_send_cnt = 100;
	fclt_evt_faultai_t fault_ai;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;
	int range;
	int last_sts;
	UINT32 keep_time;
	time_t last_time;
	int send_alarm = 0;

	cur_time = time( NULL );

	for( i = 0 ; i < MAX_TEMP_CNT ; i++ )
	{
		memset( range_val, 0, sizeof( range_val ));
        if ( g_temp_val[ i ].snsr_id > 0 &&  g_temp_val[ i ].snsr_sub_type > 0 )
        {
            fault_cnt =0;

            memset( &fault_ai, 0, sizeof( fault_ai ));
            memset(&tid, 0, sizeof( tid ));
            memset(&inter_msg, 0, sizeof( inter_msg ));


            if ( temp_evt_send_cnt++ > MAX_SEND_CNT )
            {
                temp_evt_send_cnt = 1;
            }
            /* make tid */
            tid.cur_time 	= cur_time;
            tid.siteid 		= get_my_siteid_shm();
            tid.sens_type 	= ESNSRTYP_AI;
            tid.seq 		= temp_evt_send_cnt;

            cnvt_fclt_tid( &tid );

            /* fcltelem */
            fault_ai.fault_aidi.tfcltelem.nsiteid 	= get_my_siteid_shm();
            fault_ai.fault_aidi.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
            fault_ai.fault_aidi.tfcltelem.efclt 	= EFCLT_RTU;

            /* transdbdata */
            fault_ai.fault_aidi.tdbtans.tdatetime= (UINT32)cur_time;
            memcpy( fault_ai.fault_aidi.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );


            for( j = 0 ; j< MAX_RANG_CNT ;j++ )
            {
                range_val[ j ] = g_temp_val[ i ].range_val[ j ];
            }

            last_val = g_temp_val[ i ].last_val;
            last_sts  = g_temp_val[ i ].last_sts;

			keep_time  = g_temp_val[ i ].alarm_keep_time;
			last_time  = g_temp_val[ i ].alarm_last_time;

            if( last_val < range_val[ 0 ] || last_val > range_val[ 5 ])
            {
                range = EFCLTGRADE_DANGER;
            }
            else if( last_val < range_val[ 1 ] || last_val > range_val[ 4 ] )
            {
                range = EFCLTGRADE_WARNING;
            }
            else if( last_val < range_val[ 2 ] || last_val > range_val[ 3 ] )
            {
                range = EFCLTGRADE_CAUTION;
            }
            else
            {
                range = EFCLTGRADE_NORMAL;
            }
			
			send_alarm = 0;

			if ( range != EFCLTGRADE_NORMAL )
			{
				send_alarm = issend_alarm(keep_time, last_time );
			}

            if ( last_sts != range || send_alarm == 1 )
            {
                if( fault_cnt < MAX_GRP_RSLT_AI )
                {
                    fault_ai.rslt[ fault_cnt ].esnsrtype 	= g_temp_val[ i ].snsr_type ;
                    fault_ai.rslt[ fault_cnt ].esnsrsub 	= g_temp_val[ i ].snsr_sub_type;
                    fault_ai.rslt[ fault_cnt ].idxsub 		= g_temp_val[ i ].snsr_sub_idx;
                    fault_ai.rslt[ fault_cnt ].egrade		= range;
                    fault_ai.rslt[ fault_cnt ].ecnnstatus 	= g_temp_sr_timeout;
                    if ( g_temp_sr_timeout == ESNSRCNNST_ERROR )
                    {
                        fault_ai.rslt[ fault_cnt ].frslt		= DI_UN_VAL;
                        fault_ai.rslt[ fault_cnt ].egrade		= EFCLTGRADE_UNKNOWN;

                    }
                    else
                    {
                        fault_ai.rslt[ fault_cnt ].frslt		= g_temp_val[ i ].last_val;
                    }
                    inter_msg.fault_snsr_id[ fault_cnt ] = g_temp_val[ i ].snsr_id;

                    fault_cnt++;
                    g_temp_val[ i ].last_sts = range;

                    print_dbg( DBG_SAVE,1, "Warning !! AI TEMP Event_SNSR_ID:%d, Grade:%d , cnt:%d, ", g_temp_val[ i ].snsr_id  ,fault_ai.rslt[ fault_cnt ].egrade, fault_cnt );
                }

                if ( fault_cnt > 0 )
                {
                    fault_ai.fault_aidi.nfcltsubcount = fault_cnt;

                    /* intr msg */
                    cmd = EFT_SNSREVT_FAULT;
                    inter_msg.client_id	= 0;
                    inter_msg.msg 		= cmd;
                    inter_msg.ptrbudy 	= &fault_ai;

                    /* send transfer */
                    send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

					/* 알람 전송 시간을 설정한다 */
					if ( send_alarm == 1 )
					{
						g_temp_val[ i ].alarm_last_time = cur_time;
						print_dbg( DBG_INFO, 1, "######## Send of Fault Temp Alarm :%u", cur_time );
					}
					else
					{
						g_temp_val[ i ].alarm_last_time = 0;
					}

                    sys_sleep( 100 );

                }

            }
        }
	}

	/* DB 등록 이벤트 등록 */
	return ERR_SUCCESS;
}

/* pwr c 데이터 변화가 있는 항목은 Event 메시지 보낸다 */
#if 0
static int check_pwr_c_event( void )
{
	return ERR_SUCCESS;
}
#endif

/* pwr m 데이터 변화가 있는 항목은 Event 메시지 보낸다 */
static int check_pwr_m_event( void )
{
	int i,j;
	float range_val[ MAX_RANG_CNT ];
	float last_val;
	//float offset_val;

	int fault_cnt = 0;
	time_t cur_time;
	static volatile int pwr_m_evt_send_cnt = 150;
	fclt_evt_faultai_t fault_ai;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;
	int range;
	int last_sts ;
	UINT32 keep_time;
	time_t last_time;
	int send_alarm = 0;

	cur_time = time( NULL );
	for( i = 0 ; i < MAX_PWR_M_CNT ; i++ )
	{
		memset( range_val, 0, sizeof( range_val ));
        if ( g_pwr_m_val[ i ].snsr_id > 0 &&  g_pwr_m_val[ i ].snsr_sub_type > 0 )
        {
            fault_cnt =0;

            memset( &fault_ai, 0, sizeof( fault_ai ));
            memset(&tid, 0, sizeof( tid ));
            memset(&inter_msg, 0, sizeof( inter_msg ));

            if ( pwr_m_evt_send_cnt++ > MAX_SEND_CNT )
            {
                pwr_m_evt_send_cnt = 1;
            }
            /* make tid */
            tid.cur_time 	= cur_time;
            tid.siteid 		= get_my_siteid_shm();
            tid.sens_type 	= ESNSRTYP_AI;
            tid.seq 		= pwr_m_evt_send_cnt;

            cnvt_fclt_tid( &tid );

            /* fcltelem */
            fault_ai.fault_aidi.tfcltelem.nsiteid 	= get_my_siteid_shm();
            fault_ai.fault_aidi.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
            fault_ai.fault_aidi.tfcltelem.efclt 	= EFCLT_RTU;

            /* transdbdata */
            fault_ai.fault_aidi.tdbtans.tdatetime= (UINT32)cur_time;
            memcpy( fault_ai.fault_aidi.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );


            for( j = 0 ; j< MAX_RANG_CNT ;j++ )
            {
                range_val[ j ] = g_pwr_m_val[ i ].range_val[ j ];
            }

            last_val = g_pwr_m_val[ i ].last_val;
            last_sts = g_pwr_m_val[ i ].last_sts;

			keep_time  = g_pwr_m_val[ i ].alarm_keep_time;
			last_time  = g_pwr_m_val[ i ].alarm_last_time;

            if( last_val < range_val[ 0 ] || last_val > range_val[ 5 ])
            {
                range = EFCLTGRADE_DANGER;
            }
            else if( last_val < range_val[ 1 ] || last_val > range_val[ 4 ] )
            {
                range = EFCLTGRADE_WARNING;
            }
            else if( last_val < range_val[ 2 ] || last_val > range_val[ 3 ] )
            {
                range = EFCLTGRADE_CAUTION;
            }
            else
            {
                range = EFCLTGRADE_NORMAL;
            }
			
			send_alarm = 0;

			if ( range != EFCLTGRADE_NORMAL )
			{
				send_alarm = issend_alarm(keep_time, last_time );
			}

            if ( last_sts != range || send_alarm == 1 )
            {
                if( fault_cnt < MAX_GRP_RSLT_AI )
                {
                    fault_ai.rslt[ fault_cnt ].esnsrtype 	= g_pwr_m_val[ i ].snsr_type ;
                    fault_ai.rslt[ fault_cnt ].esnsrsub 	= g_pwr_m_val[ i ].snsr_sub_type;
                    fault_ai.rslt[ fault_cnt ].idxsub 		= g_pwr_m_val[ i ].snsr_sub_idx;
                    fault_ai.rslt[ fault_cnt ].ecnnstatus 	= g_pwr_m_sr_timeout;
                    if( g_pwr_m_sr_timeout == ESNSRCNNST_ERROR )
                    {
                        fault_ai.rslt[ fault_cnt ].frslt		= DI_UN_VAL;
                        fault_ai.rslt[ fault_cnt ].egrade		= EFCLTGRADE_UNKNOWN;

                    }
                    else
                    {
                        fault_ai.rslt[ fault_cnt ].frslt		= g_pwr_m_val[ i ].last_val;
                        fault_ai.rslt[ fault_cnt ].egrade		= range;
                    }
                    inter_msg.fault_snsr_id[ fault_cnt ] = g_pwr_m_val[ i ].snsr_id;

                    fault_cnt++;
                    g_pwr_m_val[ i ].last_sts = range;
                    print_dbg( DBG_SAVE,1, "Warning !! AI PWR M Event_SNSR_ID:%d, Grade:%d, Cnt:%d", g_pwr_m_val[ i ].snsr_id , fault_ai.rslt[ fault_cnt ].egrade, fault_cnt );
                }

                if ( fault_cnt > 0 )
                {
                    fault_ai.fault_aidi.nfcltsubcount = fault_cnt;

                    /* intr msg */
                    cmd = EFT_SNSREVT_FAULT;
                    inter_msg.client_id	= 0;
                    inter_msg.msg 		= cmd;
                    inter_msg.ptrbudy 	= &fault_ai;

                    /* send transfer */
                    send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

					if ( send_alarm == 1 )
					{
						g_pwr_m_val[ i ].alarm_last_time = cur_time;
						print_dbg( DBG_INFO, 1, "######## Send of Fault PWR M Alarm :%u", cur_time );
					}
					else
						g_pwr_m_val[ i ].alarm_last_time = 0;

                    sys_sleep( 100 );
                }

            }
        }
	}

	/* DB 등록 이벤트 등록 */

	return ERR_SUCCESS;
}

static int check_ground_event( void )
{
	int last_val;
	int fault_cnt = 0;
	time_t cur_time;
	static volatile int ground_evt_send_cnt = 200;
	fclt_evt_faultdi_t fault_di;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;
	int last_sts ;
	int good_val;
	UINT32 keep_time;
	time_t last_time;
	int send_alarm = 0;

	cur_time = time( NULL );
	memset( &fault_di, 0, sizeof( fault_di ));
	memset(&tid, 0, sizeof( tid ));
	memset(&inter_msg, 0, sizeof( inter_msg ));

	
	if ( ground_evt_send_cnt++ > MAX_SEND_CNT )
	{
		ground_evt_send_cnt = 1;
	}
	/* make tid */
	tid.cur_time 	= cur_time;
	tid.siteid 		= get_my_siteid_shm();
	tid.sens_type 	= ESNSRTYP_DI;
	tid.seq 		= ground_evt_send_cnt;

	cnvt_fclt_tid( &tid );

	/* fcltelem */
	fault_di.fault_aidi.tfcltelem.nsiteid 	= get_my_siteid_shm();
	fault_di.fault_aidi.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
	fault_di.fault_aidi.tfcltelem.efclt 	= EFCLT_RTU;

	/* transdbdata */
	fault_di.fault_aidi.tdbtans.tdatetime= (UINT32)cur_time;
	memcpy( fault_di.fault_aidi.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );

	last_val = g_ground_val.last_val;
	last_sts = g_ground_val.last_sts; 
	good_val = g_ground_val.good_val; 

	keep_time  = g_ground_val.alarm_keep_time;
	last_time  = g_ground_val.alarm_last_time;

	send_alarm = 0;

	if ( last_val != good_val )
	{
		send_alarm = issend_alarm(keep_time, last_time );
	}

	if ( last_val != last_sts || send_alarm == 1 )
	{
        if ( g_ground_val.snsr_id > 0 &&  g_ground_val.snsr_sub_type > 0 )
        {
			fault_cnt = 0;

            fault_di.rslt[ fault_cnt ].esnsrtype 	= g_ground_val.snsr_type ;
            fault_di.rslt[ fault_cnt ].esnsrsub 	= g_ground_val.snsr_sub_type;
            fault_di.rslt[ fault_cnt ].idxsub 		= g_ground_val.snsr_sub_idx;
            if ( good_val != last_val )
            {
                fault_di.rslt[ fault_cnt ].egrade		= g_ground_val.grade;
            }
            else
            {
                fault_di.rslt[ fault_cnt ].egrade		= EFCLTGRADE_NORMAL;
            }

            fault_di.rslt[ fault_cnt ].ecnnstatus 	= g_pwr_m_sr_timeout;
            if ( g_pwr_m_sr_timeout == ESNSRCNNST_ERROR )
            {
                fault_di.rslt[ fault_cnt ].brslt		= DI_UN_VAL;
                fault_di.rslt[ fault_cnt ].egrade		= EFCLTGRADE_UNKNOWN;

            }
            else
            {
                fault_di.rslt[ fault_cnt ].brslt		= g_ground_val.last_val;
                if ( fault_di.rslt[ fault_cnt ].brslt == good_val  )
                {
                    memcpy( fault_di.rslt[ fault_cnt ].slabel01, g_ground_val.szlabel1, SZ_MAX_LABEL );
                }
                else
                {
                    memcpy( fault_di.rslt[ fault_cnt ].slabel01, g_ground_val.szlabel0, SZ_MAX_LABEL );
                }

            }
            inter_msg.fault_snsr_id[ fault_cnt ] = g_ground_val.snsr_id;

            fault_cnt++;
            g_ground_val.last_sts = last_val;
            print_dbg( DBG_SAVE,1, "Warning !! Ground Event Grade:%d",  fault_di.rslt[ fault_cnt ].egrade);

			if ( fault_cnt > 0 )
			{
				fault_di.fault_aidi.nfcltsubcount = fault_cnt;

				/* intr msg */
				cmd = EFT_SNSREVT_FAULT;
				inter_msg.client_id	= 0;
				inter_msg.msg 		= cmd;
				inter_msg.ptrbudy 	= &fault_di;

				/* send transfer */
				send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

				if( send_alarm == 1 )
				{
					g_ground_val.alarm_last_time = cur_time;
					print_dbg( DBG_INFO, 1, "######## Send of Fault GROUND Alarm :%u", cur_time );

				}
				else
					g_ground_val.alarm_last_time = 0;
			}
        }
	}
	
	/* DB 등록 이벤트 등록 */
	return ERR_SUCCESS;
}

/* remote 데이터 변화가 있는 항목은 Event 메시지 보낸다 */
static int check_remote_event( void )
{
	return ERR_SUCCESS;
}

static int check_apc_ups_di_event( void )
{
	int i;
	int last_val;
	int fault_cnt = 0;
	time_t cur_time;
	int last_sts =0;
	int good_val = 0;

	static volatile int ups_evt_send_cnt = 50;
	fclt_evt_faultdi_t fault_di;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;
	UINT32 keep_time;
	time_t last_time;
	int send_alarm = 0;

	cur_time = time( NULL );
	for( i = 0 ; i < MAX_APC_UPS_DATA_CNT ; i++ )
	{
		last_val = g_apc_ups_di_val[ i ].last_val;
		last_sts = g_apc_ups_di_val[ i ].last_sts;
		good_val = g_apc_ups_di_val[ i ].good_val;
		keep_time  = g_apc_ups_di_val[ i ].alarm_keep_time;
		last_time  = g_apc_ups_di_val[ i ].alarm_last_time;

		send_alarm = 0;

		if ( last_val != good_val )
		{
			send_alarm = issend_alarm( keep_time, last_time );
		}

		/* 장애가 지속 시간 이후에도 발생 하고 있을 경우 장애 메시지를 보낸다 */
		if ( (last_sts != last_val ) || ( send_alarm == 1 ) )
		{
			if( fault_cnt < MAX_GRP_RSLT_DI )
			{
                if ( g_apc_ups_di_val[ i ].snsr_id > 0 &&  g_apc_ups_di_val[ i ].snsr_sub_type > 0 )
                {
                    fault_cnt = 0;

                    memset( &fault_di, 0, sizeof( fault_di ));
                    memset(&tid, 0, sizeof( tid ));
                    memset(&inter_msg, 0, sizeof( inter_msg ));

                    if ( ups_evt_send_cnt++ > MAX_SEND_CNT )
                    {
                        ups_evt_send_cnt = 1;
                    }
                    /* make tid */
                    tid.cur_time 	= cur_time;
                    tid.siteid 		= get_my_siteid_shm();
                    tid.sens_type 	= ESNSRTYP_DI;
                    tid.seq 		= ups_evt_send_cnt;

                    cnvt_fclt_tid( &tid );

                    /* fcltelem */
                    fault_di.fault_aidi.tfcltelem.nsiteid 	= get_my_siteid_shm();
                    fault_di.fault_aidi.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
                    fault_di.fault_aidi.tfcltelem.efclt 	= EFCLT_RTU;

                    /* transdbdata */
                    fault_di.fault_aidi.tdbtans.tdatetime= (UINT32)cur_time;
                    memcpy( fault_di.fault_aidi.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );


                    fault_di.rslt[ fault_cnt ].esnsrtype 	= g_apc_ups_di_val[ i ].snsr_type ;
                    fault_di.rslt[ fault_cnt ].esnsrsub 	= g_apc_ups_di_val[ i ].snsr_sub_type;
                    fault_di.rslt[ fault_cnt ].idxsub 		= g_apc_ups_di_val[ i ].snsr_sub_idx;

                    if ( good_val != last_val )
                    {
                        fault_di.rslt[ fault_cnt ].egrade		= g_apc_ups_di_val[ i ].grade;
                    }
                    else
                    {
                        fault_di.rslt[ fault_cnt ].egrade		= EFCLTGRADE_NORMAL;
                    }

                    fault_di.rslt[ fault_cnt ].ecnnstatus 	= g_mcu_sr_timeout;
                    if ( g_mcu_sr_timeout ==  ESNSRCNNST_ERROR )
                    {
                        fault_di.rslt[ fault_cnt ].brslt		= DI_UN_VAL;
                        fault_di.rslt[ fault_cnt ].egrade		= EFCLTGRADE_UNKNOWN;

                    }
                    else
                    {
                        fault_di.rslt[ fault_cnt ].brslt		= g_apc_ups_di_val[ i ].last_val;

                        if ( fault_di.rslt[ fault_cnt ].brslt == good_val )
                        {
                            memcpy( fault_di.rslt[ fault_cnt ].slabel01, g_apc_ups_di_val[ i ].szlabel1, SZ_MAX_LABEL );
                        }
                        else
                        {
                            memcpy( fault_di.rslt[ fault_cnt ].slabel01, g_apc_ups_di_val[ i ].szlabel0, SZ_MAX_LABEL );
                        }
                    }

                    inter_msg.fault_snsr_id[ fault_cnt ] = g_apc_ups_di_val[ i ].snsr_id;

                    fault_cnt++;
                    print_dbg( DBG_SAVE,1, "Warning !! APC UPS Event_SNSR_ID:%d, Grade:%d, cnt:%d", g_apc_ups_di_val[ i ].snsr_id ,fault_di.rslt[ fault_cnt ].egrade, fault_cnt );
                    g_apc_ups_di_val[ i ].last_sts = last_val;
					
					if ( fault_cnt > 0 )
					{
						fault_di.fault_aidi.nfcltsubcount = fault_cnt;

						/* intr msg */
						cmd = EFT_SNSREVT_FAULT;
						inter_msg.client_id	= 0;
						inter_msg.msg 		= cmd;
						inter_msg.ptrbudy 	= &fault_di;

						/* send transfer */
						send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

						/* 알람 전송 시간 설정 */
						if ( send_alarm == 1 )
						{
							g_apc_ups_di_val[ i ].alarm_last_time = cur_time;
							print_dbg( DBG_INFO, 1, "######## Send of Fault APC UPS Alarm :%u", cur_time );
						}
						else
						{
							g_apc_ups_di_val[ i ].alarm_last_time = 0;
						}

						sys_sleep( 100 );
					}
                }
			}
		}
	}

	/* DB 등록 이벤트 등록 */

	return ERR_SUCCESS;
}

static int check_apc_ups_ai_event( void )
{
	int i,j;
	float range_val[ MAX_RANG_CNT ];
	float last_val;
	//float offset_val;

	int fault_cnt = 0;
	time_t cur_time;
	static volatile int apc_ups_ai_evt_send_cnt = 150;
	fclt_evt_faultai_t fault_ai;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;
	int range;
	int last_sts ;
	UINT32 keep_time;
	time_t last_time;
	int send_alarm = 0;

	cur_time = time( NULL );
	for( i = 0 ; i < MAX_PWR_M_CNT ; i++ )
	{
		memset( range_val, 0, sizeof( range_val ));
        if ( g_apc_ups_ai_val[ i ].snsr_id > 0 &&  g_apc_ups_ai_val[ i ].snsr_sub_type > 0 && g_apc_ups_ai_val[ i ].last_val >= 0 )
        {
            fault_cnt =0;

            memset( &fault_ai, 0, sizeof( fault_ai ));
            memset(&tid, 0, sizeof( tid ));
            memset(&inter_msg, 0, sizeof( inter_msg ));

            if ( apc_ups_ai_evt_send_cnt++ > MAX_SEND_CNT )
            {
                apc_ups_ai_evt_send_cnt = 1;
            }
            /* make tid */
            tid.cur_time 	= cur_time;
            tid.siteid 		= get_my_siteid_shm();
            tid.sens_type 	= ESNSRTYP_AI;
            tid.seq 		= apc_ups_ai_evt_send_cnt;

            cnvt_fclt_tid( &tid );

            /* fcltelem */
            fault_ai.fault_aidi.tfcltelem.nsiteid 	= get_my_siteid_shm();
            fault_ai.fault_aidi.tfcltelem.nfcltid 	= get_my_rtu_fcltid_shm();;
            fault_ai.fault_aidi.tfcltelem.efclt 	= EFCLT_RTU;

            /* transdbdata */
            fault_ai.fault_aidi.tdbtans.tdatetime= (UINT32)cur_time;
            memcpy( fault_ai.fault_aidi.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );


            for( j = 0 ; j< MAX_RANG_CNT ;j++ )
            {
                range_val[ j ] = g_apc_ups_ai_val[ i ].range_val[ j ];
            }

            last_val = g_apc_ups_ai_val[ i ].last_val;
            last_sts = g_apc_ups_ai_val[ i ].last_sts;

			keep_time  = g_apc_ups_ai_val[ i ].alarm_keep_time;
			last_time  = g_apc_ups_ai_val[ i ].alarm_last_time;

            if( last_val < range_val[ 0 ] || last_val > range_val[ 5 ])
            {
                range = EFCLTGRADE_DANGER;
            }
            else if( last_val < range_val[ 1 ] || last_val > range_val[ 4 ] )
            {
                range = EFCLTGRADE_WARNING;
            }
            else if( last_val < range_val[ 2 ] || last_val > range_val[ 3 ] )
            {
                range = EFCLTGRADE_CAUTION;
            }
            else
            {
                range = EFCLTGRADE_NORMAL;
            }
			
			send_alarm = 0;

			if ( range != EFCLTGRADE_NORMAL )
			{
				send_alarm = issend_alarm(keep_time, last_time );
			}

            if ( last_sts != range || send_alarm == 1 )
            {
                if( fault_cnt < MAX_GRP_RSLT_AI )
                {
                    fault_ai.rslt[ fault_cnt ].esnsrtype 	= g_apc_ups_ai_val[ i ].snsr_type ;
                    fault_ai.rslt[ fault_cnt ].esnsrsub 	= g_apc_ups_ai_val[ i ].snsr_sub_type;
                    fault_ai.rslt[ fault_cnt ].idxsub 		= g_apc_ups_ai_val[ i ].snsr_sub_idx;
                    fault_ai.rslt[ fault_cnt ].ecnnstatus 	= g_apc_ups_sr_timeout;
                    if( g_apc_ups_sr_timeout == ESNSRCNNST_ERROR )
                    {
                        fault_ai.rslt[ fault_cnt ].frslt		= DI_UN_VAL;
                        fault_ai.rslt[ fault_cnt ].egrade		= EFCLTGRADE_UNKNOWN;

                    }
                    else
                    {
                        fault_ai.rslt[ fault_cnt ].frslt		= g_apc_ups_ai_val[ i ].last_val;
                        fault_ai.rslt[ fault_cnt ].egrade		= range;
                    }
                    inter_msg.fault_snsr_id[ fault_cnt ] = g_apc_ups_ai_val[ i ].snsr_id;

                    fault_cnt++;
                    g_apc_ups_ai_val[ i ].last_sts = range;
                    print_dbg( DBG_SAVE,1, "Warning !! AI APC UPS Event_SNSR_ID:%d, Grade:%d, Cnt:%d", g_apc_ups_ai_val[ i ].snsr_id , fault_ai.rslt[ fault_cnt ].egrade, fault_cnt );
                }

                if ( fault_cnt > 0 )
                {
                    fault_ai.fault_aidi.nfcltsubcount = fault_cnt;

                    /* intr msg */
                    cmd = EFT_SNSREVT_FAULT;
                    inter_msg.client_id	= 0;
                    inter_msg.msg 		= cmd;
                    inter_msg.ptrbudy 	= &fault_ai;

                    /* send transfer */
                    send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

					if ( send_alarm == 1 )
					{
						g_apc_ups_ai_val[ i ].alarm_last_time = cur_time;
						print_dbg( DBG_INFO, 1, "######## Send of Fault PWR M Alarm :%u", cur_time );
					}
					else
						g_apc_ups_ai_val[ i ].alarm_last_time = 0;

                    sys_sleep( 100 );
                }

            }
        }
	}

	/* DB 등록 이벤트 등록 */
	return ERR_SUCCESS;
}

static int check_radio_data_event( volatile int *ptrsend_cnt, radio_val_manager_t  *ptrradio_mng, int fclt_code, int tcp_sts, char * ptrname )
{
	int i;
	int last_val;
	int fault_cnt = 0;
	time_t cur_time;
	fclt_evt_faultdi_t fault_di;
	inter_msg_t inter_msg;
	tid_t tid;
	UINT16 cmd ;
	int send_cnt = *ptrsend_cnt;
	int last_sts;
	int good_val ;
    fclt_info_t * ptrfclt = NULL;
	UINT32 keep_time;
	time_t last_time;
	int send_alarm = 0;

	cur_time = time( NULL );

	for( i = 0 ; i < MAX_RADIO_SNS_CNT ; i++ )
	{
		/* sensor type 2 : 전원제어 는 상태 체크 하지 않는다 */
		if ( (ptrradio_mng->radio_val[ i ].snsr_id > 0) && (ptrradio_mng->radio_val[ i ].snsr_sub_type > 0 ) && (ptrradio_mng->radio_val[ i ].snsr_type != 2 ))
		{
            fault_cnt =0;

            memset( &fault_di, 0, sizeof( fault_di ));
            memset(&tid, 0, sizeof( tid ));
            memset(&inter_msg, 0, sizeof( inter_msg ));

            if ( send_cnt++ > MAX_SEND_CNT )
            {
                send_cnt = 1;
            }
            *ptrsend_cnt = send_cnt;

            /* make tid */
            tid.cur_time 	= cur_time;
            tid.siteid 		= get_my_siteid_shm();
            tid.sens_type 	= ESNSRTYP_DI;
            tid.seq 		= send_cnt;

            cnvt_fclt_tid( &tid );

            ptrfclt = get_fclt_withcode( fclt_code );
            if ( ptrfclt == NULL )
            {
                print_dbg( DBG_ERR,1, "not find sts [%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
                continue;
            }

            /* fcltelem */
            fault_di.fault_aidi.tfcltelem.nsiteid 	= get_my_siteid_shm();
            fault_di.fault_aidi.tfcltelem.nfcltid 	= ptrfclt->fcltid;;
            fault_di.fault_aidi.tfcltelem.efclt 	= ptrfclt->fcltcode;

            /* transdbdata */
            fault_di.fault_aidi.tdbtans.tdatetime= (UINT32)cur_time;
            memcpy( fault_di.fault_aidi.tdbtans.sdbfclt_tid , tid.szdata, MAX_DBFCLT_TID );


			last_val = ptrradio_mng->radio_val[ i ].last_val;
			last_sts = ptrradio_mng->radio_val[ i ].last_sts; 
			good_val = ptrradio_mng->radio_val[ i ].good_val;

			keep_time  = ptrradio_mng->radio_val[ i ].alarm_keep_time;
			last_time  = ptrradio_mng->radio_val[ i ].alarm_last_time;

			send_alarm = 0;

			if ( last_val != good_val )
			{
				send_alarm = issend_alarm(keep_time, last_time );
			}

			if ( last_sts != last_val || send_alarm == 1 )
			{
				if( fault_cnt < MAX_GRP_RSLT_DI )
				{
					fault_di.rslt[ fault_cnt ].esnsrtype 	= ptrradio_mng->radio_val[ i ].snsr_type ;
					fault_di.rslt[ fault_cnt ].esnsrsub 	= ptrradio_mng->radio_val[ i ].snsr_sub_type;
					fault_di.rslt[ fault_cnt ].idxsub 		= ptrradio_mng->radio_val[ i ].snsr_sub_idx;
					if ( good_val != last_val )
					{
						fault_di.rslt[ fault_cnt ].egrade		= ptrradio_mng->radio_val[ i ].grade;
					}
					else
					{
						fault_di.rslt[ fault_cnt ].egrade		= EFCLTGRADE_NORMAL;
					}
					fault_di.rslt[ fault_cnt ].ecnnstatus 	= tcp_sts;
                    if( tcp_sts == ESNSRCNNST_ERROR )
                    {
					    fault_di.rslt[ fault_cnt ].brslt		= DI_UN_VAL;
                        fault_di.rslt[ fault_cnt ].egrade		= EFCLTGRADE_UNKNOWN;
                    }
                    else
                    {
					    fault_di.rslt[ fault_cnt ].brslt		= ptrradio_mng->radio_val[ i ].last_val;
                        if ( fault_di.rslt[ fault_cnt ].brslt == good_val )
                        {
                            memcpy( fault_di.rslt[ fault_cnt ].slabel01, ptrradio_mng->radio_val[ i ].szlabel1, SZ_MAX_LABEL );
                        }
                        else
                        {
                            memcpy( fault_di.rslt[ fault_cnt ].slabel01, ptrradio_mng->radio_val[ i ].szlabel0, SZ_MAX_LABEL );
                        }

                    }
                    inter_msg.fault_snsr_id[ fault_cnt ] = ptrradio_mng->radio_val[ i ].snsr_id;

					fault_cnt++;
#if 0
                    printf("................radio, snsr_type:%d...sub_type:%d....sub_idx:%d...val:%d......\r\n", ptrradio_mng->radio_val[ i ].snsr_type,
                              ptrradio_mng->radio_val[ i ].snsr_sub_type,ptrradio_mng->radio_val[ i ].snsr_sub_idx,ptrradio_mng->radio_val[ i ].last_val );
#endif
					ptrradio_mng->radio_val[ i ].last_sts	= last_val;
					print_dbg( DBG_SAVE,1, "Warning !! %s RADIO Event_SNSR_ID:%d, Grade:%d, cnt:%d", ptrname,  ptrradio_mng->radio_val[ i ].snsr_id , fault_di.rslt[ fault_cnt ].egrade,  fault_cnt );

                    if ( fault_cnt > 0 )
                    {
                        fault_di.fault_aidi.nfcltsubcount = fault_cnt;

                        /* intr msg */
                        cmd = EFT_EQPEVT_FAULT;
                        inter_msg.client_id	= 0;
                        inter_msg.msg 		= cmd;
                        inter_msg.ptrbudy 	= &fault_di;

                        /* send transfer */
                        send_data_transfer( cmd, (void *)&inter_msg , SEND_FMS  );

						if ( send_alarm == 1 )
						{
							ptrradio_mng->radio_val[ i ].alarm_last_time = cur_time;
							print_dbg( DBG_INFO, 1, "######## Send of Fault Radio %s, Alarm :%u", ptrname, cur_time );
							//print_dbg( DBG_LINE, 1, NULL );
						}
						else
							ptrradio_mng->radio_val[ i ].alarm_last_time = 0;

                        sys_sleep( 100 );
                    }

				}
			}
		}
	}
	
	/* DB 등록 이벤트 등록 */

	return ERR_SUCCESS;
}

static int check_fre_event( void )
{
	static volatile int fre_evt_send_cnt = 14;

	check_radio_data_event( &fre_evt_send_cnt , &g_fre_mng, g_fre_fclt_code, g_fre_tcp_sts, "FRE" );

	return ERR_SUCCESS;
}

static int check_frs_event( void )
{
	static volatile int frs_evt_send_cnt = 300;

	check_radio_data_event( &frs_evt_send_cnt , &g_frs_mng, g_frs_fclt_code, g_fre_tcp_sts, "FRS" );

	return ERR_SUCCESS;
}

static int check_sre_event( void )
{
	static volatile int sre_evt_send_cnt = 600;
	check_radio_data_event( &sre_evt_send_cnt , &g_sre_mng, g_sre_fclt_code, g_sre_tcp_sts, "SRE" );
	return ERR_SUCCESS;
}

static int check_fde_event( void )
{
	static volatile int fde_evt_send_cnt = 900;
	check_radio_data_event( &fde_evt_send_cnt , &g_fde_mng, g_fde_fclt_code, g_fde_tcp_sts, "FDE" );
	return ERR_SUCCESS;
}

/*================================================================================================
 GPIO RECV 
 ================================================================================================*/

int set_gpio_data_ctrl( mcu_data_t * ptrdata )
{
	int i;
	static int flag = 0;
	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

    //printf("###########################33 kkkkkkkkkkkkkkkkk\r\n");
	for ( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		g_di_val[ i ].last_val = ptrdata->di[ i ];
		g_do_val[ i ].last_val = ptrdata->do_[ i ];
		g_doe_val[ i ].last_val = ptrdata->doe[ i ];
	}
	g_first_mcu  = 1;
	/* 출입문 ON이 감지될때 온습도 LCD를 켠다 */
	for( i = 0 ; i < MAX_GPIO_CNT ; i++ )
	{
		if ( (g_di_val[ i ].snsr_sub_type == ESNSRSUB_DI_DOOR) && (g_di_val[ i ].last_val == 1 ))
		{
			recv_lcd_on_temp();
			break;
		}
	}

	/* di, do, doe값에 대한 Event  체크  */
	check_mcu_event(  );
	
	mapping_pwr_dev_and_doe();

	if ( g_di_test == 1 )
		return ERR_SUCCESS;

	if ( flag ++ >2 )
	{
		flag = 0;
		print_dbg( DBG_NONE, 1, "DI_1:%d, DI_2:%d, DI_3:%d, DI_4:%d, DI_5:%d, DI_6:%d, DI_7:%d, DI_8:%d",
				g_di_val[ 0 ].last_val,
				g_di_val[ 1 ].last_val,
				g_di_val[ 2 ].last_val,
				g_di_val[ 3 ].last_val,
				g_di_val[ 4 ].last_val,
				g_di_val[ 5 ].last_val,
				g_di_val[ 6 ].last_val,
				g_di_val[ 7 ].last_val);

		print_dbg( DBG_NONE, 1, "DO_1:%d, DO_2:%d, DO_3:%d, DO_4:%d, DO_5:%d, DO_6:%d, DO_7:%d, DO_8:%d",
				g_do_val[ 0 ].last_val,
				g_do_val[ 1 ].last_val,
				g_do_val[ 2 ].last_val,
				g_do_val[ 3 ].last_val,
				g_do_val[ 4 ].last_val,
				g_do_val[ 5 ].last_val,
				g_do_val[ 6 ].last_val,
				g_do_val[ 7 ].last_val);

		print_dbg( DBG_NONE, 1, "DE_1:%d, DE_2:%d, DE_3:%d, DE_4:%d, DE_5:%d, DE_6:%d, DE_7:%d, DE_8:%d",
				g_doe_val[ 0 ].last_val,
				g_doe_val[ 1 ].last_val,
				g_doe_val[ 2 ].last_val,
				g_doe_val[ 3 ].last_val,
				g_doe_val[ 4 ].last_val,
				g_doe_val[ 5 ].last_val,
				g_doe_val[ 6 ].last_val,
				g_doe_val[ 7 ].last_val);
		print_dbg( DBG_LINE,1,NULL );
	}

	return ERR_SUCCESS;
}

int set_gpio_ver_ctrl( BYTE *ptrver )
{
	if ( ptrver == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

#if 0
	print_dbg(DBG_NONE,1,"len:%x, cmd:%x, dev_id:%x, dev_addr:%x, dev_ch:%x, mode:%x, req_time:%x, check_sum:%x",
			  ptrsr->len, ptrsr->cmd, ptrsr->dev_id, ptrsr->dev_addr, ptrsr->dev_ch, ptrsr->mode, ptrsr->resp_time , ptrsr->check_sum );
#endif

	g_version.mcu_ver[ 0 ] = ptrver[ 0 ] & 0xFF;
	g_version.mcu_ver[ 1 ] = ptrver[ 1 ] & 0xFF;

	print_dbg( DBG_NONE, 1, "MCU Version: %d.%d", g_version.mcu_ver[ 0 ], g_version.mcu_ver[ 1 ]);

	return ERR_SUCCESS;

}

int set_gpio_trans_sts_ctrl( int val )
{
	int flag = 0;
    int i, snsr_id ;

	if( g_mcu_sr_timeout != val )
	{
		g_mcu_sr_timeout = val;
		send_sns_netsts( val, ESNSRTYP_DI, ESNSRSUB_DI_HEAT, SNSR_ID_UNKOWN );

		flag = 1;
        for ( i = 0 ; i < MAX_PWR_DEV_CNT ; i++ )
        {
            if ( g_pwr_dev_val[ i ].snsr_sub_type == ESNSRSUB_EQPSRE_POWER ) 
            {
                snsr_id = g_pwr_dev_val[ i ].snsr_id;
                send_sns_netsts( val, ESNSRTYP_DO, g_pwr_dev_val[ i ].snsr_sub_type, snsr_id );
                flag = 1;
                break;
            }
        }

	}
	
	if ( flag == 1 )
	{
		if( val == ESNSRCNNST_ERROR )
		{
			print_dbg( DBG_ERR,1, "MCU status once the terminal is disconnect" );  	
		}
		else if( val == ESNSRCNNST_NORMAL )
		{
			print_dbg( DBG_INFO,1, "MCU status once the terminal is connected" );  	
		}
	}
	return ERR_SUCCESS;
}

int set_gpio_do_onoff_result_ctrl( result_t * ptrresult, BYTE *ptrdata )
{
	BYTE cur_do, cur_doe;
	BYTE do_[ MAX_GPIO_CNT ];
	BYTE doe[ MAX_GPIO_CNT ];
	int i;

	if ( ptrresult == NULL || ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	if ( ptrresult->sts == ESNSRCNNST_NORMAL )
	{
		//print_dbg( DBG_INFO,1, "Success of DO Control :MsgID:%d, ClientID:%d", ptrresult->msg, ptrresult->clientid );
		/* 이력 데이터 DB Insert */
		/* Send Result */
	}
	else
	{
		print_dbg( DBG_INFO,1, "Fail of DO Control :MsgID:%d, ClientID:%d", ptrresult->msg, ptrresult->clientid );
		/* 이력 데이터 DB Insert */
		/* Send Result */
	}
	
	//BYTE pre_do, pre_doe;
	//pre_do  = ptrdata[ 0 ];
	//pre_doe = ptrdata[ 1 ];
	cur_do  = ptrdata[ 2 ];
	cur_doe = ptrdata[ 3 ];

	memset( do_, 0, sizeof( do_));
	memset( doe, 0, sizeof( doe ));

	do_[ 0 ] =  ((cur_do & 0x01)> 0 ? 1: 0);
	do_[ 1 ] = 	((cur_do & 0x02)> 0 ? 1: 0);
	do_[ 2 ] = 	((cur_do & 0x04)> 0 ? 1: 0); 
	do_[ 3 ] = 	((cur_do & 0x08)> 0 ? 1: 0); 
	do_[ 4 ] = 	((cur_do & 0x10)> 0 ? 1: 0); 
	do_[ 5 ] = 	((cur_do & 0x20)> 0 ? 1: 0); 
	do_[ 6 ] = 	((cur_do & 0x40)> 0 ? 1: 0); 
	do_[ 7 ] = 	((cur_do & 0x80)> 0 ? 1: 0);

	doe[ 0 ] =  ((cur_doe & 0x01)> 0 ? 1: 0);
	doe[ 1 ] = 	((cur_doe & 0x02)> 0 ? 1: 0);
	doe[ 2 ] = 	((cur_doe & 0x04)> 0 ? 1: 0); 
	doe[ 3 ] = 	((cur_doe & 0x08)> 0 ? 1: 0); 
	doe[ 4 ] = 	((cur_doe & 0x10)> 0 ? 1: 0); 
	doe[ 5 ] = 	((cur_doe & 0x20)> 0 ? 1: 0); 
	doe[ 6 ] = 	((cur_doe & 0x40)> 0 ? 1: 0); 
	doe[ 7 ] = 	((cur_doe & 0x80)> 0 ? 1: 0);

	if ( ptrresult->sts == ESNSRCNNST_NORMAL )
	{
		for ( i = 0 ; i < MAX_GPIO_CNT ; i++ )
		{
			g_do_val[ i ].last_val = do_[ i ];
			g_doe_val[ i ].last_val =doe[ i ];
		}
	}

	/* mcu onoff result check */
	check_sns_onoff_result( SNS_ONOFF_MCU, ptrresult->sts );

	/* Send Power Mager DOE */
	/* Set Power dev val */
	set_ctrl_mcu_etc_data_pwr_mng( doe );
	mapping_pwr_dev_and_doe();

	if ( g_di_test == 1 )
		return ERR_SUCCESS;
#if 0
	print_dbg( DBG_NONE, 1, "PRE DON_0:%d, DO_1:%d, DO_2:%d, DO_3:%d, DO_4:%d, DO_5:%d, DO_6:%d, DO_7:%d",
							(pre_do & 0x01)> 0 ? 1: 0 ,
							(pre_do & 0x02)> 0 ? 1: 0 ,
							(pre_do & 0x04)> 0 ? 1: 0 ,
							(pre_do & 0x08)> 0 ? 1: 0 ,
							(pre_do & 0x10)> 0 ? 1: 0 ,
							(pre_do & 0x20)> 0 ? 1: 0 ,
							(pre_do & 0x40)> 0 ? 1: 0 ,
							(pre_do & 0x80)> 0 ? 1: 0 );

	print_dbg( DBG_NONE, 1, "PRE DOE_0:%d, DOE_1:%d, DOE_2:%d, DO_3:%d, DO_4:%d, DO_5:%d, DO_6:%d, DO_7:%d",
							(pre_doe & 0x01)> 0 ? 1: 0 ,
							(pre_doe & 0x02)> 0 ? 1: 0 ,
							(pre_doe & 0x04)> 0 ? 1: 0 ,
							(pre_doe & 0x08)> 0 ? 1: 0 ,
							(pre_doe & 0x10)> 0 ? 1: 0 ,
							(pre_doe & 0x20)> 0 ? 1: 0 ,
							(pre_doe & 0x40)> 0 ? 1: 0 ,
							(pre_doe & 0x80)> 0 ? 1: 0 );
#endif
	print_dbg( DBG_NONE, 1, "CUR DO_1:%d, DO_2:%d, DO_3:%d, DO_4:%d, DO_5:%d, DO_6:%d, DO_7:%d, DO_8:%d",
							do_[ 0 ] ,
							do_[ 1 ] ,
							do_[ 2 ] ,
							do_[ 3 ] ,
							do_[ 4 ] ,
							do_[ 5 ] ,
							do_[ 6 ] ,
							do_[ 7 ]);

	print_dbg( DBG_NONE, 1, "CUR DE_1:%d, DE_2:%d, DE_3:%d, DE_4:%d, DE_5:%d, DE_6:%d, DE_7:%d, DE_8:%d",
							doe[ 0 ] ,
							doe[ 1 ] ,
							doe[ 2 ] ,
							doe[ 3 ] ,
							doe[ 4 ] ,
							doe[ 5 ] ,
							doe[ 6 ] ,
							doe[ 7 ] );
	
	print_dbg( DBG_LINE,1,NULL );
	return ERR_SUCCESS;
}

int set_gpio_doe_onoff_result_ctrl(result_t * ptrresult, BYTE *ptrresult_val  )
{
	return ERR_SUCCESS;

}
/*================================================================================================
 temp RECV 
 ================================================================================================*/

int set_temp_data_ctrl( temp_data_t * ptrdata   )
{
	int i; 

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
    if ( g_di_test == 0 )
    {
        print_dbg( DBG_NONE, 1, "Temp Heat Value:%.2f",ptrdata->heat );
        print_dbg( DBG_NONE, 1, "Temp Humi Value:%.2f",ptrdata->humi );
    }
    //printf("###########################temp kkkkkkkkkkkkkkkkk\r\n");

	for( i = 0 ; i < MAX_TEMP_CNT ; i++ )
	{
		if ( g_temp_val[ i ].snsr_sub_type == ESNSRSUB_AI_TEMPERATURE  )
		{
            g_temp_val[ i ].last_val = ptrdata->heat;

        }
        else if ( g_temp_val[ i ].snsr_sub_type == ESNSRSUB_AI_HUMIDITY  )
        {
            g_temp_val[ i ].last_val = ptrdata->humi;

        }
    }

	print_dbg( DBG_LINE,1,NULL );

	/* Temprature Event 체크 */
	check_temp_event( );

	return ERR_SUCCESS;
}

int set_temp_ver_ctrl( BYTE *ptrver  )
{
	if ( ptrver == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	g_version.temp_ver[ 0 ] = ptrver[ 0 ] & 0xFF;
	g_version.temp_ver[ 1 ] = ptrver[ 1 ] & 0xFF;

	print_dbg( DBG_NONE, 1, "Temprature Version: %d.%d", g_version.temp_ver[ 0 ], g_version.temp_ver[ 1 ]);
	
	return ERR_SUCCESS;
}

int set_temp_trans_sts_ctrl(int val )
{
	int flag = 0;
    int i , snsr_id;

	if( g_temp_sr_timeout != val )
	{
		g_temp_sr_timeout = val;
        for( i = 0 ; i < MAX_TEMP_CNT ; i++ )
        {
            if ( g_temp_val[ i ].snsr_id > 0 )
            {
                snsr_id = g_temp_val[ i ].snsr_id;
                send_sns_netsts( val, ESNSRTYP_AI, ESNSRSUB_AI_TEMPERATURE, snsr_id );
                flag = 1;
                break;
            }
        }

    }

	if ( flag == 1 )
	{
		if( val == ESNSRCNNST_ERROR )
		{
			print_dbg( DBG_ERR,1, "Temprature status once the terminal is disconnect" );  	
		}
		else if( val == ESNSRCNNST_NORMAL )
		{
			print_dbg( DBG_INFO,1, "Temprature status once the terminal is connected" );  	
		}
	}
	return ERR_SUCCESS;
}

/*================================================================================================
 PWR C RECV 
 ================================================================================================*/
int set_pwr_c_data_ctrl( pwr_c_data_t * ptrdata   )
{
	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
    //printf("###########################pwrc  kkkkkkkkkkkkkkkkk\r\n");

	g_pwr_c_data.val[0] = ptrdata->val[ 0 ];
	g_pwr_c_data.val[1] = ptrdata->val[ 1 ];
	g_pwr_c_data.val[2] = ptrdata->val[ 2 ];
	g_pwr_c_data.val[3] = ptrdata->val[ 3 ];
	g_pwr_c_data.val[4] = ptrdata->val[ 4 ];
	g_pwr_c_data.val[5] = ptrdata->val[ 5 ];
	
	g_first_pwr_c  = 1;

	/* 사용 안함 */
	//check_pwr_c_event();

	mapping_pwr_dev_and_pwr_c();

	if ( g_di_test == 1 )
		return ERR_SUCCESS;

	print_dbg( DBG_NONE, 1, "VOLT STS CH_1:%u, CH_2:%u, CH_3:%u, CH_4:%u, CH_5:%u, CH_6:%u", 
							 ptrdata->uval[ 0 ],ptrdata->uval[ 1 ], ptrdata->uval[ 2 ], ptrdata->uval[ 3 ], ptrdata->uval[ 4 ], ptrdata->uval[ 5 ] ); 

	print_dbg( DBG_NONE, 1, "PWR  STS CH_1:%d, CH_2:%d, CH_3:%d, CH_4:%d, CH_5:%d, CH_6:%d", 
							g_pwr_c_data.val[0],
							g_pwr_c_data.val[1],
							g_pwr_c_data.val[2],
							g_pwr_c_data.val[3],
							g_pwr_c_data.val[4],
							g_pwr_c_data.val[5]);

	print_dbg( DBG_LINE,1,NULL );
	return ERR_SUCCESS;
}

int set_pwr_c_ver_ctrl( BYTE *ptrver  )
{
	if ( ptrver == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	g_version.pwr_c_ver[ 0 ] = ptrver[ 0 ] & 0xFF;
	g_version.pwr_c_ver[ 1 ] = ptrver[ 1 ] & 0xFF;

	print_dbg( DBG_NONE, 1, "Power Control Version: %d.%d", g_version.pwr_c_ver[ 0 ], g_version.pwr_c_ver[ 1 ]);
	return ERR_SUCCESS;
}

int set_pwr_c_trans_sts_ctrl(int val )
{
	int flag = 0;
    int snsr_id = 0;
    int i;

	if( g_pwr_c_sr_timeout != val )
	{
		g_pwr_c_sr_timeout = val;

        for ( i = 0 ; i < MAX_PWR_DEV_CNT ; i++ )
        {
            if ( g_pwr_dev_val[ i ].snsr_sub_type == ESNSRSUB_EQPFRE_POWER ||
                 g_pwr_dev_val[ i ].snsr_sub_type == ESNSRSUB_EQPFDE_POWER )
            {
                snsr_id = g_pwr_dev_val[ i ].snsr_id;
				if ( snsr_id > 0  )
				{
                	send_sns_netsts( val, ESNSRTYP_DO,g_pwr_dev_val[ i ].snsr_sub_type  , snsr_id );
				}
                flag = 1;
            }
        }
	}
	
	if ( flag == 1 )
	{
		if( val == ESNSRCNNST_ERROR )
		{
			print_dbg( DBG_ERR,1, "Power C status once the terminal is disconnect" );  	
		}
		else if( val == ESNSRCNNST_NORMAL )
		{
			print_dbg( DBG_INFO,1, "Power C status once the terminal is connected" );  	
		}
	}
	return ERR_SUCCESS;
}

int set_pwr_c_onoff_result_ctrl( result_t * ptrresult, BYTE * ptrdata )
{
	BYTE val;

	if ( ptrresult == NULL || ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	if ( ptrresult->sts == ESNSRCNNST_NORMAL )
	{
		//print_dbg( DBG_INFO,1, "Success of PWR_C Control :MsgID:%d, ClientID:%d", ptrresult->msg, ptrresult->clientid );
	}
	else
	{
		print_dbg( DBG_INFO,1, "Fail of PWR_C Control :MsgID:%d, ClientID:%d", ptrresult->msg, ptrresult->clientid );
	}

	val = ptrdata[ 0 ];
	
	if ( ptrresult->sts == ESNSRCNNST_NORMAL )
	{
		g_pwr_c_data.val[0] = (val & 0x01)> 0 ? 1: 0 ;
		g_pwr_c_data.val[1] = (val & 0x02)> 0 ? 1: 0 ;
		g_pwr_c_data.val[2] = (val & 0x04)> 0 ? 1: 0 ;
		g_pwr_c_data.val[3] = (val & 0x08)> 0 ? 1: 0 ;
		g_pwr_c_data.val[4] = (val & 0x10)> 0 ? 1: 0 ;
		g_pwr_c_data.val[5] = (val & 0x20)> 0 ? 1: 0 ;
	}

	/* Send Power Manger ( &g_pwr_c_data ); */
	/* Set Power Dev Manager */

	check_sns_onoff_result( SNS_ONOFF_PWR_C, ptrresult->sts );

	set_ctrl_pwr_c_data_pwr_mng( &g_pwr_c_data );
	mapping_pwr_dev_and_pwr_c();

	if ( g_di_test == 1 )
		return ERR_SUCCESS;

	print_dbg( DBG_NONE, 1, "PWR REST CH_1:%d, CH_2:%d, CH_3:%d, CH_4:%d, CH_5:%d",
							 g_pwr_c_data.val[0] ,
							 g_pwr_c_data.val[1] ,
							 g_pwr_c_data.val[2] ,
							 g_pwr_c_data.val[3] ,
							 g_pwr_c_data.val[4] ,
							 g_pwr_c_data.val[5] ); 

	print_dbg( DBG_LINE,1,NULL );
	return ERR_SUCCESS;
}
/*================================================================================================
 PWR M RECV 
 ================================================================================================*/
int set_pwr_m_data_ctrl( pwr_m_data_t * ptrdata   )
{
	int i;
	int pos = 0;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
    //printf("###########################pwr m  kkkkkkkkkkkkkkkkk\r\n");
#if 0
	for( i =0 ; i<  MAX_PWR_M_DATA_CNT ; i++ )
	{
		printf(" pwr m val :%d, %f.................\r\n", i+1, ptrdata->fval[ i ]);
	}
#endif

	for( i = 0 ; i < MAX_PWR_M_CNT ; i++ )
	{
		if ( g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVR ||
			 g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVS ||
			 g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVT ||
			 g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERFREQ )
		{
			pos = g_pwr_m_val[ i ].data_pos;
			if ( pos >0 && pos <= 30 )
			{
				g_pwr_m_val[ i ].last_val = ptrdata->fval[ pos -1 ];	/* R volt */
			}
		}

#if 0
		/* modify 2016 11 16 */
		if ( g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVS )
		{
			g_pwr_m_val[ i ].last_val = ptrdata->fval[ 1 ];	/* S volt */
		}
		if ( g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVT )
		{
			g_pwr_m_val[ i ].last_val = ptrdata->fval[ 2 ];	/* T volt */
		}
		if ( g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERFREQ )
		{
			g_pwr_m_val[ i ].last_val = ptrdata->fval[ 12 ];	/* Freq volt */
		}
#endif

	}
#if 0	
	int i = 0;
	for( i = 0 ; i < MAX_PWR_M_DATA_CNT ;i++ )
	{
		print_dbg( DBG_INFO, 1, "idx:%d, fval:%.2f", i, ptrdata->fval[ i ] );
	}
#endif
	check_pwr_m_event();

	if ( g_di_test == 1 )
		return ERR_SUCCESS;

	for( i = 0 ; i < MAX_PWR_M_CNT ; i++ )
	{
		if ( g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVR ||
			 g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVS ||
			 g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERVT ||
			 g_pwr_m_val[ i ].snsr_sub_type == ESNSRSUB_AI_POWERFREQ )
		{
			print_dbg( DBG_NONE, 1, "Power Monitor Pos:%02d, Value :%.3f", g_pwr_m_val[ i ].data_pos, g_pwr_m_val[ i ].last_val );	/* R volt */
		}
	}

#if 0
	print_dbg( DBG_NONE, 1, "Power R Volt:%.3f, S Volt:%.3f, T Volt :%.3f, Freq:%.3f", ptrdata->fval[ 0 ], 
																				 ptrdata->fval[ 1 ], 
																				 ptrdata->fval[ 2 ], 
																				 ptrdata->fval[ 12 ]);
#endif

	print_dbg( DBG_LINE,1,NULL );

	return ERR_SUCCESS;
}

int set_pwr_m_ground_ctrl( unsigned short val )
{
	BYTE bval = 0x00;
	int flag = 0;

	flag = (val & 0x8000 ) ;

	if ( flag > 0 )
		bval =1;
	else
		bval = 0;

	g_ground_val.last_val = bval;

	check_ground_event();

	print_dbg( DBG_NONE, 1, "Power Ground Alarm sVal:%d, bVal:%d", val, g_ground_val.last_val );
  print_dbg( DBG_LINE, 1, NULL );
	return ERR_SUCCESS;
}

int set_pwr_m_ver_ctrl( BYTE *ptrver  )
{
	if ( ptrver == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	g_version.pwr_m_ver[ 0 ] = ptrver[ 0 ] & 0xFF;
	g_version.pwr_m_ver[ 1 ] = ptrver[ 1 ] & 0xFF;

	print_dbg( DBG_NONE, 1, "Power Monitor Version: %d.%d", g_version.pwr_c_ver[ 0 ], g_version.pwr_c_ver[ 1 ]);
	return ERR_SUCCESS;
}

int set_pwr_m_trans_sts_ctrl(int val )
{
	int flag = 0;

	if( g_pwr_m_sr_timeout != val )
	{
		g_pwr_m_sr_timeout = val;

        send_sns_netsts( val, ESNSRTYP_AI, ESNSRSUB_AI_POWERVR, SNSR_ID_UNKOWN );
        flag = 1;

    }
	
	if ( flag == 1 )
	{
		if( val == ESNSRCNNST_ERROR )
		{
			print_dbg( DBG_ERR,1, "Power Monitor status once the terminal is disconnect" );  	
		}
		else if( val == ESNSRCNNST_NORMAL )
		{
			print_dbg( DBG_INFO,1, "Power Monitor status once the terminal is connected" );  	
		}
	}
	return ERR_SUCCESS;
}
/*================================================================================================
 REMOTE RECV 
 ================================================================================================*/

int set_remote_data_ctrl( remote_data_t * ptrdata)
{
	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	g_remote_val.last_val = ptrdata->remote_val;

	check_remote_event();

	if ( g_di_test == 1 )
		return ERR_SUCCESS;

	print_dbg( DBG_NONE, 1, "Remote Status Val:%d", g_remote_val.last_val);
	print_dbg( DBG_LINE,1,NULL );
	
	return ERR_SUCCESS;
}

int set_remote_ver_ctrl( BYTE *ptrver  )
{
	if ( ptrver == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	g_version.remote_ver[ 0 ] = ptrver[ 0 ] & 0xFF;
	g_version.remote_ver[ 1 ] = ptrver[ 1 ] & 0xFF;

	print_dbg( DBG_NONE, 1, "Remote Version: %d.%d", g_version.remote_ver[ 0 ], g_version.remote_ver[ 1 ]);
	
	return ERR_SUCCESS;
}

int set_remote_trans_sts_ctrl(int val )
{
	int flag = 0;

	if( g_remote_sr_timeout != val )
	{
		g_remote_sr_timeout = val;
		send_sns_netsts( val, ESNSRTYP_DO, ESNSRSUB_DO_AIRCON ,g_remote_val.snsr_id );
		flag = 1;
	}
	
	if ( flag == 1 )
	{
		if( val == ESNSRCNNST_ERROR )
		{
			print_dbg( DBG_ERR,1, "Remocon status once the terminal is disconnect" );  	
		}
		else if( val == ESNSRCNNST_NORMAL )
		{
			print_dbg( DBG_INFO,1, "Remocon status once the terminal is connected" );  	
		}
	}
	return ERR_SUCCESS;
}

int set_remote_onoff_result_ctrl( result_t * ptrresult, BYTE * ptrdata )
{
	BYTE val;

	if ( ptrresult == NULL || ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	if ( ptrresult->sts == ESNSRCNNST_NORMAL )
	{
		//print_dbg( DBG_INFO,1, "Success of REMOTE Control :MsgID:%d, ClientID:%d", ptrresult->msg, ptrresult->clientid );
	}
	else
	{
		print_dbg( DBG_INFO,1, "Fail of REMOTE Control :MsgID:%d, ClientID:%d", ptrresult->msg, ptrresult->clientid );
	}

	val = ptrdata[ 0 ];

	if ( ptrresult->sts == ESNSRCNNST_NORMAL )
	{
		g_remote_val.last_val = val;
	}

	check_sns_onoff_result( SNS_ONOFF_REMOTE, ptrresult->sts );

	//print_dbg( DBG_NONE, 1, "REMOTE REST :%d", val );
	if ( g_di_test == 1 )
		return ERR_SUCCESS;

	print_dbg( DBG_LINE,1,NULL );
	
	return ERR_SUCCESS;
}

/*================================================================================================
 APC UPS RECV 
 ================================================================================================*/
int get_apc_ups_fclt_info_ctrl( fclt_info_t * ptrfclt  )
{
	int i;
	int ret = ERR_RETURN;

	if ( ptrfclt == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrfaclt is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
	
	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( g_rtu_fclt_info[ i ].fcltcode == EFCLT_UPS )
		{
			memcpy( ptrfclt, &g_rtu_fclt_info[ i ], sizeof( fclt_info_t ));
			ret = ERR_SUCCESS;
			break;
		}
	}

	return ret;
}

int get_apc_recv_data( int snsr_sub_type, ups_data_t * ptrdata )
{
	int i;
	int val;
	int sub_type;

	for( i = 0 ; i < MAX_APC_UPS_DATA_CNT ;i++ )
	{
		sub_type 	= ptrdata->sub_type[ i ];
		val 		= ptrdata->val[ i ]; 

		if ( sub_type  == snsr_sub_type )
		{
			return val;
		}
	}

	return ERR_RETURN;
}

int set_apc_ups_data_ctrl( ups_data_t * ptrdata   )
{
	int i;
	int sub_type ;
	int val;

	if ( ptrdata == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrdata is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
	
	/* di data */
	for( i = 0 ; i < MAX_APC_UPS_DATA_CNT ; i++ )
	{
		sub_type = g_apc_ups_di_val[ i ].snsr_sub_type;
		if ( sub_type <= 0 )
			break;
		val = get_apc_recv_data( sub_type, ptrdata );
		if( val >=0  )
		{
			//printf(".................UPS SUB:%d....val:%d..................\r\n", sub_type, val );
			g_apc_ups_di_val[ i ].last_val = val;
		}
	}

	check_apc_ups_di_event();

	/* ai data */
	for( i = 0 ; i < MAX_APC_UPS_DATA_CNT ; i++ )
	{
		sub_type = g_apc_ups_ai_val[ i ].snsr_sub_type;
		if ( sub_type <= 0 )
			break;
		val = get_apc_recv_data( sub_type, ptrdata );
		if( val >=0  )
		{
			//printf(".................UPS AI SUB:%d....val:%d..................\r\n", sub_type, val );
			g_apc_ups_ai_val[ i ].last_val = val;
		}
	}

	check_apc_ups_ai_event();
#if 1
	if ( g_di_test == 1 )
		return ERR_SUCCESS;
#endif
	//printf("222222kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkksssssss\r\n");
	for( i = 0 ; i < MAX_APC_UPS_DATA_CNT ; i++ )
	{
		if ( g_apc_ups_di_val[ i ].snsr_sub_type == ESNSRSUB_DI_UPS_LOW_INPUT ) 
		{
			print_dbg( DBG_NONE, 1, "UPS DI SubType :%d, Value :%d", g_apc_ups_di_val[ i ].snsr_sub_type, g_apc_ups_di_val[ i ].last_val );	/* R volt */
		}

		if ( g_apc_ups_ai_val[ i ].snsr_sub_type == ESNSRSUB_AI_UPS_BATTERY_CHARGE  ||
			 g_apc_ups_ai_val[ i ].snsr_sub_type == ESNSRSUB_AI_UPS_BATTERY_REMAIN_TIME )
		{
			print_dbg( DBG_NONE, 1, "UPS AI SubType :%d, Value :%f", g_apc_ups_ai_val[ i ].snsr_sub_type, g_apc_ups_ai_val[ i ].last_val );	/* R volt */
		}
	}

	print_dbg( DBG_LINE,1,NULL );
	return ERR_SUCCESS;
}

int set_apc_ups_trans_sts_ctrl(int val )
{
	int flag = 0;

	if( g_apc_ups_sr_timeout != val )
	{
		g_apc_ups_sr_timeout = val;
        send_sns_netsts( val, ESNSRTYP_DI, ESNSRSUB_DI_UPS_LOW_INPUT, SNSR_ID_UNKOWN );

        flag = 1;
    }
	
	if ( flag == 1 )
	{
		if( val == ESNSRCNNST_ERROR )
		{
			print_dbg( DBG_ERR,1, "APC UPS status once the terminal is disconnect" );  	
		}
		else if( val == ESNSRCNNST_NORMAL )
		{
			print_dbg( DBG_INFO,1, "APC status once the terminal is connected" );  	
		}
	}
	return ERR_SUCCESS;
}

/*================================================================================================
 전파 감시 장치  처리 함수 radio Control RECV 
 ================================================================================================*/
int get_radio_fclt_info_ctrl( int fcltcode, fclt_info_t * ptrfclt  )
{
	int i;
	int ret = ERR_RETURN;

	if ( ptrfclt == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrfaclt is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
	
	for( i = 0 ; i < MAX_FCLT_CNT ; i++ )
	{
		if ( fcltcode == g_fclt_info[ i ].fcltcode )
		{
			memcpy( ptrfclt, &g_fclt_info[ i ], sizeof( fclt_info_t ));
			ret = ERR_SUCCESS;
			break;
		}
	}

	return ret;
}

int set_radio_tcp_conn_sts_ctrl( int fclt_id, int fclt_code, int sts )
{
	int flag = 0;

	/* 고정 */
	if ( fclt_code == g_fre_fclt_code )
	{
		if ( g_fre_tcp_sts != sts )
		{
			g_fre_tcp_sts = sts;
			send_fclt_netsts( fclt_code, sts, ESNSRSUB_UNKNOWN);
			flag = 1;
		}
	}
	/* 준고정 */
	else if ( fclt_code == g_sre_fclt_code )
	{
		if ( g_sre_tcp_sts != sts )
		{
			g_sre_tcp_sts = sts;
			send_fclt_netsts( fclt_code, sts, ESNSRSUB_UNKNOWN);
			flag = 1;
		}
	}
	/* 고정 방탐 */
	else if ( fclt_code == g_fde_fclt_code )
	{
		if ( g_fde_tcp_sts != sts )
		{
			g_fde_tcp_sts = sts;
			send_fclt_netsts( fclt_code, sts , ESNSRSUB_UNKNOWN);
			flag = 1;
		}
	}
	if ( flag == 1 )
	{
		if( fclt_code > 0 && sts == ESNSRCNNST_ERROR )
		{
			print_dbg( DBG_ERR,1, "%d Notification !! EQP Tcp status once the terminal is disconnect", fclt_code );  	
		}
		else if( fclt_code > 0 && sts == ESNSRCNNST_NORMAL )
		{
			print_dbg( DBG_SAVE,1, "%d Notification !! EPQ Tcp status once the terminal is connected", fclt_code );  	
		}
	}
	return ERR_SUCCESS;
}

int set_fre_data_ctrl( radio_data_t * ptrradio )
{
	int i,j;
	int l_sub, d_sub;
	BYTE d_val;

	if ( ptrradio == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrradio is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	for ( i = 0 ; i <  MAX_RADIO_SNS_CNT ; i++ )
	{
		d_sub = ptrradio->sub_type[ i ];
		d_val = ptrradio->val[ i ];

		if( d_sub == 0 )
		{
			//printf("..................kkkkkkkkkk i:%d......\r\n", i);
			break;
		}
		for( j = 0 ; j < MAX_RADIO_SNS_CNT ; j++ )
		{
			l_sub = g_fre_mng.radio_val[ j ].snsr_sub_type;

			if ( (d_sub != 0 ) && (l_sub == d_sub) )
			{
				g_fre_mng.radio_val[ j ].last_val = d_val;

				if ( g_di_test == 0 )
				{
					print_dbg( DBG_NONE, 1, "FRE RX DATA Sub_type:%d, val:%d",g_fre_mng.radio_val[ j ].snsr_sub_type,
							g_fre_mng.radio_val[ j ].last_val );
				}
				break;
			}
		}
	}

	/* 고정 감시 장치 값에 대한 Event  체크  */
	check_fre_event(  );
	print_dbg( DBG_LINE, 1, NULL );

	return ERR_SUCCESS;
}

int set_frs_data_ctrl( radio_data_t * ptrradio )
{
	int i,j;
	int l_sub, d_sub;
	BYTE d_val;

	if ( ptrradio == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrradio is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	for ( i = 0 ; i <  MAX_RADIO_SNS_CNT ; i++ )
	{
		d_sub = ptrradio->sub_type[ i ];
		d_val = ptrradio->val[ i ];

		if( d_sub == 0 )
			break;

		for( j = 0 ; j < MAX_RADIO_SNS_CNT ; j++ )
		{
			l_sub = g_frs_mng.radio_val[ j ].snsr_sub_type;

			if ( (d_sub != 0 ) && (l_sub == d_sub) )
			{
				g_frs_mng.radio_val[ j ].last_val = d_val;

                if ( g_di_test == 0 )
                {
                    print_dbg( DBG_NONE, 1, "FRS RX DATA Sub_type:%d, val:%d",g_frs_mng.radio_val[ j ].snsr_sub_type,
                            g_frs_mng.radio_val[ j ].last_val );
                }
				break;
			}
		}
	}

	/* 고정 운영  값에 대한 Event  체크  */
	check_frs_event(  );
  	print_dbg( DBG_LINE, 1, NULL );

	return ERR_SUCCESS;
}

int set_sre_data_ctrl( radio_data_t * ptrradio )
{
	int i,j;
	int l_sub, d_sub;
	BYTE d_val;

	if ( ptrradio == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrradio is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	for ( i = 0 ; i <  MAX_RADIO_SNS_CNT ; i++ )
	{
		d_sub = ptrradio->sub_type[ i ];
		d_val = ptrradio->val[ i ];
	
		if( d_sub == 0 )
			break;

		for( j = 0 ; j < MAX_RADIO_SNS_CNT ; j++ )
		{
			l_sub = g_sre_mng.radio_val[ j ].snsr_sub_type;

			if ( (d_sub != 0 ) && (l_sub == d_sub) )
			{
				g_sre_mng.radio_val[ j ].last_val = d_val;

                if ( g_di_test == 0 )
                {
                    print_dbg( DBG_NONE, 1, "SRE RX DATA Sub_type:%d, val:%d",g_sre_mng.radio_val[ j ].snsr_sub_type,
                            g_sre_mng.radio_val[ j ].last_val );
                }
				break;
			}
		}
	}

	/* 준고정  값에 대한 Event  체크  */
	check_sre_event(  );
  	print_dbg( DBG_LINE, 1, NULL );

	return ERR_SUCCESS;
}

int set_fde_data_ctrl( radio_data_t * ptrradio )
{
	int i,j;
	int l_sub, d_sub;
	BYTE d_val;

	if ( ptrradio == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrradio is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	for ( i = 0 ; i <  MAX_RADIO_SNS_CNT ; i++ )
	{
		d_sub = ptrradio->sub_type[ i ];
		d_val = ptrradio->val[ i ];
	
		if( d_sub == 0 )
		{
			//printf("..................dddddddddddk i:%d., sub:%d.....\r\n", i, d_sub);
			break;
		}
		//printf("..................dddddddddddk i:%d., sub:%d.....\r\n", i, d_sub);

		for( j = 0 ; j < MAX_RADIO_SNS_CNT ; j++ )
		{
			l_sub = g_fde_mng.radio_val[ j ].snsr_sub_type;

			if ( (d_sub != 0 ) && (l_sub == d_sub) )
			{
				g_fde_mng.radio_val[ j ].last_val = d_val;

                if ( g_di_test == 0 )
                {
                    print_dbg( DBG_NONE, 1, "FDE RX DATA Sub_type:%d, val:%d",g_fde_mng.radio_val[ j ].snsr_sub_type,
                            g_fde_mng.radio_val[ j ].last_val );
                }
				break;
			}
		}
	}

	/* 고정 운영  값에 대한 Event  체크  */
	check_fde_event(  );
  	print_dbg( DBG_LINE, 1, NULL );

	return ERR_SUCCESS;
}

/*================================================================================================
 Power Mansger 처리 함수  
 ================================================================================================*/
int send_eqp_pwr_data_ctrl( UINT16 msg , void * ptrdata , int op_send )
{
    inter_msg_t * ptrmsg = NULL;
	ptrmsg = ( inter_msg_t *)ptrdata;
    
    if ( ptrmsg != NULL )
    {
        if ( ptrmsg->ndata == 1)
        {
            g_eqp_auto.run = 0;
            memset( &g_eqp_auto, 0, sizeof( g_eqp_auto ));

            print_dbg( DBG_INFO,1,"Release of EQP ONOFF");
        }
        else if ( ptrmsg->ndata == 9 )
        {
            g_eqp_auto.run= 1;
            g_eqp_auto.run_time = get_sectick();

            print_dbg( DBG_INFO,1,"Automod of EQP ONOFF Time:%u", g_eqp_auto.run_time );
        }
    }

	return send_data_transfer( msg, ptrdata , op_send);
}

int set_eqp_pwr_value_ctrl( void * ptrset )
{
	if ( ptrset == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrip is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	return internal_set_eqp_pwr_value_ctrl( ptrset );
}

int get_fcltip_ctrl( int fcltcode,  char * ptrip )
{
	int i ;

	if ( ptrip == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrip is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}
	
	for( i = 0 ; i < MAX_FCLT_CNT ;i++ )
	{
		if ( fcltcode == g_fclt_info[ i ].fcltcode )
		{
			memcpy( ptrip, g_fclt_info[ i ].szip , MAX_IP_SIZE );
			break;
		}
	}

	return ERR_SUCCESS;
}

int get_pwr_mthod_data_ctrl( int snsr_sub_type, pwr_mthod_mng_t * ptrmthod_mng )
{
	int i = 0;
	int l_sub_type = 0;
	int ret = ERR_RETURN;

	if ( ptrmthod_mng == NULL )
	{
		print_dbg( DBG_ERR, 1, "ptrip is Null[%s:%d:%s]", __FILE__, __LINE__,__FUNCTION__);
		return ERR_RETURN;
	}

	for( i = 0 ; i< MAX_PWR_DEV_CNT ; i++ )
	{
		l_sub_type = g_pwr_dev_val[ i ].snsr_sub_type;

		if ( l_sub_type > 0  && l_sub_type == snsr_sub_type )
		{
			memcpy( ptrmthod_mng, &g_pwr_dev_val[ i ].pwr_mthod_mng , sizeof( pwr_mthod_mng_t ));
			ret = ERR_SUCCESS;
			break;
		}
	}
	
	return ret;
}

int get_fclt_netsts_ctrl( int fcltcode )
{
	if ( fcltcode == g_fre_fclt_code  || fcltcode == g_frs_fclt_code )
	{
		return g_fre_tcp_sts;
	}
	else if ( fcltcode == g_sre_fclt_code )
	{
		return g_sre_tcp_sts;

	}
	else if ( fcltcode == g_fde_fclt_code )
	{
		return g_fde_tcp_sts;
	}

	return ESNSRCNNST_ERROR; 
}

int get_sr_netsts_ctrl( int fcltcode )
{
	if ( fcltcode == g_fre_fclt_code  || fcltcode == g_frs_fclt_code || fcltcode == g_fde_fclt_code )
	{
		return g_pwr_c_sr_timeout;
	}
	else if ( fcltcode == g_sre_fclt_code )
	{
		return g_mcu_sr_timeout;
	}

	return ESNSRCNNST_ERROR; 
}
